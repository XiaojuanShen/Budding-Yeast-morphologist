/*
 * Madstructs.cpp
 * 
 * Copyright (C) 2013 Louis-Francois Handfield
 * e-mail: lfhandfield@gmail.com
 *
 * This program is free software; upon notification by email to the licensor
 * of the licencee identity and nature of use, the licencee can redistribute
 * this program and/or modify it under the terms of the GNU General Public
 * License as published by the Free Software Foundation; either version 2 
 * of the License, or (at the licencee option) any later version. As such,
 * no further notifications are required.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 
 */

#include "Madstructs.h"

unsigned short Madstructs::font[] = {960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,
960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,384,960,960,384,0,384,960,960,960,960,960,960,960,960,960,384,0,0,0,0,0,0,0,0,0,0,0,0,1632,1632,1632,1632,0,0,1632,1632,1632,8184,8184,1632,1632,1632,1632,8184,8184,1632,1632,1632,128,192,192,2032,4088,3276,204,504,2016,3264,3276,2044,1016,192,192,64,0,48,6264,7288,3632,1792,960,224,3184,7736,7704,3072,0,0,0,0,0,0,902,1998,3128,3192,3278,1670,768,384,704,1632,1120,1728,960,384,0,0,0,0,0,0,0,0,0,0,0,0,384,384,384,384,224,192,384,384,384,384,768,768,768,768,384,384,384,384,192,224,1792,768,384,384,384,384,192,192,192,192,384,384,384,384,768,1792,0,0,0,0,0,1632,2016,384,4080,4080,384,2016,1632,0,0,0,0,0,0,0,0,384,384,384,4080,4080,384,384,384,0,0,0,384,192,192,960,960,384,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4080,4080,0,0,0,0,0,0,0,0,384,960,960,384,0,0,0,0,0,0,0,0,0,0,6144,3072,3072,1536,1536,768,768,384,384,192,192,96,96,48,48,24,
0,0,2016,4080,3696,7224,7224,6168,6168,6168,6168,7224,7224,3696,4080,2016,0,0,8184,8184,192,192,192,192,192,192,6336,7360,3776,1984,960,448,0,0,8184,8184,7168,3584,1792,896,448,224,112,6200,7192,7736,4080,2016,0,0,2016,4080,7224,6168,56,240,480,480,240,56,6168,7224,8184,4080,0,0,48,48,48,48,48,48,8184,8184,7216,3632,1840,944,496,240,0,0,2016,4080,7224,24,24,56,8176,8160,6144,6144,6144,6144,8184,8184,0,0,2016,4080,7224,6168,6168,7224,4080,4064,7168,6144,6168,7224,4080,2016,0,0,768,768,768,768,896,448,224,112,56,24,24,24,8184,8184,0,0,2016,4080,7224,6168,6168,7224,4080,2016,3120,6168,6168,7224,4080,2016,0,0,2016,4080,7224,24,24,56,2032,4080,7224,6168,6168,7224,4080,2016,0,0,384,960,960,384,0,0,0,384,960,960,384,0,0,0,384,192,192,960,960,384,0,0,0,384,960,960,384,0,0,0,0,0,0,48,240,960,3584,3584,960,240,48,0,0,0,0,0,0,0,0,0,4080,4080,0,0,4080,4080,0,0,0,0,0,0,0,0,0,3072,3840,960,112,112,960,3840,3072,0,0,0,0,0,384,960,960,384,0,384,960,960,480,240,56,24,6168,6168,3696,4080,
4088,6158,12288,25486,18395,19569,39985,38961,38961,39985,19570,18402,9092,12300,3120,960,31806,31806,12300,12300,12300,8188,8188,2072,3096,1072,1584,560,864,352,480,192,32760,32764,6158,6150,6150,6150,6150,6158,8188,8188,6158,6150,6150,6158,32764,16376,2016,8176,15416,12312,28696,24576,24576,24576,24576,24576,24576,28696,12312,15416,8176,2016,32736,32760,6204,6156,6158,6150,6150,6150,6150,6150,6150,6158,6156,6204,32760,32736,32766,32766,6144,6144,6144,6144,6144,6144,8160,8160,6144,6144,6144,6144,32766,16382,32256,32256,6144,6144,6144,6144,6144,6144,8160,8160,6144,6144,6144,6144,32766,16382,2016,8176,15416,12312,28696,24638,24638,24576,24576,24576,24624,28720,12312,15408,8176,2016,31806,31806,12300,12300,12300,12300,12300,12300,16380,16380,12300,12300,12300,12300,31806,15422,16380,16380,384,384,384,384,384,384,384,384,384,384,384,384,16380,8188,0,8064,16352,28912,24624,24632,24,24,24,24,48,48,48,48,16380,8188,30782,30782,12312,12312,12336,12336,12384,15552,16320,13184,12672,12480,12384,12336,31772,15388,32766,32766,6150,6150,6144,6144,6144,6144,6144,6144,6144,6144,6144,6144,31744,15360,24582,24582,24582,24582,24582,24582,24582,24966,24966,25542,26214,26214,27702,27702,30750,28686,24590,24606,24598,24630,24630,24678,24678,25030,24966,25478,26118,26118,27654,27654,30726,28678,960,8184,15420,12300,12300,24582,24582,24582,24582,24582,24582,12300,12300,7224,8184,960,
31744,31744,12288,12288,12288,12288,12288,16352,16376,12344,12300,12300,12300,12344,32760,16352,4038,8174,15480,12348,12404,24806,24774,24582,24582,24582,24582,12300,12300,7224,8184,960,30782,30782,12312,12312,12336,12336,12384,15552,16320,13296,12344,12300,12300,12344,32760,16352,4064,16376,30748,24590,6,6,14,4092,16368,28672,24576,24576,28678,14366,8188,2032,2016,2016,384,384,384,384,384,384,384,384,384,384,384,24966,32766,16382,2016,8184,15420,12300,28686,24582,24582,24582,24582,24582,24582,24582,24582,24582,24582,24582,384,384,960,1632,1632,3120,3120,3120,6168,6168,6168,12300,12300,12300,24582,24582,1632,3696,7800,6744,7128,13260,12684,12684,12684,24966,24966,24966,24966,24966,24966,24966,24582,24582,12300,6168,3120,1632,960,384,384,960,1632,3120,6168,12300,24582,24582,2016,2016,384,384,384,384,384,960,2016,3120,6168,6168,12300,24582,24582,24582,32766,32766,12288,6144,3072,1536,768,384,192,96,48,24,12,6,32766,32766,4080,4080,3072,3072,3072,3072,3072,3072,3072,3072,3072,3072,3072,3072,4080,4080,24,48,48,96,96,192,192,384,384,768,768,1536,1536,3072,3072,6144,4080,4080,48,48,48,48,48,48,48,48,48,48,48,48,4080,4080,0,0,0,0,0,0,0,0,6168,6168,3120,1632,832,960,384,128,16380,16380,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,128,448,384,896,768,0,0,972,2028,3128,7192,6168,6168,6168,6168,7704,4088,496,0,0,0,0,0,7104,8160,7216,6168,6168,6168,6168,6168,7216,8160,7104,6144,6144,6144,0,0,992,2032,3096,2056,6144,6144,6144,6144,3680,4080,992,0,0,0,0,0,984,2040,3128,6168,6168,6168,6168,6168,3128,2040,984,24,24,24,0,0,992,2032,3096,6152,7168,8128,6624,6192,3696,4064,960,0,0,0,0,0,768,768,768,768,768,768,4032,4032,768,768,816,816,480,192,2016,2032,56,24,2008,4088,7224,6168,6168,6168,7224,4080,2016,0,0,0,0,0,6168,6168,6168,6168,6168,6168,6168,7216,8048,7136,6272,6144,6144,6144,0,0,384,384,384,384,384,384,384,384,384,0,0,384,384,0,1920,4032,2272,96,96,96,96,96,96,240,240,0,0,96,96,0,0,0,3120,3312,3520,3840,3584,3072,3840,4032,3312,3120,3072,3072,3072,3072,0,0,384,384,384,384,384,384,384,384,384,384,384,384,384,384,0,0,6552,6552,6552,6552,6552,6552,6552,6552,7128,16376,14128,0,0,0,0,0,6168,6168,6168,6168,6168,6168,6168,6168,7224,16368,14304,0,0,0,0,0,896,2016,3184,2072,6168,6168,6168,6160,3632,2016,448,0,0,0,
6144,6144,7104,8176,7216,6168,6168,6168,6168,6168,7216,8176,7104,0,0,0,24,24,984,4088,3128,6168,6168,6168,6168,6168,3128,4088,984,0,0,0,0,0,6144,6144,6144,6144,6144,6144,6144,7704,7992,7152,6368,0,0,0,0,0,960,4064,3120,48,992,1984,3072,3120,3696,2016,384,0,0,0,0,0,384,384,384,384,384,384,384,384,384,384,4080,4080,384,384,0,0,2016,4080,6168,6168,6168,6168,6168,6168,3120,3120,3120,0,0,0,0,0,384,960,2016,3696,6168,6168,6168,6168,6168,6168,6168,0,0,0,0,0,3120,7800,7128,6552,6552,6552,6552,6552,6552,6552,6168,0,0,0,0,0,6168,7224,3696,1632,960,384,960,1632,3696,7224,6168,0,0,0,4032,4064,112,496,1968,3608,3096,6168,6168,6168,6168,6168,6168,0,0,0,0,0,8176,8184,3584,1792,896,448,224,112,48,8184,4088,0,0,0,96,192,384,384,384,768,1536,6144,1536,768,384,384,384,384,192,96,384,384,384,384,384,384,384,384,384,384,384,384,384,384,384,384,1536,768,384,384,384,192,96,24,96,192,384,384,384,384,768,1536,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,
960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,0,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,
960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,
960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,
960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,
960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,
960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,
960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,
960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960,960,3120,12300,8196,16386,16386,32769,32769,32769,32769,16386,16386,8196,12300,3120,960};



double Madstructs::cleveratof(const char* buf){
	double tmp = atof(buf);
	return(tmp != 0.0f ? tmp : (buf[0] != '0' ? NAN : 0.0f));
}


double  Madstructs::keyframeCorr(const Madstructs::CellStageKeyFrame &a, const Madstructs::CellStageKeyFrame &b){
	double tmp, tmp2;
	tmp2 = a.size_stage - b.size_stage;
	tmp =exp(-0.5f* tmp2*tmp2);
	if (&a == &b){
		return(1.0f);
	}
	if (a.type == b.type){
		if (a.type == 'l') return( a.CellProb * b.CellProb * tmp);
		else {
			tmp2 = a.MD_stage; - b.MD_stage;
			return(a.CellProb * b.CellProb *
				   ( a.MDprob * b.MDprob * exp(-0.5f* tmp2*tmp2) + (1.0f - a.MDprob) * (1.0f - b.MDprob) * tmp ));
		}
	}else if ((a.type != 'l')&&(b.type != 'l')) {
		return(a.CellProb * b.CellProb *
			   ((1.0f - a.MDprob) * (1.0f - b.MDprob) * tmp ));
	}else if (a.type == 'l') return(a.CellProb * b.CellProb * ( (1.0f - b.MDprob) * tmp ));
	else return(a.CellProb * b.CellProb * ( (1.0f - a.MDprob) * tmp ));
}
void Madstructs::memecure(char* sequence){
	int i,j;
	unsigned int same[4];
	memset(same,'\0',sizeof(int)*4);
	
	for(i=0;i<5;i++){
	if (!((sequence[i] ^ sequence[i+1]) & 95)) same[0] |= 65537 << (i+1);
	}
	for(i=0;i<4;i++){
		if (!((sequence[i] ^ sequence[i+2]) & 95)) same[1] |= 65537 << (i+2);
	}
	for(i=0;i<3;i++){
		if (!((sequence[i] ^ sequence[i+3]) & 95)) same[2] |= 65537 << (i+3);
	}
	i=6;
	while(sequence[i] != '\0'){
		
		if ((sequence[i-1] ^ sequence[i]) & 95) same[0] &= 0xFFFFFFF ^ (65537 << (i & 15));
		else same[0] |= 65537 << (i & 15);
		if ((sequence[i-2] ^ sequence[i]) & 95) same[1] &= 0xFFFFFFF ^ (65537 << (i & 15));
		else same[1] |= 65537 << (i & 15);
		if ((sequence[i-3] ^ sequence[i]) & 95) same[2] &= 0xFFFFFFF ^ (65537 << (i & 15));
		else same[2] |= 65537 << (i & 15);
		
		if (((same[2] >> (11 + (i & 15))) & 63) == 63) {
			if ((sequence[i-2] & 128) == 0){
			sequence[i] |=128;
			sequence[i-1] |=128;
			sequence[i-2] |=128;
			}
		}
		
		if (((same[1] >> (11 + (i & 15))) & 63) == 63) {
			if ((sequence[i-1] & 128) == 0){
			sequence[i] |=128;
			sequence[i-1] |=128;
			}
		}
		if (((same[0] >> (11 + (i & 15))) & 63) == 63) {
			sequence[i] |=128;
		}
		i++;
	}
	
	i=0;
	j=0;
	int k=0;
	/*
	 while(sequence[i] != '\0'){
	 if (sequence[i] & 128) sequence[i] = '#';
	 }	 
	 */
	while(sequence[i] != '\0'){
		if (sequence[i] & 128) {
			if (k !=0){
				memcpy(sequence + j, sequence + k, sizeof(char) *(i-k));
			}
			j += i-k;
			i++;
			while((sequence[i] != '\0')&&(sequence[i] & 128)) i++;
			k = i;
			if (sequence[i] == '\0') {sequence[j] = '\0'; k=0; break;}
		}
		i++;
	}
	if (k !=0){
		memcpy(sequence + j, sequence + k, sizeof(char) *(i-k));
		sequence[j +i-k] = '\0';
	}	
}

void Madstructs::fastaout(FILE* out, char* sequence, int chunksize){
	int i = strlen(sequence);
	char tmp;
	int j=0;
	while (i > chunksize){
		tmp = sequence[j*chunksize];
		sequence[(j+1)*chunksize] = '\0';
		fprintf(out,"%s\n",sequence +j*chunksize);
		j++;
		sequence[j*chunksize] = tmp;
		i -= chunksize;
	}
	if (i !=0) fprintf(out,"%s\n",sequence +j*chunksize);
}


double Madstructs::lngamma(double xx){
	double x,y,tmp,ser;
	static double cof[6]={76.18009172947146,-86.50532032941677
	,24.01409824083091, -1.231739572450155,
	0.1208650973866179e-2,-0.5395239384953e-5};
	int j;
	y=x=xx;
	tmp=x+5.5f;
	tmp-=(x+0.5)*log(tmp);
	ser= 1.000000000190015;
	for(j=0;j<=5;j++)ser += cof[j]/++y;
	return(-tmp+log(2.5066282746310005*ser/x));
}

double Madstructs::polygamma0(double xx){
	return( 32768.0f * (lngamma(xx * (1.0f + (1.0f /65536.0f))) - lngamma(xx * (1.0f - (1.0f /65536.0f)))) / xx );
}



double Madstructs::lncumhypergeoinv(int i, int a, int b, int n){
	double sum, term;
	sum = term = 1.0f;
	int j,k,l;
	double p2 = pow(2.0f,512.0f); 
	l = 0;
	k = n - a - b;
	for(j=0;j<i;){
		term *= (a - j) * (b - j);
		j++;
		term /= j * (k + j);
		sum += term;
		if (sum > p2){
			term /= p2;
			sum /= p2;
			l++;
		}
	}
	sum = log(sum) + l * log(p2);
//	printf("%f\t",sum);
	sum += lngamma(n-a+1)+ lngamma(n-b+1);//	printf("%f\t",sum);
	sum -= lngamma(n+1) + lngamma(k+1);// printf("%f\t",lngamma(n+1) + lngamma(k+1));
	return(sum);

}

double Madstructs::lncumhypergeo(int i, int a, int b, int n){
	double sum, term, osum;
	sum = term = 1.0f;
	int j,k,l;
	double p2 = pow(2.0f,512.0f); 
	l = 0;
	k = n - a - b;
	j = ( a< b) ? a : b;
	osum = lngamma(n-a-b+j+1) + lngamma(j+1) + lngamma(( a< b)? b-a+1: a-b+1);
	for(;j>i;){
		term *= j * (k + j);
		j--;
		term /= (a - j) * (b - j);
		sum += term;
		if (sum > p2){
			term /= p2;
			sum /= p2;
			l++;
		}
	//	printf("%f\t",sum);
	}
	sum = log(sum) + l * log(p2);
	//	printf("%f\t",sum);
	sum += lngamma(a+1)+lngamma(b+1)+lngamma(n-a+1)+ lngamma(n-b+1);//	printf("%f\t",sum);
	sum -= lngamma(n+1) + osum;// printf("%f\t",lngamma(n+1) + lngamma(k+1));
	return(sum);
	
}


void Madstructs::solveCubic(double* coef, double *zeros){ // 4 double, 6 double
	double tmp = 3 *coef[3];
	double q = (coef[1] - (coef[2]*coef[2] / tmp) ) / tmp;
	double r = (-1.5f*coef[0] - ( ((coef[2]*coef[2]*coef[2] / tmp) - 1.5f*coef[2]*coef[1] )/tmp) )/tmp;
//	printf("q=%f\tr=%f\n",q,r);
	
	tmp = q*q*q + r*r;
//	printf("r:%f\td:%f\n",r,q);
	double s,t,si,ti;
	if ( tmp >= 0){
//		printf("preroot: s=%f\tt=%f\n",r + sqrt(q),r - sqrt(q));
		q = sqrt(tmp);
		tmp = r + q; s = pow(fabs(tmp),1/3.0f) * ((tmp <0) ? -1.0f:1.0f);
		tmp = r - q; t = pow(fabs(tmp),1/3.0f) * ((tmp <0) ? -1.0f:1.0f);
		si = 0.0f;
		ti = 0.0f;
//		printf("s=%f\tt=%f\n",s,t);
		zeros[0] = s + t - coef[2] / (3*coef[3]);
		zeros[2] = -0.5f * (s + t) - coef[2] / (3*coef[3]);
		zeros[4] = -0.5f * (s + t) - coef[2] / (3*coef[3]);

		zeros[3] = (s-t)* sqrt(0.75f);
		zeros[5] = (t-s)* sqrt(0.75f);
	}else{
		tmp = r*r - tmp;
		t = acos(r/sqrt(tmp))/3;
		q = sqrt(-q); // q >= 0 is guarrantied!

		zeros[0] = cos(t)*q*2 - coef[2] / (3*coef[3]);
		zeros[2] = (-cos(t) +sin(t)*sqrt(3.0f) )*q - coef[2] / (3*coef[3]);
		zeros[4] = (-cos(t) -sin(t)*sqrt(3.0f) )*q - coef[2] / (3*coef[3]);
		
		zeros[3] = 0.0f; // real
		zeros[5] = 0.0f; // real
	}
	zeros[1] = 0.0f; // always real
	
} 

/* solving
 *
 * m[0]x +m[3]y +m[6]z = m[9]
 * m[1]x +m[4]y +m[7]z = m[10]
 * m[2]x +m[5]y +m[8]z = m[10]
 */
void Madstructs::solve3linear(double* m, double* outv){
	double den = m[0]*(m[4]*m[8]-m[5]*m[7]) +m[1]*(m[5]*m[6]-m[3]*m[8]) + m[2]*(m[3]*m[7]-m[4]*m[6]);
//	printf("den %f\n",den);
	//double dir[6];
	if (den != 0){
	outv[0] = (m[9]*(m[4]*m[8]-m[5]*m[7]) +m[10]*(m[5]*m[6]-m[3]*m[8]) + m[11]*(m[3]*m[7]-m[4]*m[6])) /den;
	outv[1] = (m[0]*(m[10]*m[8]-m[11]*m[7]) +m[1]*(m[11]*m[6]-m[9]*m[8]) + m[2]*(m[9]*m[7]-m[10]*m[6])) /den;
	outv[2] = (m[0]*(m[4]*m[11]-m[5]*m[10]) +m[1]*(m[5]*m[9]-m[3]*m[11]) + m[2]*(m[3]*m[10]-m[4]*m[9])) /den;
	}
}

void Madstructs::solvelinear(int size, double* matrix, double* output){
	int x,y,z,i;
	double fact;
	vector<int> miscrow;
	i=0;/*
	for(x=0;x<size;x++){
		for(y=0;y<size;y++){
			printf("%f\t",matrix[x+y*size]);
		}
		printf("= %f\n",matrix[x+y*size]);
	}
	*/
	for(z=0;z<size;z++){
		
		for(x=z-i;x<size;x++) {
			if (matrix[x+z*size] != 0) break;
		}
		if (x ==size){
			i++;
			miscrow.push_back(z);
		}else{
			
			if (x != z-i){
				
				
				
				fact = matrix[x+z*size];
				for(y=0;y<=size;y++) matrix[z-i + y*size] += matrix[x + y*size] / fact;
			}else{
				fact = matrix[z-i+z*size];
				for(y=0;y<=size;y++){
					matrix[z-i+y*size] /= fact;
				}	
			}
			
			
			
			
			for(x=0;x<size;x++){
				if (z-i != x){
					fact = matrix[x+z*size];
					for(y=z;y<=size;y++){
						matrix[x+y*size] -=  fact * matrix[z-i+y*size];
					}
				}
			}
			
		}
		
		
	}
	/*for(x=0;x<size;x++){
		for(y=0;y<size;y++){
			printf("%f\t",matrix[x+y*size]);
		}
		printf("= %f\n",matrix[x+y*size]);
	}*/
	if (miscrow.size() == 0) memcpy(output, matrix + size*size,sizeof(double)*size);
	else{
		// finding smallest vector: another system of linear equations:
		double *subsystem = new double[i*(i+1)];
		double *subout = new double[i];
		memset(subsystem,'\0',sizeof(double)*i*(i+1));
		for(x = 0;x<i;x++){
			subsystem[x + x*i] = 1.0f;
			for(y = 0;y<i;y++){
				for(z = 0;z<size;z++) subsystem[x + y*i] += matrix[z + miscrow[x]*size] * matrix[z + miscrow[y]*size];
			}
			for(z = 0;z<size;z++) subsystem[x + y*i] += matrix[z + miscrow[x]*size] * matrix[z + size*size];
			
		}
		solvelinear(i,subsystem, subout);
		delete[](subsystem);
		y=0;
		for(x=0;x<size;x++){
			if (x == miscrow[y]) {output[x] = subout[y]; y++;}
			else{
				for(z=0;z<i;z++){
					matrix[x-y + size*size] -= subout[z] * matrix[x-y + miscrow[z]*size];
				}
				output[x] = matrix[x-y + size*size];
			}
		}
		delete[](subout);
	}
}

char* Madstructs::cloneString(char* what){
	int i = strlen(what) +1;
	char* _out = new char[i];
	memcpy(_out,what,sizeof(char)*i);
	return(_out);
}

double Madstructs::determinant(double* matrix, int size, int tsize){
	tsize += size;
	if (size == 2) return(matrix[0]*matrix[tsize+1] - matrix[1]*matrix[tsize]);
	if (size == 3) return(matrix[0]*determinant(matrix + 4, 2,1) + matrix[1]*(matrix[5]*matrix[6]-matrix[3]*matrix[8]) + matrix[2]*determinant(matrix + 3, 2,1));

	return(0.0f);
}

double* Madstructs::makeinverse(double* matrix, int size){
	double* out = new double[size*size];
	int i,j;
	double det = 1.0f / determinant(matrix,size);
	printf("det %f\n",det);
	if (size == 3){
		for(i=0;i<3;i++){
			for(j=0;j<3;j++){
				out[i + j*3] = matrix[((j+1) % 3) * 3 + ((i+1) % size)]*matrix[((j+2) % 3)*3 + ((i+2) % size)] - matrix[((j+1) % 3)*3 + ((i+2) % size)]*matrix[((j+2) % 3)*3 + ((i+1) % size)];
				out[i + j*3] *= det;
			}
		}
	}
	
	return(out);
}

double Madstructs::L2norm(double x, double y){
return(sqrt(x*x + y*y));
}


char Madstructs::bitwiseswap(char r){
	char out = ((r >> 4) & 15) | (r << 4);
	out = ((out & 0x00000033) << 2) | ((out >> 2) & 0x00000033);
	out = ((out & 0x00000055) << 1) | ((out >> 1) & 0x00000055);
	return out;
}
short Madstructs::bitwiseswap(short r){
	//printf("%x\n",r);
	short out = ((r >> 8) & 255) | (r << 8);
	/*printf("%x\n",out);
	out = ((out & 0x00000F0F) << 4) | ((out >> 4) & 0x00000F0F);
	printf("%x\n",out);
	out = ((out & 0x00003333) << 2) | ((out >> 2) & 0x00003333);
	printf("%x\n",out);
	out = ((out & 0x00005555) << 1) | ((out >> 1) & 0x00005555);
	printf("%x\n",out);*/
	return out;
}

int Madstructs::bitwiseswap(int r){
	int out = ((r >> 16) & 65535) | (r << 16);
//	printf("%x\n",r);
//	printf("%x\n",out);
	out = ((out & 0x00FF00FF) << 8) | ((out >> 8) & 0x00FF00FF);
//	printf("%x\n",out);
	/*out = ((out & 0x0F0F0F0F) << 4) | ((out >> 4) & 0x0F0F0F0F);
	printf("%x\n",out);
	out = ((out & 0x33333333) << 2) | ((out >> 2) & 0x33333333);
	printf("%x\n",out);
	out = ((out & 0x55555555) << 1) | ((out >> 1) & 0x55555555);
	printf("%x\n",out);*/
	return out;
}

double Madstructs::polyeval(double* polynomial, int order, double x){
	double out = polynomial[order];
	int i;
	for(i=order-1;i>=0;i--) out = polynomial[i] + x * out;
	return(out);
}

void Madstructs::polyrootdivide(double* polynomial, int order, double root, double* out_poly){
	out_poly[order-1] = polynomial[order];
	int i;
	for(i = order-2;i>=0;i--) out_poly[i] = polynomial[i+1] + root * out_poly[i+1];
//	double err = polynomial[0] + root * out_poly[0]; // ERROR term!
	
	
	
//	printf("%f error\n",err);

}

void Madstructs::polyderivative(double* polynomial, int order, double* out_poly){
	int i;
	for(i = order;i>0;i--) out_poly[i-1] = i * polynomial[i];
}

void Madstructs::polyprintf(double* p, int order){
	int i;
	for(i = order;i>0;i--) printf("%c%fx^%i", (p[i]>= 0) ? '+' : ' ', p[i], i);
	printf("%c%f\n",(p[i]>= 0) ? '+' : ' ', p[i]);
}

void Madstructs::polysolverreal(double* polynomial, int order, vector<double> &out){
	double a,b,tmp;
	int i;
	if (order <=3){
		switch(order){
			case 1: out.push_back(-polynomial[0] / polynomial[1]); break;
			case 2:
				tmp = polynomial[1] * polynomial[1] /4.0f -  polynomial[0] * polynomial[2];
				if (tmp >=0){
					tmp = sqrt(tmp);
					out.push_back( (-polynomial[1] / 2.0f + tmp) / polynomial[2]);
					out.push_back( (-polynomial[1] / 2.0f - tmp) / polynomial[2]);
				}
			break;
			case 3:
			{
				double zeroes[6];
				solveCubic(polynomial,zeroes);
				out.push_back(zeroes[0]);
				if (zeroes[3] == 0){
					out.push_back(zeroes[2]);
					out.push_back(zeroes[4]);
				} 
			}
			break;
		}
		
		
		
	
	} else if ((order & 1)||(polynomial[order] * polynomial[0] < 0)) {

	b = (polynomial[order] * polynomial[0] < 0 ) ? 1.0f : -1.0f;
	tmp = Madstructs::polyeval(polynomial,order,b);
	while(tmp * polynomial[0] > 0) tmp = Madstructs::polyeval(polynomial,order,b *= 2);
		out.push_back(Madstructs::polybisection(polynomial,order,0,b));
   	    double* subpoly = new double[order];
		Madstructs::polyrootdivide(polynomial,order, out[out.size()-1],subpoly);
		Madstructs::polysolverreal(subpoly, order-1,out);
  	    delete[](subpoly);
    }else{
		a = 2.0f;
		for(i=0;i<10;i++){
			tmp = Madstructs::polyeval(polynomial,order,a);
			if (tmp * polynomial[0] <= 0) {b = a; break;}
			tmp = Madstructs::polyeval(polynomial,order,-a);
			if (tmp * polynomial[0] <= 0) {b = -a; break;}
			tmp = Madstructs::polyeval(polynomial,order,1/a);
			if (tmp * polynomial[0] <= 0) {b = 1/a; break;}
			tmp = Madstructs::polyeval(polynomial,order,1/-a);
			if (tmp * polynomial[0] <= 0) {b = 1/-a; break;}
			a *=2;
		}
		double* subpoly = new double[order];
		if (i >= 10){
			// complicated stuff! make sure no zero is missed!
			vector<double> dz;
			Madstructs::polyderivative(polynomial,order,subpoly);
			Madstructs::polysolverreal(subpoly, order-1,dz); // get zeroes of derivative!
			for(i=0;i<dz.size();i++){
				tmp = Madstructs::polyeval(polynomial,order,dz[i]);
				if (tmp * polynomial[0] <= 0) break;				
			}
			if (i<dz.size()) b = dz[i];
			else i = -1;
		
		}
		if (i != -1){
		out.push_back(Madstructs::polybisection(polynomial,order,0,b));
		Madstructs::polyrootdivide(polynomial,order, out[out.size()-1],subpoly);
		Madstructs::polysolverreal(subpoly, order-1,out);
		}else{
	//		printf("no root possible?\n");
	//		polyprintf(polynomial,order);
		}
		delete[](subpoly);
		return;
	}
}

double Madstructs::polybisection(double* p, int order, double a, double b){
	
	
	double x[6];
	double cubic[4];
	double zeroes[6];
	int i,j;	
	x[0] = a;
	x[3] = b;
	x[1] = 0.0f;
	x[2] = 0.0f;
	x[4] = 0.0f;
	x[5] = 0.0f;
	
	for(i=order; i>0;i--){
		x[1] = p[i] + x[0] * x[1];
		x[2] = i*p[i] + x[0] * x[2];
		x[4] = p[i] + x[3] * x[4];
		x[5] = i*p[i] + x[3] * x[5];
//		printf("%f\t",p[i]);
	}
	x[1] = p[i] + x[0] * x[1];
	x[4] = p[i] + x[3] * x[4];
	
	if (x[1] * x[4] > 0) return(NAN);
	if (x[1] < 0){
		memcpy(zeroes, x, sizeof(double)*3);
		memcpy(x, x+3, sizeof(double)*3);
		memcpy(x+3, zeroes, sizeof(double)*3);
	}
	
	
	int ite =0;
	bool needsbisection = false;
	while(true){
		if ((needsbisection)||(rand() & 15 == 15)){
			zeroes[0] = (x[3] + x[0])/2;needsbisection = false;
		}else{
			zeroes[4] = (x[0] == 0) ? x[3] : x[0];
		//	printf("%f(%f,%f) and %f(%f,%f)   %f\n", x[0],x[1],x[2],x[3],x[4], x[5],fabs((x[0] - x[3]) / zeroes[4]));
			zeroes[0] = (x[1] - x[0]*x[2]);
			zeroes[1] = (x[4] - x[3]*x[5]);
			cubic[3] = x[2] + x[5];
			cubic[2] = zeroes[0] + zeroes[1] - 2*x[2]*x[3] - 2*x[5]*x[0];
			cubic[1] = x[3]*x[3]*x[2] + x[0]*x[0]*x[5] - 2*zeroes[0]*x[3] - 2*zeroes[1]*x[0];
			cubic[0] = x[3]*x[3]*zeroes[0] + x[0]*x[0]*zeroes[1];
			solveCubic(cubic, zeroes);
			if (zeroes[3] == 0){ // three roots! pick a random one!
				j =0;
				if ((zeroes[0] > x[0])^(zeroes[0] > x[3])) j |= 1;
				if ((zeroes[2] > x[0])^(zeroes[2] > x[3])) j |= 2;
				if ((zeroes[4] > x[0])^(zeroes[4] > x[3])) j |= 4;
				switch(j){
					case 1: break;
					case 2: zeroes[0] = zeroes[2]; break;
					case 4: zeroes[0] = zeroes[4]; break;
					case 7: zeroes[0] = zeroes[2*(rand()%3)]; break;
					default:
					// was numerically unstable, do a simpler analisis!
					zeroes[0] = (x[1] * x[3] - x[0] * x[4]) / (x[1] - x[4]);						
				}
			}else{
				if (!((zeroes[0] > x[0])^(zeroes[0] > x[3]))) {
					// was numerically unstable, do a simpler analisis!
					zeroes[0] = (x[1] * x[3] - x[0] * x[4]) / (x[1] - x[4]);
				}
			}
			
		}
		
		if (!((zeroes[0] > x[0])^(zeroes[0] > x[3]))) {
			zeroes[0] = (x[3] + x[0])/2;
		}
		
		zeroes[1] = 0.0f;		zeroes[2]= 0.0f;
		for(i=order; i>0;i--){
			zeroes[1] = p[i] + zeroes[0] * zeroes[1];
			zeroes[2] = i*p[i] + zeroes[0] * zeroes[2];
		}zeroes[1] = p[i] + zeroes[0] * zeroes[1];
		if (zeroes[1] == 0) return(zeroes[0]);
		if (zeroes[0] == x[zeroes[1] < 0.0f ? 3 : 0]) needsbisection = true;
		else{
		memcpy( x + ((zeroes[1] < 0.0f)? 3 : 0) , zeroes,sizeof(double)*3);
//		if ((fabs(x[1])< pow(10.0f,-20.0f))||((fabs(x[1])< pow(10.0f,-20.0f))) break;
		zeroes[4] = (x[0] == 0) ? x[3] : x[0];
		if (fabs((x[0] - x[3]) / zeroes[4]) < pow(2.0f,-50.0f)) break;
		}
		ite++;
	}
	return(x[0]);
}
/*
void Madstructs::polysolver(double* p, int order, LFHPrimitive::complex *outval){
	int i,j;
	LFHPrimitive::complex denum, step;
	
	for(i=0;i<order;i++){
		outval[i][0] = exp(-i * 0.01) * cos(i+1);
		outval[i][1] = exp(-i * 0.01) * sin(i+1);
	}
	int ite =0;
	while(true){

	for(j=0;j<order;j++){
		step[0] = p[order];
		step[1] =0;
		for(i=order-1;i>=0;i--) {step *= outval[j] ; step[0] += p[i];}
	//	printf("%f,%f step \n", step.r,step.i);
		if (j == 0) {denum[0] = outval[1][0];denum[1] = outval[1][1]; i=2;}
		else{denum[0] = outval[0][0];denum[1] = outval[0][1];i = 1;}
		for(;i<order;i++){
			if (j != i) denum *= (outval[j] - outval[i]);
		}
		step /= denum;
		outval[j] -= step;
	}
		ite++;
		if (ite == 100) break;
	}
	
	
	
}*/
/*
void Madstructs::polysolver(double* p, int order, double *outval){

	
	double x[6];
	double cubic[4];
	double zeroes[6];
	int i,j;	
	x[0] = -1.0f + outval[0];
	x[3] = 1.0f+ outval[0];
	x[1] = 0.0f;
	x[2] = 0.0f;
	x[4] = 0.0f;
	x[5] = 0.0f;
	
	for(i=order; i>0;i--){
		x[1] = p[i] + x[0] * x[1];
		x[2] = i*p[i] + x[0] * x[2];
		x[4] = p[i] + x[3] * x[4];
		x[5] = i*p[i] + x[3] * x[5];
		printf("%f\t",p[i]);
	}
	x[1] = p[i] + x[0] * x[1];
	x[4] = p[i] + x[3] * x[4];
	
	
	printf("%f\n",p[i]);

	int ite =0;
	while(true){
		if (((x[4] * x[1]) < 0)&&((rand() & 15) == 15)){
			
			//zeroes[0] = (x[1] * x[3] - x[0] * x[4]) / (x[1] - x[4]);
			zeroes[0] = (x[3] + x[0])/2;
		}else{
		printf("%f(%f,%f) and %f(%f,%f)\n", x[0],x[1],x[2],x[3],x[4], x[5]);
			zeroes[0] = (x[1] - x[0]*x[2]);
			zeroes[1] = (x[4] - x[3]*x[5]);
		cubic[3] = x[2] + x[5];
		cubic[2] = zeroes[0] + zeroes[1] - 2*x[2]*x[3] - 2*x[5]*x[0];
		cubic[1] = x[3]*x[3]*x[2] + x[0]*x[0]*x[5] - 2*zeroes[0]*x[3] - 2*zeroes[1]*x[0];
		cubic[0] = x[3]*x[3]*zeroes[0] + x[0]*x[0]*zeroes[1];
		solveCubic(cubic, zeroes);
		if (zeroes[3] == 0){ // three roots! pick a random one!
			j =0;
			if ((zeroes[0] > x[0])^(zeroes[0] > x[3])) j |= 1;
			if ((zeroes[2] > x[0])^(zeroes[2] > x[3])) j |= 2;
			if ((zeroes[4] > x[0])^(zeroes[4] > x[3])) j |= 4;
			switch(j){
				case 1: break;
				case 2: zeroes[0] = zeroes[2]; break;
				case 4: zeroes[0] = zeroes[4]; break;
				case 3: zeroes[0] = zeroes[2*(rand()%2)]; break;
				case 6: zeroes[0] = zeroes[2 + 2*(rand()%2)]; break;
				case 5: zeroes[0] = zeroes[4*(rand()%2)]; break;
				case 0:
					if ((x[4] * x[1]) < 0){
						zeroes[0] = (x[1] * x[3] - x[0] * x[4]) / (x[1] - x[4]);
						break;
					}
				default:
				zeroes[0] = zeroes[2*(rand()%3)];
			}
		}else{
			if ((x[4] * x[1]) < 0){
				j =0;
				if ((zeroes[0] > x[0])^(zeroes[0] > x[3])) j |= 1;
				if (j != 1) {
					// was numerically unstable, do a simpler analisis!
					zeroes[0] = (x[1] * x[3] - x[0] * x[4]) / (x[1] - x[4]);

				}
			}
		}
			
		}
	//	printf("zero : %f,%f,%f \n", zeroes[0],zeroes[0],zeroes[0]);
	//	x[j] = (x[j] + zeroes[0])/2.0f;
		zeroes[1] = 0.0f;		zeroes[2]= 0.0f;
		for(i=order; i>0;i--){
			zeroes[1] = p[i] + zeroes[0] * zeroes[1];
			zeroes[2] = i*p[i] + zeroes[0] * zeroes[2];
		}zeroes[1] = p[i] + zeroes[0] * zeroes[1];
		if (((x[4] * x[1]) < 0)||(zeroes[1] * x[1] < 0)) memcpy( x + ((zeroes[1] < 0.0f)? 3 : 0) , zeroes,sizeof(double)*3);
		else memcpy( x + ((ite & 1)? 3 : 0) , zeroes,sizeof(double)*3);
		if (fabs(x[1])< pow(10.0f,-20.0f + (ite / 10))) break;
		ite++;
		

	}
	
	printf("%f(%f,%f) final\n", x[0],x[1],x[2]);
	outval[0] = x[0];
}*/	
/*
void Madstructs::polysolver(double* polynomial, int order, double *outval){
	double* p = new double[order+1];
	memcpy(p,polynomial,sizeof(double)*order);
	
	// tries to have 2 positive and 2 negative!
	
	double x[4];
	double fx[4];
	double c =0;
	
	double cubic[4];
	double zeroes[6];
	
	x[0] =1/3.0f; fx[0] = p[0];
	x[1] =-1/3.0f; fx[1] = p[0];
	x[2] =1; fx[2] = p[0];
	x[3] =-1; fx[3] = p[0];
	
	
	int i;
	double tmp = 1.0f / 3.0f;
	for(i=1;i<=order;i++){
		fx[0] +=p[i] * tmp;
		fx[1] +=p[i] * (i & 1 ? -tmp : tmp);
		fx[2] +=p[i];
		fx[3] +=p[i] * (i & 1 ? -1 : 1);
		tmp /= 3.0f;
	}
	int nbpos=0;
	for(i=0;i< 4;i++) if (fx[i] > 0) nbpos++;
	

	if (fx[0] < fx[1]){ 
		tmp = fx[1]; fx[1] = fx[0];fx[0] = tmp;
		tmp = x[1]; x[1] = x[0];x[0] = tmp;
	}
	
	if (fx[2] < fx[3]){ 
		tmp = fx[2]; fx[2] = fx[3];fx[3] = tmp;
		tmp = x[2]; x[2] = x[3];x[3] = tmp;
	}
	
	if (fx[1] < fx[2]){ 
		tmp = fx[1]; fx[1] = fx[2];fx[2] = tmp;
		tmp = x[1]; x[1] = x[2];x[2] = tmp;
	}

	
	if (fx[0] < fx[1]){ 
		tmp = fx[1]; fx[1] = fx[0];fx[0] = tmp;
		tmp = x[1]; x[1] = x[0];x[0] = tmp;
	}
	
	if (fx[2] < fx[3]){ 
		tmp = fx[2]; fx[2] = fx[3];fx[3] = tmp;
		tmp = x[2]; x[2] = x[3];x[3] = tmp;
	}
	
	while(true){
		
		memset(cubic,'\0',sizeof(double)*4);
		double tmp2 ;
		double tmp3;
		for(i=0;i<4;i++){
			tmp = 1.0f / (x[i] - x[(i+1)&3]) * (x[i] - x[(i+2)&3]) * (x[i] - x[(i+3)&3]) ;
			tmp3 = x[(i+1)&3] + x[(i+2)&3] + x[(i+3)&3];
			tmp2 = x[(i+1)&3] * x[(i+2)&3] * x[(i+3)&3];
			cubic[3] += fx[i] *tmp;
			cubic[2] -= fx[i] *tmp * tmp3;
			cubic[1] += tmp2 *tmp / tmp3;
			cubic[0] -= tmp2 *tmp;
		}	
		
	solveCubic(cubic, zeroes);
	
	if (zeroes[3] == 0){ // three roots! pick closest one!
		if (fabs(zeroes[0] - c) > fabs(zeroes[2] - c)) zeroes[0] = zeroes[2];
		if (fabs(zeroes[0] - c) > fabs(zeroes[4] - c)) zeroes[0] = zeroes[4];
	}
	tmp = 1.0f;
	tmp2 =p[order];
		int j;
	for(i=order-1;i>=0;i--) tmp2 = p[i] + tmp2 *zeroes[0]; 
		if (fabs(tmp2) < pow(10.0f,-20.0f)) break;
		if (nbpos == 2){
			j = (rand() & 1)  | ((tmp2 > 0) ? 0: 2 );
		}else if (tmp2 * (nbpos -2)< 0) {
			// a rare one has been found!
			
			if (nbpos < 2) {j = nbpos;nbpos++;}
			else {nbpos--; j = nbpos;}
		}else {
			// a rare one has not been found!
			 j = (rand() % (abs(nbpos -2)+2)) + (((tmp2 < 0)&&(nbpos ==1)) ? 1 : 0);
		}

		
		c +=  (zeroes[0] - x[j]) /4.0f;
		x[j] = zeroes[0];
		fx[j] = tmp2;
		printf("%f\t%f\t%i\t%i\n",x[j],fx[j], nbpos, j);
	}
	outval[0] = zeroes[0];
	
	
	
	delete[](p);
}
*/
int Madstructs::bimodalAnalaticalRoutine(double* rawmomments, double* in_var, double* out_means, double &out_mix){

	
	double vc = 2*rawmomments[2]+ 2* rawmomments[0]*(2*rawmomments[0]*rawmomments[0]-3*rawmomments[1]);
	double vb = in_var[1] -in_var[0];
	double va = 2*rawmomments[1] -2*rawmomments[0]*rawmomments[0]- in_var[1] - in_var[0];
//	vc = vc*vc*2;
//	printf("%f\t%f\t%f\n",va,4*fabs(va*va*va)/vc,vc);
	double tmp = 1.0f + 4*va*va*va/vc;
	double tmpmix = vc / sqrt(vc*vc + 2*va*va*va);
//		printf("DA MIXIN  %f\n",tmpmix);
	int i=0;
	double coef[6];
	if (isinf(tmpmix)||isnan(tmpmix)) {
		return(0);
	} else if (vb != 0){
		vc =2*vc*vc/ (vb*vb*vb); 
		va /= vb;
		coef[0] = 9*va -vc;
		coef[1] = 12*va*va + 9.0f;
		coef[2] = va*(4*va*va+6) +vc;
		coef[3] = -6.0f;
		coef[4] = -3.0f*va;
		coef[5] = 1.0f;
		
		for(i=0;i<100;i++){
			tmp = coef[1] + tmpmix * (2.0f * coef[2] + tmpmix * (3.0f *coef[3] + tmpmix * (4.0f *coef[4] + 5.0f *tmpmix)));
			if (tmp == 0) break;
			tmpmix -= (coef[0] + tmpmix * (coef[1] + tmpmix * (coef[2] + tmpmix * (coef[3] + tmpmix * (coef[4] + tmpmix))))) / tmp;  
			
		}

	//	printf("%f\t%f\n",tmpmix,(coef[0] + tmpmix * (coef[1] + tmpmix * (coef[2] + tmpmix * (coef[3] + tmpmix * (coef[4] + tmpmix))))));
	}

	out_mix = tmpmix;
	
	tmp = in_var[0] + in_var[1]  -  tmpmix * (in_var[1] - in_var[0]);
	tmp = -tmp *0.5f + rawmomments[1] - rawmomments[0]*rawmomments[0];
//	printf("%f\t%f\n",tmp,tmp/(1 -   tmpmix* tmpmix));
	if (fabs(tmpmix) < 1.0f){
		tmp /= (1 -   tmpmix* tmpmix);
	} else return(0);
	tmp = sqrt(fabs(tmp));
	out_means[0] = rawmomments[0] + (out_mix - 1.0f) * tmp;
	out_means[1] = rawmomments[0] + (out_mix + 1.0f) * tmp;
	return(1);
}

double Madstructs::sampleGaussian(){
	return(sqrt(-2 * log((1 + rand()) / ((float)RAND_MAX))) * cos(M_PI *2 * rand() / ((float)RAND_MAX))); 
}

double Madstructs::sampleGamma(double k, double t){
	
	return(0.0f);
}

void Madstructs::bimodalsolverold(double* rawmomments, double* out_means, double* out_std, double &out_mix){
	printf("input:	%f\t%f\t%f\t%f\t%f\n", rawmomments[0], rawmomments[1], rawmomments[2], rawmomments[3], rawmomments[4]);
	double var[2];
	var[0] =0;
	var[1] =0;
	double tmean[2];
	double mix;
	double tmp,tmp2;
	
	
	double cmpmom[6];
	double step[2];
	int i;
	int o;
	double stepmommentum[2];
	stepmommentum[0] =0.0f;
	stepmommentum[1] =0.0f;
	for(i=0;i<1000;i++){
	
	o =bimodalAnalaticalRoutine(rawmomments,var,tmean,mix);
	
		if (o ==1){
		tmp = tmean[0]*tmean[0];
	tmp2 =tmean[1]*tmean[1];
	
	cmpmom[4] = 2*rawmomments[3] - ( (1 + mix)*(tmp*tmp+6*tmp*var[0]+3*var[0]*var[0]) + (1 - mix)*(tmp2*tmp2+6*tmp2*var[1]+3*var[1]*var[1]));
	cmpmom[5] = 2*rawmomments[4] - ( (1 + mix)* tmean[0] *(tmp*tmp+10*tmp*var[0]+15*var[0]*var[0]) + (1 - mix)* tmean[1]*(tmp2*tmp2+10*tmp2*var[1]+15*var[1]*var[1]));
	cmpmom[0] = (1 + mix)*(6*tmp + 6*var[0]);	//deriv
	cmpmom[2] = (1 - mix)*(6*tmp2 + 6*var[1]);	//deriv
	cmpmom[1] = tmean[0] *(1 + mix)*(10*tmp + 30*var[0]);	//deriv
	cmpmom[3] = tmean[1] *(1 - mix)*(10*tmp2 + 30*var[1]);	//deriv
	Madstructs::solvelinear(2,cmpmom,step);
		
		
	if (isinf(step[0])||isnan(step[0])) step[0] =0.0f;
	if (isinf(step[1])||isnan(step[1])) step[1] =0.0f;
	if ((i % 100) == 0)	printf("err:	%f\t%f\t%f\t%f\t%f\t\t(%f\t%f\t%f)\n", 1.0f-(tmean[0] + tmean[1] + mix*(tmean[0] - tmean[1]))/(2*rawmomments[0]),
			   1.0f-(tmp + tmp2 + var[0] + var[1] + mix*(tmp - tmp2 + var[0] - var[1]))/(2*rawmomments[1]),
			   1.0f-(tmean[0]*(tmp + 3*var[0]) + tmean[1] *(tmp2 + 3*var[1]) + mix*(tmean[0]*(tmp + 3*var[0]) - tmean[1] *(tmp2 + 3*var[1])))/(2*rawmomments[2]),
			   cmpmom[4] / rawmomments[3],
			   cmpmom[5]/rawmomments[4],sqrt(var[0]),sqrt(var[1]),mix);		

 	if (i < 300)step[1] =step[0] = (step[1] + step[0])/2;
		stepmommentum[0] = (step[0] + 15.0f*stepmommentum[0])/16.0f;
		stepmommentum[1] = (step[1] + 15.0f*stepmommentum[1])/16.0f;
		if ((var[0]-stepmommentum[0]) < 0.0f) stepmommentum[0] = var[0] /2.0f;
		if ((var[1]-stepmommentum[1]) < 0.0f) stepmommentum[1] = var[1] /2.0f;
		}else{
			// bounce! not valid move done
			stepmommentum[0] = -stepmommentum[0]; 
			stepmommentum[1] = -stepmommentum[1];
			var[0] *= 0.95f;
			var[1] *= 0.95f;
			if (i > 990) i -=10;
		}

		var[0] = var[0]-stepmommentum[0];
		var[1] = var[1]-stepmommentum[1];
	/*	printf("err:	%f\t%f\t%f\t%f\t%f\n", 1.0f-(tmean[0] + tmean[1] + mix*(tmean[0] - tmean[1]))/(2*rawmomments[0]),
			   1.0f-(tmp + tmp2 + var[0] + var[1] + mix*(tmp - tmp2 + var[0] - var[1]))/(2*rawmomments[1]),
			   1.0f-(tmean[0]*(tmp + 3*var[0]) + tmean[1] *(tmp2 + 3*var[1]) + mix*(tmean[0]*(tmp + 3*var[0]) - tmean[1] *(tmp2 + 3*var[1])))/(2*rawmomments[2]),
			   cmpmom[4] / rawmomments[3],
			   cmpmom[5]/rawmomments[4]);	*/
	//printf("fit:	%f\t%f\t\t(%f\t%f\t%f)\n",  sqrt(var[0]),  sqrt(var[1]),tmean[0],tmean[1],mix);
	
		
	}

	
	
	out_mix = mix;
	out_means[0] = tmean[0];
	out_means[1] = tmean[1];
	out_std[0] = sqrt(var[0]);
	out_std[1] = sqrt(var[1]);

}

void Madstructs::bimodalsolver(double* rawmomments, double &mean, double &var, double &mix, double &dif_mean, double &dif_var){
	double tmp = rawmomments[0]* rawmomments[0];
	double c = rawmomments[2] - rawmomments[0] * (3.0f*rawmomments[1] - 2.0f* tmp);
	double d = rawmomments[3] - 4.0f * rawmomments[0] * rawmomments[2] - 3.0f * rawmomments[1] * rawmomments[1] + 6.0f * tmp * ( 2.0f*rawmomments[1] - tmp);
	double e = rawmomments[4] - 5.0f * rawmomments[0] * rawmomments[3] + 24.0f * tmp * tmp *rawmomments[0] + 10.0f * (rawmomments[2] - 3.0f * rawmomments[0]*rawmomments[1])*(2* tmp -rawmomments[1]);
	double z = 0.0f;
	int i;
	int b;
	double j ,m2;
//	printf("c=%f\td=%f\te=%f\n",c,d,e);
	double q,y,m;
	double err;
	mean = rawmomments[0];
	var = rawmomments[1] - rawmomments[0]*rawmomments[0];
	
	if (c != 0.0f) { //  c = 0 => z=0 is a valid solution!
	tmp = 2*c*c;
	q = d / tmp;
	y = e / tmp;
	
	double poly[4];
	poly[3] =1.0f;

		tmp = d / (2 * pow(fabs(c), 4 / 3.0f)); // * ((c<0)? -1.0f:1.0f))
		m = e / (2 * pow(fabs(c), 5 / 3.0f) * ((c<0)? -1.0f:1.0f));
		
		z = dif_var; 
	
	double polynomial[10];
		polynomial[0] = 1;
		polynomial[1] = 0;
		polynomial[2] = 7*tmp;
		polynomial[3] = -1.5f;
		polynomial[4] = 15*tmp*tmp+6*m;
		polynomial[5] = -37*tmp+3*m*m;
		polynomial[6] = 12+9*tmp*(tmp*tmp-2*m);
		polynomial[7] = 10.5f*tmp*tmp+6*m;
		polynomial[8] = -8.0f*tmp;
		polynomial[9] = 1;
		
	vector<double> polyout;
		polysolverreal(polynomial,9,polyout);
		y = (pow(fabs(c), 1 / 3.0f) * ((c<0)? -1.0f:1.0f));
	//	printf("polysolver says: ");
	//	for(i=0;i<polyout.size()-1;i++) printf("%f\t", polyout[i]*y);
	//	printf("%f\n", polyout[i]*y);
		b = -1;
		for(i=0;i<polyout.size();i++){
			z = polyout[i] * (pow(fabs(c), 1 / 3.0f) * ((c<0)? -1.0f:1.0f));
			if (z != 0.0f) q = z * ( 2 * c * c + z * (e +  z * (2 * c * z - 3 * d )) ) / (-2*c*c + z*z*(4 * z*c - 3*d) );
			else q =0;
			y = 0.5f * (3 * q - z);
			m = 1.5f * (q*q -4 *y*q+ 2*y*y); // i^2
			if (z != 0) m -= z*d / (2*c);
			if (m > 0){ //else illegal!!!
				m2 = y*y/m;
				if (m2 <= 1) { //else illegal!!!
				m = sqrt(m2) * (y < 0 ? 1.0f : -1.0f);
				y /=  m;
				q *= y;
				j = var - y*y * (1 - m * m) - m * q; // half-sum of variance
					if ((j - q >=0)&&(j + q >=0)) { // else illegal!
						
						
						
						
						if ((b == -1)||(j > err)){
							b = i;
							err = j;
//							printf("%f is legal\n",polyout[b] * (pow(fabs(c), 1 / 3.0f) * ((c<0)? -1.0f:1.0f)));
						}
					}
				}
			} 
		}
		if (b == -1){
			z =0;
			//if (polyout.size() > 0) z = polyout[0] * (pow(fabs(c), 1 / 3.0f) * ((c<0)? -1.0f:1.0f));
		} else z = polyout[b] * (pow(fabs(c), 1 / 3.0f) * ((c<0)? -1.0f:1.0f));
		
	}
	if (z != 0.0f) q = z * ( 2 * c * c + z * (e +  z * (2 * c * z - 3 * d )) ) / (-2*c*c + z*z*(4 * z*c - 3*d) );
	else q =0;
	y = 0.5f * (3 * q - z);
	m = 1.5f * (q*q -4 *y*q+ 2*y*y); // i^2
	if (z != 0) m -= z*d / (2*c);
	m = y*y/m;	
//	printf("comp q=%f\ty=%f\tm=%f\tz=%f\n",q,y,m,z);
	m = sqrt(fabs(m)) * (y < 0 ? 1.0f : -1.0f);
	y /=  m;
	q *= y;

	
	
	

//		printf("comp q=%f\ty=%f\tm=%f\tz=%f\n",q,y,m,z);
//		printf("comp z=%f\n",z);


	
	mix = m;
	dif_mean = y;
	dif_var = q;
	
}

void Madstructs::bimodalsolverGamma(double* rawmomments, double *mean, double *var, double &mix){
	double tmp = rawmomments[0]* rawmomments[0];
	double a = rawmomments[0];
	double b = rawmomments[1];
	double c = rawmomments[2];
	double d = rawmomments[3];
	double e = rawmomments[4];
/*	double a = rawmomments[0];
	double b = rawmomments[1] - tmp;
	double c = rawmomments[2] - rawmomments[0] * (3.0f*rawmomments[1] - 2.0f* tmp);
	double d = rawmomments[3] - 4.0f * rawmomments[0] * rawmomments[2] - 5.0f * rawmomments[1] * rawmomments[1] + 8.0f * tmp * ( 2.0f*rawmomments[1] - tmp);
	double e = rawmomments[4] - 3.0f * rawmomments[0] * rawmomments[3] + 12.0f * tmp * tmp *rawmomments[0] -2.0f * rawmomments[2] * rawmomments[1]+ 4.0f * (-rawmomments[2] + 3.0f * rawmomments[0]*rawmomments[1])*(2 * rawmomments[1] - 3* tmp);
*/	
	
		printf("%f\t%f\t%f\t%f\t%f  modmoments\n", a,b,c,d,e);
	/*
	 LFHMath::mm->equlist.push_back(new LFHMath::Equation("C = c-3ab+2a^3"));
	 LFHMath::mm->equlist.push_back(new LFHMath::Equation("C = 3ql-2ly"));
	 LFHMath::mm->equlist.push_back(new LFHMath::Equation("D = d-4ac-5b^2+16a^2b-8a^4"));
	 LFHMath::mm->equlist.push_back(new LFHMath::Equation("D = -4bl+4a^2l+5q^2l-12lqy+4ly^2"));
	 LFHMath::mm->equlist.push_back(new LFHMath::Equation("E = e-3ad+12a^5-10bc+12a^2c+24ab^2-36a^3b"));
	 LFHMath::mm->equlist.push_back(new LFHMath::Equation("E = -4ai^2l+16i^2ly-32i^2lq+12blq-12a^2lq+6alq^2-24alqy+12aly^2-42lq^2y+72lqy^2-24ly^3"));
	 */
	
	
	double Gmean[4];	
	double z = 0.0f;
	int i;
	int best;
	double j ,m2;
	//	printf("c=%f\td=%f\te=%f\n",c,d,e);
	double q,y,m;
	double err;

	
	if (c != 0.0f) { //  c = 0 => z=0 is a valid solution!
		tmp = 2*c*c;
		q = d / tmp;
		y = e / tmp;
		
		double poly[4];
		poly[3] =1.0f;
		
		tmp = d / (2 * pow(fabs(c), 4 / 3.0f)); // * ((c<0)? -1.0f:1.0f))
		m = e / (2 * pow(fabs(c), 5 / 3.0f) * ((c<0)? -1.0f:1.0f));
		

		
		/*
		$P = -(4BC^4+C^4a^2)
		+2z(6BC^3a^2+12B^2C^3-4C^4a-C^3D)
		+2z^2(-18B^2C^2a^2-18B^3C^2-C^2Ea+6BC^2D+3C^2Da^2+36BC^3a-6C^4)
		+2z^3(-4C^2E+40BC^3-2C^3a^2-72B^2C^2a+6BCEa-9B^2CD-18BCDa^2+18C^2Da)
		+z^4(24BCE-9D^2a^2+24BC^2a^2+6DEa-132B^2C^2-144BCDa-E^2+52C^2D-32C^3a)
		+4z^5(-9D^2a-CEa+3DE+36BC^2a-39BCD+3CDa^2-18C^3)
		+4z^6(-4CE+53BC^2-C^2a^2+18CDa-9D^2)
		+2z^7(-16C^2a+47CD)
		-60z^8(C^2)$\\
		*/
		

		
		//D = D/C
		//E = E/C
		/*
		 $P = -C^4(4B+a^2)
		 +2C^3z(6Ba^2+12B^2-4Ca-CD)
		 +2C^2z^2(-18B^2a^2-18B^3-CEa+6BCD+3CDa^2+36BCa-6C^2)
		 +2C^2z^3(-4CE+40BC-2Ca^2-72B^2a+6BEa-9B^2D-18BDa^2+18CDa)
		 +C^2z^4(24BE-9D^2a^2+24Ba^2+6DEa-132B^2-144BDa-E^2+52CD-32Ca)
		 +4C^2z^5(-9D^2a-Ea+3DE+36Ba-39BD+3Da^2-18C)
		 +4C^2z^6(-4E+53B-a^2+18Da-9D^2)
		 +2C^2z^7(-16a+47D)
		 -60C^2z^8$\\
		 */
		
		/*
		 $P = -C^4(4B+a^2)
		 +2C^3z(6Ba^2+12B^2-4Ca-D)
		 +2C^2z^2(-18B^2a^2-18B^3-Ea+6BD+3Da^2+36BCa-6C^2)
		 +2Cz^3(-4CE+40BC^2-2C^2a^2-72B^2Ca+6BEa-9B^2D-18BDa^2+18CDa)
		 +z^4(24BCE-9D^2a^2+24BC^2a^2+6DEa-132B^2C^2-144BCDa-E^2+52C^2D-32C^3a)
		 +4z^5(-9D^2a-CEa+3DE+36BC^2a-39BCD+3CDa^2-18C^3)
		 +4z^6(-4CE+53BC^2-C^2a^2+18CDa-9D^2)
		 +2Cz^7(-16Ca+47D)
		 -60C^2z^8$\\
		 */		
		/*
		 $P = -C^4(4B+a^2)
		 +2C^3z(6Ba^2+12B^2-4Ca-D)
		 +2C^2z^2(-18B^2a^2-18B^3-Ea+6BD+3Da^2+36BCa-6C^2)
		 +2Cz^3(-4CE+40BC^2-2C^2a^2-72B^2Ca+6BEa-9B^2D-18BDa^2+18CDa)
		 +z^4(24BCE-9D^2a^2+24BC^2a^2+6DEa-132B^2C^2-144BCDa-E^2+52C^2D-32C^3a)
		 +4z^5(-9D^2a-CEa+3DE+36BC^2a-39BCD+3CDa^2-18C^3)
		 +4z^6(-4CE+C^2(53B-a^2)+18CDa-9D^2)
		 +2Cz^7(-16Ca+47D)
		 -60C^2z^8$\\
		 */		
		tmp = c*c;
		double polynomial[10];
		polynomial[0] = -tmp*tmp*(4*b+a*a);
		polynomial[1] = 2*tmp*c*((6*a*a+12*b)*b-4*a*c-d);
		polynomial[2] = 2*tmp*(-18*b*b*(a*a+b)-a*e+3*d*(2*b+a*a)+36*b*c*a-6*c*c);
		polynomial[3] = 2*c*(-4*c*e+40*b*tmp-2*tmp*a*a-72*b*b*c*a+6*b*e*a-9*b*b*d-18*b*d*a*a+18*c*d*a);
		polynomial[4] = (24*c*d*e+-9*d*d*a*a+24*b*tmp*a*a+6*a*d*e-132*b*b*tmp-144*b*c*d*a-e*e+52*tmp*d-32*tmp*c*a);
		polynomial[5] = 4*(-9*d*d*a-c*e*a+3*d*e+36*b*tmp*a-39*b*c*d+3*c*d*a*a-18*tmp*c);
		polynomial[6] = 4*(-4*c*e+tmp*(53*b-a*a)+18*c*d*a-9*d*d);
		polynomial[7] = 2*c*(-16*c*a+47*d);
		polynomial[8] = -60.0f*tmp;

		
		vector<double> polyout;
		polysolverreal(polynomial,8,polyout);
		//y = (pow(fabs(c), 1 / 3.0f) * ((c<0)? -1.0f:1.0f));
		//	printf("polysolver says: ");
		//	for(i=0;i<polyout.size()-1;i++) printf("%f\t", polyout[i]*y);
		//	printf("%f\n", polyout[i]*y);
		best = -1;
		for(i=0;i<polyout.size();i++){
			z = polyout[i] *0.5f;
			m = c * (8*c-12*b*z-z*z*z);
			m = (-e *z*z-4*c*c*a+12*c*a*b*z-c*a*z*z*z+3*d*a*z*z-2*c*z*z*z*z-8*c*c*z+12*c*b*z*z+3*d*z*z*z) /m; // q
			q = -b+0.25f*z*(z- d / c) ; // q^2
			q = sqrt(fabs(q)) * ((m >=0) ? 1.0f : -1.0f);
			printf("qq = %f,%f    %f\n", q,m, z);
			j = fabs(q-m);
						if ((best == -1)||(j < err)){
							best = i;
							err = j;
							//							printf("%f is legal\n",polyout[best] * (pow(fabs(c), 1 / 3.0f) * ((c<0)? -1.0f:1.0f)));
						}

		}
		if (best == -1){
			z =0;
			//if (polyout.size() > 0) z = polyout[0] * (pow(fabs(c), 1 / 3.0f) * ((c<0)? -1.0f:1.0f));
		} else z = polyout[best] *0.5f;
		
	}
	//z = mean[0];
	
	//q = var[0] / var[1];

	m = c * (8*c-12*b*z-z*z*z);
	m = (-e *z*z-4*c*c*a+12*c*a*b*z-c*a*z*z*z+3*d*a*z*z-2*c*z*z*z*z-8*c*c*z+12*c*b*z*z+3*d*z*z*z) /m; // q
	q = -b+0.25f*z*(z- d / c) ; // q^2
	q = sqrt(fabs(q)) * ((m >=0) ? 1.0f : -1.0f);
 //   	  -Ez^2 -4C^2a   +12Cabz   -Caz^3    +3Daz^2   -2Cz^4     -8C^2z    +12Cbz^2  +3Dz^3
	//y = var[1] * mean[1];
	y = 0.5f * (3 * q - z);
//	m = var[1]*var[1];
	m = y*y + ((z == 0)? 0.0f :(c / z)); // i^2

//	m2 = mean[1]*mean[1];
	m2 = y*y/m; // x^2

	printf("comp q=%f\ty=%f\tm=%f\tz=%f\n",q,y,m,z);
	printf("comp q=%f\ty=%f\tm=%f\tz=%f\n",var[0] / var[1],var[1] * mean[1],var[1]*var[1],c / z);
	m = sqrt(m2) * (y < 0 ? 1.0f : -1.0f); // x

/*
	mean[0] = 3*vk/vi -2*vi*rmix; // 
	mean[1] = rmix; // CHEAT!
	var[0] = vk; // CHEAT!
	var[1] = vi; // CHEAT!*/
	
	
	
	
	//		printf("comp q=%f\ty=%f\tm=%f\tz=%f\n",q,y,m,z);
	//		printf("comp z=%f\n",z);
	
//			printf("z=%f\tq=%f\ty=%f\ti2=%f   recovered\n", z,q,y,m);
	m2 = y/m; // i
//	printf("h=%f\tj=%fi=%f\tk=%f   recovered\n", rawmomments[0] - y,rawmomments[1] + y*y -q*y,m2,q*m2);
	Gmean[0] = a - y + m2;
	Gmean[1] = a - y - m2;
	Gmean[2] = b + y*y -m2*m2 -q*y +  q * m2;
	Gmean[3] = b + y*y -m2*m2 -q*y -  q * m2;
	
//	printf("%f\t%f\t%f\t%f   Gmeans\n", Gmean[0],Gmean[1],Gmean[2],Gmean[3]);
	
	mean[0] = Gmean[2] + Gmean[0]*Gmean[0];
	mean[1] = Gmean[3] + Gmean[1]*Gmean[1];
	
	var[0] = mean[0] * Gmean[2]*4;
	var[1] = mean[1] * Gmean[3]*4;

	mix =m;
	

}


void Madstructs::bimodalmommentsEMGamma(double* rawmomments, double sqrtshift, double *mean, double *var, double &mix){

	double tmp = (sqrt(sqrtshift) - rawmomments[0])*(sqrt(sqrtshift) + rawmomments[0]);
	double a = rawmomments[0];
	double b = rawmomments[1] + tmp;
	double c = rawmomments[2] -3*rawmomments[0]*rawmomments[1] -2*rawmomments[0]*tmp;
	double d = rawmomments[3] -4*rawmomments[0]*rawmomments[2] - rawmomments[1]*(16*tmp+5*rawmomments[1]) -8*tmp*tmp +4*sqrtshift*(2*rawmomments[1]+tmp);
	double e = rawmomments[4] -3*rawmomments[0]*rawmomments[3] + rawmomments[1]*(rawmomments[0]*(36*tmp+24*rawmomments[1])-10*rawmomments[2]) -12*tmp*rawmomments[2]+12*rawmomments[0]*tmp*tmp+4*sqrtshift*(rawmomments[2] - rawmomments[0]*rawmomments[1]);
//	e = 0.05f;
																		//	E-3AD+36ABz+24aB^2-10BC-12cz+12aZ^2-4ABm+4mc
	printf("%f,%f,%f,%f,%f\n",rawmomments[0],rawmomments[1],rawmomments[2],rawmomments[3],rawmomments[4]);
	printf("%f,%f,%f,%f,%f,%f\n",a,b,c,d,e,tmp);
	
	
	


/*
	-3a(2Bm)+24a(2mB)-36a^3(B+m)+-10(B)(Am);
	-6Bm+48mB+36z(B+m)-46mB;

//	m(2C+Am)-3am(2B+m)+24a(B^2+2mB+m^2)-36a(m - z)(B+m)+12(m - z)(C+Am)+12a(m2-2zm)-10(ABm+mC+Am^2);
	//	m(2C+Am)-3am(2B+m)+24a(B^2+2mB+m^2)-36a(mB+m2 - zB-zm)+12(mC+Am2 - zC-zAm) +12a(m2-zm)-10(ABm+mC+Am^2);
//	4mc-12cz +(Am2)-3am(2B+m)+24a(2mB+m^2)-36a(mB+m2 - zB-zm)+12(Am2 -zAm) +12a(m2-zm)-10(ABm+Am^2);
//	4mc-12cz -4amB-36a( - zB);

//	(E+2Cm+Am2)-3a(D+2Bm+m2)+24a(B^2+2mB+m^2)^2-36a^3(B+m)+12a^2(C+Am)+12a^5-10(B+m)(C+Am);
//	(E+2Cm+Am2)-3a(D+2Bm+m2)+24a(B^2+2mB+m^2)-36a^3(B+m)+12a^2(C+Am)+12a^5-10(B+m)(C+Am);
//	12Am2 (E+2Cm)-3a(D+2Bm)+24a(B^2+2mB)-36a^3(B+m)+12a^2(C+Am)+12a^5-10(B*C+Cm+ABm);
//	(E-8Cm)-3AD+24a(B^2)-36a^3B+12amZ+12a^2(C)-12a^3Z-10B*C+32ABm;
	(E+4Cm)-3AD+24a(B^2)+4aBZ-12CZ-10BC+32ABZ+12aZ^2-4abm;

//	E-3AD-10BC+24aB^2+12aZ^2-4ABm+36ABz+4mc-12cz
	z = m - a*a*/
	
	double error[5];
	double deriv[25];
	double matrix[30];
	
	double mommentum[5];
	double vi,vk;
	double h,j,l,q,y;
	int i;
	int step;
	h = a- 1;
	if (rawmomments[1] != 0) l = -rawmomments[3] / (4*rawmomments[1]);
	else l = 0; 
	y = 1;
	j = b - l;
	q = 0;
	/*
	mean[0] =1000 + sqrtshift;
	mean[1] = 1300 +sqrtshift;
	var[0] = 100*100;
	var[1] = 200*200;
	
	j = (var[0]/(4*mean[0]) + var[1]/(4*mean[1]))/2;
	vk = (var[0]/(4*mean[0]) - var[1]/(4*mean[1]))/2;
	
	h = (sqrt(mean[0] - (j+vk)) + sqrt(mean[1] - (j-vk)))/2;
	vi = (sqrt(mean[0] - (j+vk)) - sqrt(mean[1] - (j-vk)))/2;
	mix =0.625f;
	
	y= vi*mix;
	q= vk/vi;
	l = vi*vi+y*y;*/
	memset(deriv,'\0',sizeof(double)*25);
	memset(mommentum,'\0',sizeof(double)*5);

	for(step=0;step<100;step++){
	
	
//	error[0] = (h+y-a);		h -= error[0];		error[0] =0;
	error[0] = 8*(h+y-a);
	error[1] = 6*(j+q*y+l-b);
	error[2] = 4*(l*(-2*y+3*q)-c);
	error[3] = 3*(4*l*(-l+y*y+1.25f*q*q-4*q*y-j)-d);
	error[4] = 2*(2*l*(6*l*y-10*l*q+6*j*q+8*q*y*y-12*q*q*y+h*(-2*l+4*y*y-12*q*y+3*q*q))-e);
		
		
	       //    2 (2 l(-10lq+6ly+6jq+8qy^2-12q^2y+h(-12qy+3q^2+4y^2-2l)))
printf("error:  %f,%f,%f,%f,%f\n",error[0],error[1],error[2],error[3],error[4]);
		
	double sh,sj,sl,sq,sy;
		
		sh = h*h;
		sj = j*j;
		sl = l*l;
		sq = q*q;
		sy = y*y;
		
		memset(matrix,'\0',sizeof(double)*25);
		
		matrix[0] = 64+sl*(2688*sq*sy-1152*sq*q*y-1536*q*sy*y+768*l*q*y-192*l*sq+144*sq*sq+64*sl+256*sy*sy-256*l*sy);
		matrix[1] = sl*(-1152*sq*y+288*sq*q+384*q*sy-192*l*q);
		matrix[2] = 16*h*(168*l*sq*sy-24*sl*sy+72*sl*q*y-18*sl*sq+9*l*sq*sq+8*sl*l-96*l*q*sy*y-72*l*sq*q*y+16*l*sy*sy)+96*j*(-12*l*sq*y+3*l*sq*q+4*l*q*sy-2*sl*q)+192*sl*(25*sq*y-5*sq*q-20*q*sy+4*sy*y)+128*sl*l*(5*q-3*y)+64*l*(-36*sq*sy*y+42*sq*q*sy+8*q*sy*sy-9*sq*sq*y);
		matrix[3] = 96*h*(28*sl*q*sy-2*sl*l*q-18*sl*sq*y-8*sl*sy*y+4*sl*l*y+3*sl*sq*q)+96*j*(-12*sl*q*y+3*sl*sq+4*sl*sy-2*sl*l)+32*sl*l*(84*q*y-15*sq-28*sy)+320*sl*sl*(1)+128*sl*(-24*q*sy*y+39*sq*sy+4*sy*sy-9*sq*q*y);
		matrix[4] = 64+ 16*h*(168*l*sq*sy-24*sl*sy+72*sl*q*y-18*sl*sq+9*l*sq*sq+8*sl*l-96*l*q*sy*y-72*l*sq*q*y+16*l*sy*sy)+96*j*(-12*l*sq*y+3*l*sq*q+4*l*q*sy-2*sl*q)+192*sl*(25*sq*y-5*sq*q-20*q*sy+4*sy*y)+128*sl*l*(5*q-3*y)+64*l*(-36*sq*sy*y+42*sq*q*sy+8*q*sy*sy-9*sq*sq*y);
		matrix[6] = 36+576*sl*sq* + 144*sl;
		matrix[7] = 36+ 96*h*(-4*sl*q-12*l*sq*y+3*l*sq*q+4*l*q*sy)+144*j*(l+4*l*sq)+96*sl*(3-20*sq+12*q*y)+12*l*(-12*sy-15*sq+48*q*y+64*sq*sy-96*sq*q*y);
		matrix[8] = 36*y+576*h*(-2*sl*q*y+sl*sq)+576*j*(sl*q)+24*sl*(-15*q+24*y+32*q*sy-96*sq*y)-960*sl*l*(q);
		matrix[9] = 36*q+384*h*(2*sl*q*y-3*sl*sq)+96*sl*(16*sq*y-12*sq*q-3*y+6*q)+576*sl*l*(q);
		matrix[12] = -3072*sq*q*sy*y+1024*sq*sy*sy+2304*sq*sq*sy+144*sy*sy+2664*sq*sy-1152*q*sy*y-1440*sq*q*y+225*sq*sq+64*sy-192*q*y+144*sq+64*h*(40*sl*q+162*l*sq*y-30*l*sq*q-128*l*q*sy-24*sl*y-72*sq*sy*y+84*sq*q*sy+24*l*sy*y-36*j*sq*y-12*j*l*q+9*j*sq*q+12*j*q*sy-18*sq*sq*y+16*q*sy*sy)+16*sh*(16*sy*sy+168*sq*sy-96*q*sy*y+16*sl-24*l*sq+96*l*q*y-32*l*sy-72*sq*q*y+9*sq*sq)+24*j*(-160*l*sq+96*l*q*y-96*sq*q*y+64*sq*sy+24*l-12*sy+48*q*y-15*sq)+144*sj*(4*sq+1)+64*sl*(100*sq-120*q*y+36*sy+9)+16*l*(-608*sq*sy+480*sq*q*y+192*q*sy*y-36*sy-45*sq+144*q*y);
		matrix[13] = 36*y+32*h*(20*sl*l+264*sl*q*y-75*sl*sq-108*sl*sy-12*j*sl-72*j*l*q*y+27*j*l*sq+12*j*l*sy+252*l*sq*sy-144*l*q*sy*y+16*l*sy*sy-72*l*sq*q*y)+96*sh*(28*l*q*sy+3*l*sq*q-4*sl*q-18*l*sq*y+8*sl*y-8*l*sy*y)+24*j*(-120*sl*q+48*sl*y+64*l*q*sy-144*l*sq*y-15*l*q+24*l*y)+576*sj*(l*q)+2*l*(-48*y+72*q+512*q*sy*sy-2304*sq*sy*y+2304*sq*q*sy+1332*q*sy+225*sq*q-1080*sq*y-288*sy*y)+640*sl*l*(5*q-3*y)+48*sl*(-176*q*sy+200*sq*y+32*sy*y-15*q+24*y);
		matrix[14] = 36*q+32*h*(-220*sl*q*y-216*l*sq*sy+168*l*sq*q*y+64*l*q*sy*y+153*sl*sq+60*sl*sy+24*j*l*q*y-36*j*l*sq-12*sl*l-18*l*sq*sq)+64*sh*(-8*sl*y-9*l*sq*q-36*l*q*sy+42*l*sq*y+8*l*sy*y+12*sl*q)+96*j*(6*l*q-3*l*y+16*l*sq*y-12*l*sq*q+6*sl*q)+8*l*(8*y-12*q+36*sy*y-216*q*sy+333*sq*y-90*sq*q+256*sq*sy*y-576*sq*q*sy+288*sq*sq*y)+64*sl*(-9*y+18*q-134*sq*y+60*q*sy+60*sq*q)+384*sl*l*(3*y-5*q);
		matrix[18] = 36*sy+384*h*(10*sl*l*y-5*sl*l*q-6*j*sl*y+3*j*sl*q-12*sl*sq*y+28*sl*q*sy-8*sl*sy*y)+576*sh*(sl*sq-4*sl*q*y+4*sl*sy)+384*j*(-5*sl*l+4*sl*sy-12*sl*q*y)+576*sj*(sl)+4*sl*(36+225*sq-720*q*y+576*sy+256*sy*sy-1536*q*sy*y+2304*sq*sy)+1600*sl*sl*(1)+2560*sl*l*(-sy+3*q*y);
		matrix[19] = 36*q*y + 128*h*sl*(-38*l*y+39*l*q+12*j*y-18*j*q+16*sy*y-120*q*sy+132*sq*y-18*sq*q)+768*sh*sl*(-4*sy-3*sq+8*q*y)+384*j*sl*(8*q*y-6*sq+3*l)+256*sl*l*(-38*q*y+15*sq+6*sy)-1920*sl*sl*(1)+32*sl*(128*q*sy*y-480*sq*sy+288*sq*q*y-3);
		matrix[24] = 64+ 36*sq+256*h*(16*sl*q*sy-36*sl*sq*y+6*sl*l*y-9*sl*l*q+18*sl*sq*q)+256*sh*(9*sl*sq+4*sl*sy-12*sl*q*y)+64*sl*(1+9*sy-36*q*y+36*sq+64*sq*sy-96*sq*q*y+36*sq*sq)+768*sl*l*(4*q*y-3*sq)+576*sl*sl*(1);
		
		 
		 /*
		
	hh:		64 + l^2(2688q^2y^2-1152q^3y-1536qy^3+768lqy-192lq^2+144q^4+64l^2+256y^4-256ly^2)
	hj:		l^2(-1152q^2y+288q^3+384qy^2-192lq)
	jj:		36+576l^2q^2 + 144l^2
	lh:		16h(168lq^2y^2-24l^2y^2+72l^2qy-18l^2q^2+9lq^4+8l^3-96lqy^3-72lq^3y+16ly^4)+96j(-12lq^2y+3lq^3+4lqy^2-2l^2q)+192l^2(25q^2y-5q^3-20qy^2+4y^3)+128l^3(5q-3y)+64l(-36q^2y^3+42q^3y^2+8qy^4-9q^4y)
	lj:		36 + 96h(-4l^2q-12lq^2y+3lq^3+4lqy^2)+144j(l+4lq^2)+96l^2(3-20q^2+12qy)+12l(-12y^2-15q^2+48qy+64q^2y^2-96q^3y)
	ll		-3072q^3y^3+1024q^2y^4+2304q^4y^2+144y^4+2664q^2y^2-1152qy^3-1440q^3y+225q^4+64y^2-192qy+144q^2+64h(40l^2q+162lq^2y-30lq^3-128lqy^2-24l^2y-72q^2y^3+84q^3y^2+24ly^3-36jq^2y-12jlq+9jq^3+12jqy^2-18q^4y+16qy^4)+16h^2(16y^4+168q^2y^2-96qy^3+16l^2-24lq^2+96lqy-32ly^2-72q^3y+9q^4)+24j(-160lq^2+96lqy-96q^3y+64q^2y^2+24l-12y^2+48qy-15q^2)+144j^2(4q^2+1)+64l^2(100q^2-120qy+36y^2+9)+16l(-608q^2y^2+480q^3y+192qy^3-36y^2-45q^2+144qy)
	qh		96h(28l^2qy^2-2l^3q-18l^2q^2y-8l^2y^3+4l^3y+3l^2q^3)+96j(-12l^2qy+3l^2q^2+4l^2y^2-2l^3)+32l^3(84qy-15q^2-28y^2)+320l^4(1)+128l^2(-24qy^3+39q^2y^2+4y^4-9q^3y)
	qj		36y+576h(-2l^2qy+l^2q^2)+576j(l^2q)+24l^2(-15q+24y+32qy^2-96q^2y)-960l^3(q)
	ql		36y+32h(20l^3+264l^2qy-75l^2q^2-108l^2y^2-12jl^2-72jlqy+27jlq^2+12jly^2+252lq^2y^2-144lqy^3+16ly^4-72lq^3y)+96h^2(28lqy^2+3lq^3-4l^2q-18lq^2y+8l^2y-8ly^3)+24j(-120l^2q+48l^2y+64lqy^2-144lq^2y-15lq+24ly)+576j^2(lq)+2l(-48y+72q+512qy^4-2304q^2y^3+2304q^3y^2+1332qy^2+225q^3-1080q^2y-288y^3)+640l^3(5q-3y)+48l^2(-176qy^2+200q^2y+32y^3-15q+24y)
	qq		36y^2+384h(10l^3y-5l^3q-6jl^2y+3jl^2q-12l^2q^2y+28l^2qy^2-8l^2y^3)+576h^2(l^2q^2-4l^2qy+4l^2y^2)+384j(-5l^3+4l^2y^2-12l^2qy)+576j^2(l^2)+4l^2(36+225q^2-720qy+576y^2+256y^4-1536qy^3+2304q^2y^2)+1600l^4(1)+2560l^3(-y^2+3qy)
	yh		64 + 16h(168lq^2y^2-24l^2y^2+72l^2qy-18l^2q^2+9lq^4+8l^3-96lqy^3-72lq^3y+16ly^4)+96j(-12lq^2y+3lq^3+4lqy^2-2l^2q)+192l^2(25q^2y-5q^3-20qy^2+4y^3)+128l^3(5q-3y)+64l(-36q^2y^3+42q^3y^2+8qy^4-9q^4y)
	yj		36q+384h(2l^2qy-3l^2q^2)+96l^2(16q^2y-12q^3-3y+6q)+576l^3(q)
	yl		36q+32h(-220l^2qy-216lq^2y^2+168lq^3y+64lqy^3+153l^2q^2+60l^2y^2+24jlqy-36jlq^2-12l^3-18lq^4)+64h^2(-8l^2y-9lq^3-36lqy^2+42lq^2y+8ly^3+12l^2q)+96j(6lq-3ly+16lq^2y-12lq^3+6l^2q)+8l(8y-12q+36y^3-216qy^2+333q^2y-90q^3+256q^2y^3-576q^3y^2+288q^4y)+64l^2(-9y+18q-134q^2y+60qy^2+60q^3)+384l^3(3y-5q)
	yq		36qy + 128hl^2(-38ly+39lq+12jy-18jq+16y^3-120qy^2+132q^2y-18q^3)+768h^2l^2(-4y^2-3q^2+8qy)+384jl^2(8qy-6q^2+3l)+256l^3(-38qy+15q^2+6y^2)-1920l^4(1)+32l^2(128qy^3-480q^2y^2+288q^3y-3)
	yy:		64 + 36q^2+256h(16l^2qy^2-36l^2q^2y+6l^3y-9l^3q+18l^2q^3)+256h^2(9l^2q^2+4l^2y^2-12l^2qy)+64l^2(1+9y^2-36qy+36q^2+64q^2y^2-96q^3y+36q^4)+768l^3(4qy-3q^2)+576l^4(1)
		*/
		
		
	// error dependent:
	
	matrix[19] += error[1];
	
	matrix[13] += 3*error[2];
	matrix[14] += -2*error[2];
	
	matrix[7] += -4*error[3];	
	matrix[12] += -8*error[3];	
	matrix[13] += (10*q-16*y)*error[3];	
	matrix[14] += (8*y-16*q)*error[3];	
	matrix[18] += 10*l*error[3];	
	matrix[19] += -16*l*error[3];	
	matrix[24] += 8*l*error[3];
	
	
	
		//	2l(-12qy+3q^2+4y^2-2l)
		//	2l(6q)
		//	2(-20lq+6jq+8qy^2-12q^2y+12ly+h(-12qy+3q^2+4y^2-4l))

//	2l(-12q+3q^2+8y-2l)
//	2l(-12y+6q+4y^2-2l)

	matrix[2] += 2*(-12*q*y+3*q*q+4*y*y-4*l)*error[4];	
	matrix[3] += 2*l*(-12*y+6*q)*error[4];	
	matrix[4] += 2*l*(-12*q+8*y)*error[4];	
		
	matrix[7] += 12*q*error[4];	
	matrix[8] += 12*l*error[4];	
		
	matrix[12] += 8*(3*y-5*q-h)*error[4];	
	matrix[13] += 2*(-20*l+6*j+8*y*y-24*q*y+h*(-12*y+6*q))*error[4];	
	matrix[14] += 2*(16*q*y-12*q*q+12*l+h*(-12*q+8*y))*error[4];
		
	matrix[18] += 6*l*(h-4*y)*error[4];	
	matrix[19] += 4*l*(5*y-6*q-3*h)*error[4];	
	matrix[24] += 32*l*(2*q+h)*error[4];	
	
	matrix[5] = matrix[1];
	matrix[10] = matrix[2];
	matrix[15] = matrix[3];
	matrix[20] = matrix[4];
	matrix[11] = matrix[7];
	matrix[16] = matrix[8];
	matrix[21] = matrix[9];
	matrix[17] = matrix[13];
	matrix[22] = matrix[14];
	matrix[23] = matrix[19];
	
//		2l(-10lq+6jq+8qy^2-12q^2y+6ly+h(-12qy+3q^2+4y^2-2l))
//		2l(-10lq+6jq+8qy^2-12q^2y+6ly+h(-12qy+3q^2+4y^2-2l))
//		2l(-10l+6j+8y^2-24qy+h(-12y+6q))
//		2l(16qy-12q^2+6l+h(-12q+8y))
	matrix[25] = error[0] + error[4] * (2*l*(-2*l+4*y*y-12*q*y+3*q*q));
	matrix[26] = error[1] + -4*l*error[3] +  12*l*q*error[4];
	matrix[27] = error[1] + (-2*y+3*q) * error[2] + error[4] * 2*(-20*l*q+6*j*q+8*q*y*y-12*q*q*y+12*l*y+h*(-12*q*y+3*q*q+4*y*y-4*l));
	matrix[28] = y*error[1] + 3*l*error[2]+ l*(10*q-16*y)*error[3] + error[4]*2*l*(-10*l+6*j+8*y*y-24*q*y+h*(-12*y+6*q));
	matrix[29] = error[0] + q*error[1] - 2*l*error[2] + l*(8*y-16*q)*error[3] + error[4]*2*l*(16*q*y-12*q*q+6*l+h*(-12*q+8*y));
	
//		for(i=0;i<5;i++)		printf("%f\t\t%f\t\t%f\t\t%f\t\t%f\t\t%f\n",matrix[0+i],matrix[5+i],matrix[10+i],matrix[15+i],matrix[20+i],matrix[25+i] );
	Madstructs::solvelinear(5, matrix, error);
	
//		printf("solution: %f\t\t%f\t\t%f\t\t%f\t\t%f\n",error[0],error[1],error[2],error[3],error[4]);
		printf("param:  %f,%f,%f,%f,%f\n",h,j,l,q,y);
	mommentum[0] = (-error[0] + mommentum[0]* 15)/16;
	mommentum[1] = (-error[1] + mommentum[1]* 15)/16;
	mommentum[2] = (-error[2] + mommentum[2]* 15)/16;
	mommentum[3] = (-error[3] + mommentum[3]* 15)/16;
	mommentum[4] = (-error[4] + mommentum[4]* 15)/16;


	h += mommentum[0];
	j += mommentum[1];
	l += mommentum[2];
	q += mommentum[3];
	y += mommentum[4];
	//bool valid = true;
	if ((j<0)||(q*q>j*j*(l+y*y))){
		if ((l+y*y) < 0) l = -l;
		for(i=0;i<5;i++) mommentum[i] = -mommentum[i];
		h += mommentum[0];
		j += mommentum[1];
		l += mommentum[2];
		q += mommentum[3];
		y += mommentum[4];
	}
	
		vi = sqrt(l + y*y);
		vk = vi*q;
		mix = y / vi;
	printf("i=%f k=%f x=%f\n",vi, vk, mix);

		mean[0] = (h*h + 2*h*vi + l + y*y + (j+vk));
		mean[1] = (h*h - 2*h*vi + l + y*y + (j-vk));
		var[0] = 4*(j+vk)*mean[0];
		var[1] = 4*(j-vk)*mean[1];
		mean[0] -=sqrtshift;
		mean[1] -=sqrtshift;
		
		printf("(%f, %f) (%f, %f) %f \n", mean[0], sqrt(var[0]), mean[1], sqrt(var[1]), mix);
		
	}
	
	vi = sqrt(l + y*y);
	vk = vi*q;
	mix = y / vi;
	mean[0] = (h*h + 2*h*vi + l + y*y + (j+vk));
	mean[1] = (h*h - 2*h*vi + l + y*y + (j-vk));
	var[0] = 4*(j+vk)*mean[0];
	var[1] = 4*(j-vk)*mean[1];
	mean[0] -=sqrtshift;
	mean[1] -=sqrtshift;

	
//	LFHMath::mm->equlist.push_back(new LFHMath::Equation("E-14BC+56ABZ-3AD+36AB^2-16CZ+20AZ^2+4m(C-AB) = 24lqy^2+20l^2y-32l^2q-36lq^2y+8jly-4hl^2+8hly^2-24hlqy+6hlq^2"));
//	LFHMath::mm->equlist.push_back(new LFHMath::Equation("D-16BZ-5B^2-4AC-8Z^2+4m(2B+Z) = -4l^2+4ly^2+5lq^2-16lqy-4jl"));
//	LFHMath::mm->equlist.push_back(new LFHMath::Equation("C-3AB-2AZ = l(-2y+3q)"));
//	LFHMath::mm->equlist.push_back(new LFHMath::Equation("B+Z = j+qy+l"));
//	LFHMath::mm->equlist.push_back(new LFHMath::Equation("A = h+y"));
}


/*h = mean - m * y;
 tmp = y*y;
 if (var != 0) {printf("verrfor %f is %f\n",z, fabs(var - (j + q*m + (1 - m2)*(y*y)) ) / var);}
 j = fabs(c - (1 - m2)*(3*y*q - 2*m*tmp*y))/c ; // error
 printf("err for %f is %f\n",z,j);
 if (d != 0) j += fabs(d - (1 - m2)*(tmp*tmp*(-2+6*m2) +3*q*q -12*tmp*q*m)) /d;
 printf("err for %f is %f\n",z,j);
 if (e != 0) j += fabs(e - y*(1 - m2)*(tmp*tmp*m*(16 -24*m2) -30*q*q*m + 60*m2*tmp*q -20*tmp*q)) /e;
 // $d-3b^2+12a^2b-4ac-6a^4 = (1 - x*x)(-2i^4+3k^2 -12i^2kx +6i^4x^2)$
 // $e-5ad+24a^5+30ab^2-10bc-60a^3b+20a^2c = (1 -x*x)(-20i^3k+x(16i^5-30ik^2)+x^2(60i^3k)+x^3(-24i^5))$
 printf("err for %f is %f\n",z,j);
 
 //h = mean - m * y;
 //printf("%f err\n", )
 */


// junk!
//	tmp =(((((((1*y-8*tmp)*y+10.5f*tmp*tmp+6*m)*y+12+9*tmp*tmp*tmp-18*tmp*m)*y-37*tmp+ 3*m*m)*y+15*tmp*tmp+6*m)*y-1.5f)*y+7*tmp)* y*y+1;
//	printf("%f g(z) = %f\n", y,tmp);
//	printf("polysolver says : %f   %f\n", polyout[0] *(pow(fabs(c), 1 / 3.0f) * ((c<0)? -1.0f:1.0f)) , dif_var);

//	z =  polyout[0] *(pow(fabs(c), 1 / 3.0f) * ((c<0)? -1.0f:1.0f));
/*
 for(i=0;i<100;i++){
 y = z * (pow(fabs(c), -1 / 3.0f) * ((c<0)? -1.0f:1.0f));
 tmp =(((((((1*y-8*tmp)*y+10.5f*tmp*tmp+6*m)*y+12+9*tmp*tmp*tmp-18*tmp*m)*y-37*tmp+ 3*m*m)*y+15*tmp*tmp+6*m)*y-1.5f)*y+7*tmp)* y*y+1;
 printf("%f g(z) = %f\n", z,tmp);
 g = z * z * q;
 y = e / (2*c*c);
 h = z * y;
 poly[2] = 12.0f -8*g +6*h;
 poly[1] = -1.5f + g * (-37.0f +10.5f*g -18.0f * h)  +h * (6.0f +3.0f*h);
 poly[0] = 1.0f +g *(7.0f + g*(15.0f + g * 9.0f));
 //	printf("polynomial u^3 %fu^2 %fu %f\n",poly[2],poly[1],poly[0]);
 solveCubic(poly,zeroes);
 //	printf("zero: %f\n", zeroes[0]);
 //	printf("polyeval! %f\n", poly[0]  + zeroes[0] * (poly[1]  + zeroes[0] * (poly[2]  + zeroes[0] * poly[3])) );
 if (zeroes[3] == 0.0f){ // 3 real roots! closest to estimate!
 if (fabs(zeroes[0] -zerog) > fabs(zeroes[2] -zerog)) zeroes[0] = zeroes[2];
 if (fabs(zeroes[0] -zerog) > fabs(zeroes[4] -zerog)) zeroes[0] = zeroes[4];
 }
 //	printf("polyeval! %f\n", poly[0]  + zeroes[0] * (poly[1]  + zeroes[0] * (poly[2]  + zeroes[0] * poly[3])) );
 zerog = zeroes[0];
 tmp = zeroes[0] * c;
 tmp = pow(fabs(tmp), 1 / 3.0f) * ((tmp<0)? -1.0f:1.0f);
 z = tmp;//(z * (i / 10) + tmp) / (1 + (i / 10));
 //	printf("%f\t%f\t",zerog,tmp);
 
 
 }*/

void Madstructs::bimodalsolversimple(double* rawmomments, double* out_means, double* out_std, double &out_mix){
	double matrix[30];
	double var[2];
	double mea[2];
	double mix;
	int i,j;
	double tmp,tmp2;
	
	double step[5];
	double stepm[5];
	memset(stepm,'\0',sizeof(double)*5);
	var[0] =0.0f;
	var[1] =0.0f;
	bimodalAnalaticalRoutine(rawmomments,var,mea,mix); // for initial guess
	printf("Initial Guess: %f,%f,%f\n", mea[0],mea[1], mix);
	bool err;
	for(i=0;i<100;i++){
		
		tmp = mea[0]*mea[0];
		tmp2 =mea[1]*mea[1];
		
		matrix[0] = (1 + mix);
		matrix[5] = (1 - mix);
		matrix[10] =  mea[0] -mea[1];
		matrix[15] = 0;
		matrix[20] = 0;
		
		matrix[1] =  2*(1 + mix)* (mea[0]) ;
		matrix[6] =  2*(1 - mix)* (mea[0]);
		matrix[11] = (tmp + var[0]) - (tmp2 + var[1]);
		matrix[16] = (1 + mix);
		matrix[21] = (1 - mix);
		
		matrix[2] =  (1 + mix)* (3*tmp + 3*var[0]) ;
		matrix[7] =  (1 - mix)* (3*tmp2+ 3*var[1]);
		matrix[12] = mea[0] * (tmp + 3*var[0]) -mea[1]*(tmp2+ 3*var[1]);
		matrix[17] =  (1 + mix)* mea[0] * (3);
		matrix[22] =  (1 - mix)*mea[1]*(3);
		
		matrix[3] = (1 + mix)* mea[0]*(4*tmp+12*var[0]) ;
		matrix[8] =  (1 - mix)* mea[1]*(4*tmp2+12*var[1]);
		matrix[13] = (tmp*tmp+6*tmp*var[0]+3*var[0]*var[0]) - (tmp2*tmp2+6*tmp2*var[1]+3*var[1]*var[1]);
		matrix[18] = (1 + mix)*(6*tmp+6*var[0]);
		matrix[23] = (1 - mix)*(6*tmp+6*var[1]);
		
		matrix[4] = (1 + mix) *(5*tmp*tmp+30*tmp*var[0]+15*var[0]*var[0]);
		matrix[9] = (1 - mix)*(5*tmp2*tmp2+30*tmp2*var[1]+15*var[1]*var[1]);
		matrix[14] = mea[0] *(tmp*tmp+10*tmp*var[0]+15*var[0]*var[0]) - mea[1]*(tmp2*tmp2+10*tmp2*var[1]+15*var[1]*var[1]);
		matrix[19] = (1 + mix)* mea[0] *(10*tmp+30*var[0]);
		matrix[24] = (1 - mix)* mea[1] *(10*tmp2+30*var[1]);
		
		matrix[25] = 2*rawmomments[0] - ( (1 + mix)* mea[0] + (1 - mix)*mea[1]);
		matrix[26] = 2*rawmomments[1] - ( (1 + mix)* (tmp + var[0]) + (1 - mix)*(tmp2+ var[1]));
		matrix[27] = 2*rawmomments[2] - ( (1 + mix)* mea[0] * (tmp + 3*var[0]) + (1 - mix)*mea[1]*(tmp2+ 3*var[1]));
		matrix[28] = 2*rawmomments[3] - ( (1 + mix)*(tmp*tmp+6*tmp*var[0]+3*var[0]*var[0]) + (1 - mix)*(tmp2*tmp2+6*tmp2*var[1]+3*var[1]*var[1]));
		matrix[29] = 2*rawmomments[4] - ( (1 + mix)* mea[0] *(tmp*tmp+10*tmp*var[0]+15*var[0]*var[0]) + (1 - mix)* mea[1]*(tmp2*tmp2+10*tmp2*var[1]+15*var[1]*var[1]));
	
		Madstructs::solvelinear(5,matrix,step);
		
		err = false;

		for(j=0;j<5;j++){
		if (isinf(step[j])||isnan(step[j])) {step[j] =0.0f; err = true;}
		}
		if (err){
			for(j=0;j<5;j++) stepm[j] = -stepm[j];
			}else{
			for(j=0;j<5;j++) stepm[j] = (step[j] + 15.0f*stepm[j])/16.0f;
		}
		mea[0] += stepm[0];
		mea[1] += stepm[1];
		mix += stepm[2];
		var[0] += stepm[3];
		var[1] += stepm[4];
		
		if ((var[0] < 0)||(var[1] < 0)||(fabs(mix)>1.0f)){
			mea[0] -= stepm[0];
			mea[1] -= stepm[1];
			mix -= stepm[2];
			var[0] -= stepm[3];
			var[1] -= stepm[4];
			if (!err) for(j=0;j<5;j++) stepm[j] = -stepm[j];
		}
		
		
	}
	
	out_mix = mix;
	out_means[0] = mea[0];
	out_means[1] = mea[1];
	out_std[0] = sqrt(var[0]);
	out_std[1] = sqrt(var[1]);
}
//	printf("mat:	%f\t%f\t%f\n", cmpmom[0], cmpmom[1], cmpmom[2]);		
//	printf("mat:	%f\t%f\t%f\n", cmpmom[3], cmpmom[4], cmpmom[5]);		

/*	cmpmom[4] = rawmomments[3] - (tmp*tmp+6*tmp*var[0]+3*var[0]*var[0] + tmp2*tmp2+6*tmp2*var[1]+3*var[1]*var[1] + mix*(tmp*tmp+6*tmp*var[0]+3*var[0]*var[0] - (tmp2*tmp2+6*tmp2*var[1]+3*var[1]*var[1])))/2;
 cmpmom[5] = rawmomments[4] - (tmean[0] *(tmp*tmp+10*tmp*var[0]+15*var[0]*var[0]) + tmean[1]*(tmp2*tmp2+10*tmp2*var[1]+15*var[1]*var[1]) + mix*(tmean[0] *(tmp*tmp+10*tmp*var[0]+15*var[0]*var[0]) - tmean[1]*(tmp2*tmp2+10*tmp2*var[1]+15*var[1]*var[1])))/2;
 cmpmom[0] = (1 + mix)*(6*tmp + 6*var[0]);	//deriv
 cmpmom[2] = (1 - mix)*(6*tmp2 + 6*var[1]);	//deriv
 cmpmom[1] = tmean[0] *(1 + mix)*(10*tmp + 30*var[0]);	//deriv
 cmpmom[3] = tmean[1] *(1 - mix)*(10*tmp2 + 30*var[1]);	//deriv
 
 printf("fit:	%f\t%f\n",  -cmpmom[4] + cmpmom[0] * step[0] + step[1]*cmpmom[2],  -cmpmom[5] + cmpmom[1] * step[0] + step[1]*cmpmom[3]);
 */
Madstructs::Transformed::Transformed(Madstructs::Evaluatable* target){
	int i,x;
	insize = i = target->inputsize();
	input_matrix = new double[(i+1)*i];
	memset(input_matrix,'\0',sizeof(double)*i*(i+1));
	for(x=0;x<i;x++) input_matrix[x*(i+1)] = 1.0f;
	
	outsize = i = target->outputsize();
	output_matrix = new double[(i+1)*i];
	memset(output_matrix,'\0',sizeof(double)*i*(i+1));
	for(x=0;x<i;x++) output_matrix[x*(i+1)] = 1.0f;

	intrivial = true;
	outtrivial = true;
	ev = target;
}

Madstructs::Transformed::Transformed(int ins, int outs) : ev(NULL){
	int i,x;
	insize = i = ins;
	input_matrix = new double[(i+1)*i];
	memset(input_matrix,'\0',sizeof(double)*i*(i+1));
	for(x=0;x<i;x++) input_matrix[x*(i+1)] = 1.0f;
	
	outsize = i = outs;
	output_matrix = new double[(i+1)*i];
	memset(output_matrix,'\0',sizeof(double)*i*(i+1));
	for(x=0;x<i;x++) output_matrix[x*(i+1)] = 1.0f;
	
	intrivial = true;
	outtrivial = true;


}
Madstructs::Transformed::~Transformed(){delete[](input_matrix); delete[](output_matrix);}
void Madstructs::Transformed::eval(double* coor,double* output){
	double bufferc[32];
	double buffer[32];
	int x,y;
	int oignore =0;
	if (intrivial){
		if (ev != NULL) ev->eval(coor,buffer);
		else {
			memcpy(output,coor,sizeof(double)*insize); // dummy operation
			return;
		}
	}else{
		for(x=0;x<insize;x++){
			bufferc[x] = input_matrix[insize*insize+x];
			for(y=0;y<insize;y++){
				bufferc[x] += coor[y] * input_matrix[x + y * insize];
			}
		}
		if (ev != NULL) ev->eval(bufferc,buffer);
		else{
			memcpy(output,bufferc,sizeof(double)*insize);
			return;
		}
	}

	if (ev != NULL) {
	oignore = ev->outputsize();
		oignore -= outsize;
	}
	
	if (outtrivial){memcpy(output,buffer+oignore,sizeof(double)*outsize);
	}else{
		for(x=0;x<outsize;x++){
			y=0;
			output[x] = buffer[y] * output_matrix[x + y * outsize];
			for(y++;y<outsize;y++){
				output[x] += buffer[y] * output_matrix[x + y * outsize];
			}
		}
	}
	
}
void Madstructs::Transformed::evalDerivatives(double* coor,double* output){
	double bufferc[32];
	double buffer[32*32];
	int x,y,z;
	int oignore = ev->outputsize() - outsize;
	if (intrivial) {ev->eval(coor,buffer); oignore = ev->outputsize() - outsize;}
	else{
		for(x=0;x<insize;x++){
			bufferc[x] = input_matrix[insize*insize+x];
			for(y=0;y<insize;y++){
				bufferc[x] += coor[y] * input_matrix[x + y * insize];
			}
		}
		ev->evalDerivatives(bufferc,buffer);
		
		// chain rule of joy!!!!
		for(z=oignore;z<outsize+oignore;z++){
			memset(bufferc,'\0',sizeof(double)*insize);
			for(x=0;x<insize;x++){
				for(y=0;y<insize;y++){
					bufferc[x] += buffer[z + y*(outsize+oignore)] * input_matrix[y + x * insize];
				}
			}
			for(x=0;x<insize;x++){
				buffer[z + x*(outsize+oignore)] = bufferc[x];
			}
		}
		
	}
	


	
	

	if (outtrivial){ 
		if (oignore == 0) memcpy(output,buffer,sizeof(double)*outsize*insize);
		else{
			for(x=0;x<insize;x++) memcpy(output + x*outsize, buffer +oignore +x*(outsize +oignore) ,outsize*sizeof(double));
		}
	}else{
		// for now nothing here
	}
	
}
void Madstructs::Transformed::invert(){
	bool tmpb = intrivial;
	outtrivial = intrivial;
	intrivial = tmpb;
	int tmpint = insize;
	insize = outsize;
	outsize = tmpint;
	double *tmppt = input_matrix;
	input_matrix = output_matrix;
	output_matrix = tmppt;
}

int Madstructs::Transformed::inputsize() {return(insize);}
int Madstructs::Transformed::outputsize() {return(outsize);}

void Madstructs::Transformed::rescale(int sizex, int sizey, double mean){
	double coor[2];
	double pix[32];
	double cumul[32];
	int x,y,z;
	if (ev->inputsize() != 2) exit(123);
	int nbdim = ev->outputsize();
	memset(cumul,'\0', sizeof(double)*32);
	for(y=0;y<sizey;y++) {
		coor[1] = y;
		for(x=0;x<sizex;x++){
			coor[0] = x;
			ev->eval(coor,pix);
			for(z=0;z<nbdim;z++) cumul[z] += pix[z];
		}
	}
	/*
	for(z=0;z<nbdim;z++) {
		cumul[z] += pix[z];
	}
	*/
}
void Madstructs::Transformed::renormalize(int sizex, int sizey, double mean, double std){
	
}

Madstructs::Transformed* Madstructs::Transformed::twopointsTransform(int insize, int outsize, double* sour, double* sink){
	Madstructs::Transformed* out = new Madstructs::Transformed(insize, outsize);
	double tmp;
	out->intrivial = false;
	out->input_matrix[2] =0.0f;
	out->input_matrix[5] =0.0f;
		
	out->input_matrix[6] =0.0f;
	out->input_matrix[7] =0.0f;
		
	out->input_matrix[8] =1.0f;
		
	out->input_matrix[0] = sour[2] - sour[0];
	out->input_matrix[1] = sour[3] - sour[1];
	tmp =1.0f/sqrt(out->input_matrix[0]*out->input_matrix[0] +out->input_matrix[1]*out->input_matrix[1]);
		
	out->input_matrix[0] *= -tmp;
	out->input_matrix[1] *= -tmp;
	tmp =sqrt((sink[2]-sink[0])*(sink[2]-sink[0])+(sink[3]-sink[1])*(sink[3]-sink[1]));
	out->input_matrix[0] *= tmp;
	out->input_matrix[1] *= tmp;
	out->input_matrix[3] = out->input_matrix[1];
	out->input_matrix[4] = -out->input_matrix[0];
		
	//matrix[4] = cover[1].width / (cover[1].width + cover[0].width) - jpos[0] * matrix[0] - jpos[1] * matrix[2];
	out->input_matrix[9] = sink[0];
	out->input_matrix[10] = sink[1];	
	out->input_matrix[11] = sink[4];
	
	return(out);
} // coordinates of two (distinc) point in the input and output, which defines a mapping


Madstructs::ConcatOperator::ConcatOperator(Madstructs::Evaluatable* _para,Madstructs::Evaluatable* _parb): para(_para), parb(_parb){}
void Madstructs::ConcatOperator::eval(double* coor,double* output){
	para->eval(coor,output);
	parb->eval(coor,output + para->outputsize());
}
void Madstructs::ConcatOperator::evalDerivatives(double* coor,double* output){
	int sa= para->outputsize();
	int sb = parb->outputsize();
	int sc = para->inputsize();
	double* tmpbuf = new double[sb*sc];
	para->evalDerivatives(coor,output);
	parb->evalDerivatives(coor,tmpbuf);
	int i;
	
	
	for(i=sc-1;i>=1;i--) memcpy(output+i * (sa+sb),output+i * (sa), sizeof(double)*sa);
	for(i=sc-1;i>=0;i--) memcpy(output+sa+i * (sa+sb),tmpbuf+i * (sb), sizeof(double)*sb);
	delete[](tmpbuf);
}
int Madstructs::ConcatOperator::inputsize(){return(para->inputsize());}
int Madstructs::ConcatOperator::outputsize(){return(para->outputsize() + parb->outputsize());}

Madstructs::SubPartOperator::SubPartOperator(int _start, int _nbchannels, Madstructs::Evaluatable* _what): start(_start), nbchannels(_nbchannels), para(_what){
}

void Madstructs::SubPartOperator::eval(double* coor,double* output){
	double* buffer = new double[para->outputsize()];
	para->eval(coor,buffer);
	memcpy(output,buffer+start, sizeof(double)*nbchannels);
	delete[](buffer);
}
void Madstructs::SubPartOperator::evalDerivatives(double* coor,double* output){
	double* buffer = new double[para->inputsize()*para->outputsize()];
	int i;
	para->evalDerivatives(coor,buffer);
	for(i=0;i<para->inputsize();i++) memcpy(output+nbchannels*i,buffer + start + para->outputsize()*i, sizeof(double)*nbchannels);
	delete[](buffer);
}
int Madstructs::SubPartOperator::inputsize(){return(para->inputsize());}
int Madstructs::SubPartOperator::outputsize(){return(nbchannels);}

/*
 PROTEIN stuff
 
 double Madstructs::Classifier::getPriorMean(int inp,int state){
 if (inp == 0){
 if (state == 0) return(3.2f);
 if (state == 1) return(13.0f);
 if (state == 2) return(68.0/255.0f);
 }else{
 if (state == 0) return(31.83f);
 if (state == 1) return(130.0f);
 if (state == 2) return(64.0f/255.0f);
 }
 return(0.0f);
 }
 
 double Madstructs::Classifier::getPriorStd(int inp,int state){
 if (inp == 0){
 if (state == 0) return(sqrt(3.07f));
 if (state == 1) return(sqrt(16.34f));
 if (state == 2) return(6.0f/255.0f);
 }else{
 if (state == 0) return(sqrt(231.69f));
 if (state == 1) return(sqrt(656.0f));
 if (state == 2) return(3.0f/255.0f);
 }
 return(0.0f);
 
 }
 
*/


bool Madstructs::CellPose::isInside(int x, int y){
	return( distsum((double)x,(double)y) < width );
}

double Madstructs::CellPose::distsum(double x, double y){
	double dista, distb,tmp, tmpb;
	
	tmpb = x - center[0];
	distb = y - center[1];
	tmp = tmpb - eccentric[0];	dista = tmp * tmp;
	tmp = distb - eccentric[1];	dista += tmp * tmp;
	
	tmp = tmpb + eccentric[0];	tmpb = tmp * tmp;
	tmp = distb + eccentric[1];	distb = tmpb + tmp * tmp;
	
	return( sqrt(dista) + sqrt(distb));
}
/*
double Madstructs::CellPose::distToEdge(int x, int y){

	double dista, distb,tmp, tmpb;
	
	tmpb = x - center[0];
	distb = y - center[1];
	tmp = tmpb - eccentric[0];	dista = tmp * tmp;
	tmp = distb - eccentric[1];	dista += tmp * tmp;
	
	tmp = tmpb + eccentric[0];	tmpb = tmp * tmp;
	tmp = distb + eccentric[1];	distb = tmpb + tmp * tmp;
	
	tmpb = dista - distb;
	dista += distb;
	tmp = width * width /2.0f;
	dista *= 4.0f *tmp;
	distb = -2.0f * tmpb * tmpb;
	
	
	tmpb = (eccentric[0] * eccentric[0] + eccentric[1] * eccentric[1])/2.0f;
	LFHPrimitive::PolyThing<double> poly;
	poly.setOrder(4);
	
	poly.coef[0] = tmp*tmp*(-8.0f*tmp*tmp+ 15*tmp*tmpb-8.0f*tmpb*tmpb+dista) + (tmp-tmpb)*(tmp-tmpb)*distb;
	poly.coef[1] = 2.0f*(tmp*tmp*(-16.0f*tmp*tmp+ 23*tmp*tmpb-8.0f*tmpb*tmpb+dista) + (tmp-tmpb)*distb);
	poly.coef[2] = -48.0f*tmp*tmp+ 47*tmp*tmpb-8.0f*tmpb*tmpb+ dista + distb;
	poly.coef[3] = 16.0f * (tmpb -2*tmp);
	poly.coef[4] = -8.0f;
	
	tmp = poly.newtonRoot(0.0f, tmpb - tmp, LFHPrimitive::ExCo<double>::max());
	
	return(tmp);
	
}*/

double Madstructs::CellPose::cmpArea() const{
	return 0.5f * M_PI * width * sqrt(0.25f*width*width -  eccentric[0] * eccentric[0] - eccentric[1] * eccentric[1]);
}


// init from s,sx,sy,sxx,syy,syx
void Madstructs::CellPose::initFromCummul(double* data){
	area = data[0]; // == dab * pi()
	center[0] = data[1] / data[0];
	center[1] = data[2] / data[0];

	
	double pxx = (data[3]/ data[0]) - center[0] * center[0];
	double pyy = (data[4]/ data[0]) - center[1] * center[1];
	double pxy = (data[5]/ data[0]) - center[0] * center[1];
	// pxx + pyy = ab3 +ba3
	// pxx - pyy = [ab3 -ba3] cos 2t
	
	double tmp = pxx - pyy;
	pxx +=pyy;
	pyy =  sqrt(tmp*tmp + 4.0f * pxy*pxy); // == [a2 - b2] (as a>b)
	
	width = sqrt(8.0f * (pyy + pxx) );
	tmp = 0.5f *atan2(pxy, 0.5f*tmp);
	
 // b	pyy - 0.5f *pxx 
	// sqrt((pyy + 0.5f *pxx)^2 - (pyy - 0.5f *pxx)^2)
	// sqrt(2.0f*pyy*pxx)
	eccentric[0] = 2.0f * cos(tmp) * sqrt(pyy); 
	eccentric[1] = 2.0f * sin(tmp) * sqrt(pyy); 
	
}


bool Madstructs::CellCover::findUnclassifCellpt(Madstructs::Image<double>* source, Madstructs::Image<double>* label ,double* out_coor, double* out_width){
	int x,y,z;
	double pix[3];
	double pox[32];
	double ave[4];
	double count=0;
	double weight,tmp,tmp2;
	int looping;
	bool outb;
	ave[0] = 0;
	ave[1] = 0;
	//	double best;
	//	double expl;
	
	double min = 99.0f;
	for(y=0;y<source->sizey;y++){
		for(x=0;x<source->sizex;x++){
			source->getPixel(x,y,pix);
			
			if (pix[0] > 0.1f){
				weight =1.0f;
				if (label != NULL) {
					label->getPixel(x+source->sizex,y+source->sizey,pox);
					for(z=0;z<label->channels;z++) weight -= pox[z];
					if (weight< 0) weight = 0;
				}
				weight *= pix[0];
				if ((weight != 0.0f)&&(min > (1.0f - pix[0]) / weight)){
					min  = pix[0] / weight;
					ave[0] =x;
					ave[1] =y;
				}
				
			//	ave[0] += x*weight;
			//	ave[1] += y*weight;
				count+= weight;
			}
		}
	}
	
	if (count < 16) return(false);
	/*ave[0] /= count;
	ave[1] /= count;*/
	(*out_width) = 1.128379167095513f * sqrt(count);
	outb=false;
	source->getPixel((int)ave[0],(int)ave[1],pix);
	
	weight =1.0f;
	if (label != NULL) {
		label->getPixel(((int)ave[0])+source->sizex,((int)ave[1])+source->sizey,pox);
		for(z=0;z<label->channels;z++) weight -= pox[z];
		if (weight< 0) weight = 0;
	}
	
	for(looping=0; ((pix[0] < 0.1f) || (weight < 0.25)) && (looping < 100);looping++) {
		ave[2] = 0;
		ave[3] = 0;
		count =0;
		for(y=0;y<source->sizey;y++){
			for(x=0;x<source->sizex;x++){
				source->getPixel(x,y,pix);
				if (pix[0] > 0.1f){
					weight =1.0f;
					if (label != NULL) {
						label->getPixel(x+source->sizex,y+source->sizey,pox);
						for(z=0;z<label->channels;z++) weight -= pox[z];
						if (weight< 0) weight = 0;
					}
					weight *= pix[0];
					tmp = x - ave[0]; tmp2 = tmp*tmp;
					tmp = y - ave[1]; tmp2 += tmp*tmp;
					weight /= (tmp2 +10.0f );
					ave[2] += x*weight;
					ave[3] += y*weight;
					count+= weight;
					//					if ((outb == false)||(count < best)) {count = best; out_coor[0] = source->sizex +x; out_coor[1] = source->sizey +y;outb = true;}
				}	}	}
		if (count != 0.0f){
		ave[0] = ave[2] / count;
		ave[1] = ave[3] / count;
		}
		source->getPixel((int)ave[0],(int)ave[1],pix);
		
		weight =1.0f;
		if (label != NULL) {
			label->getPixel(((int)ave[0])+source->sizex,((int)ave[1])+source->sizey,pox);
			for(z=0;z<label->channels;z++) weight -= pox[z];
			if (weight< 0) weight = 0;
		}
		source->getPixel((int)ave[0],(int)ave[1],pix);
		//	printf("%f,%f\t%f,%f\n",ave[0],ave[1],weight,pix[2]);
	}
	if (looping == 100) return(false);
	out_coor[0] = source->sizex + ave[0];
	out_coor[1] = source->sizey + ave[1];
	
	return(true);
}


bool Madstructs::CellCover::findUnclassifCellpt_2(Madstructs::Image<double>* source, Madstructs::Image<double>* label ,double* out_coor, double* out_width){
	double worthdist =0.0f;
	unsigned int coor[2];
	double tmp, tmp2, dista,distb;
	int k;
	double pix[32];
	double worstpt[2];
	int unex=0;
		
		for(coor[1] =0;coor[1]<source->sizey;coor[1]++) for(coor[0] =0;coor[0]<source->sizex;coor[0]++){
			for(k=0;k<cover.size()-1;k++){
				tmp = coor[0] - cover[k].center[0] +source->sizex;
				tmp2 = tmp + cover[k].eccentric[0];dista = tmp2*tmp2;
				tmp2 = tmp - cover[k].eccentric[0];distb = tmp2*tmp2;
				tmp = coor[1] - cover[k].center[1] + source->sizey;
				tmp2 = tmp + cover[k].eccentric[1];dista = sqrt(dista+tmp2*tmp2);
				tmp2 = tmp - cover[k].eccentric[1];distb = sqrt(distb+tmp2*tmp2);				
				if (dista+distb < cover[k].width) break;
			//	printf("%f\t%f\t%f\t%f\n",dista+distb,cover[k].width, cover[k].eccentric[0],cover[k].eccentric[1]);
			}
			
			if (k==cover.size()-1) {
				source->getPixel(coor[0],coor[1],pix);
				unex++;
				if (worthdist< pix[2]){
					worthdist = pix[2];
					worstpt[0] = coor[0];
					worstpt[1] = coor[1];
				}
			}
			
		}
	if (worthdist == 0.0f) return(false);
	out_coor[0] = worstpt[0];
	out_coor[1] = worstpt[1];
	(*out_width) = sqrt((double)(unex) / M_PI) * 2.0f;
	if (!LFHPrimitive::ExCo<double>::isValid(out_coor[0])) {out_coor[0] = source->sizex / 2; (*out_width) = 16.0f;}
	if (!LFHPrimitive::ExCo<double>::isValid(out_coor[1])) {out_coor[1] = source->sizey / 2; (*out_width) = 16.0f;}
	return(true);
}


/*
bool Madstructs::CellCover::findUnclassifCellpt(Madstructs::Image<double>* source, Madstructs::Image<double>* label ,double* out_coor, double* out_width){
	int x,y,z;
	double pix[3];
	double pox[32];
	double ave[4];
	double count=0;
	double weight,tmp,tmp2;
	int looping;
	bool outb;
	ave[0] = 0;
	ave[1] = 0;
//	double best;
//	double expl;
	for(y=0;y<source->sizey;y++){
		for(x=0;x<source->sizex;x++){
			source->getPixel(x,y,pix);
			 
			if (pix[2] < 1.0f){
				weight =1.0f;
				if (label != NULL) {
					label->getPixel(x+source->sizex,y+source->sizey,pox);
					for(z=0;z<label->channels;z++) weight -= pox[z];
					if (weight< 0) weight = 0;
				}
				ave[0] += x*weight;
				ave[1] += y*weight;
				count+= weight;
			}
		}
	}
	
	if (count < 16) return(false);
	ave[0] /= count;
	ave[1] /= count;
	(*out_width) = 1.128379167095513f * sqrt(count);
	outb=false;
	source->getPixel((int)ave[0],(int)ave[1],pix);
	
	weight =1.0f;
	if (label != NULL) {
		label->getPixel(((int)ave[0])+source->sizex,((int)ave[1])+source->sizey,pox);
		for(z=0;z<label->channels;z++) weight -= pox[z];
		if (weight< 0) weight = 0;
	}
	
	for(looping=0; ((pix[2] == 1.0f) || (weight < 0.25)) && (looping < 100);looping++) {
		ave[2] = 0;
		ave[3] = 0;
		count =0;
		for(y=0;y<source->sizey;y++){
			for(x=0;x<source->sizex;x++){
				source->getPixel(x,y,pix);
				if (pix[2] < 1.0f){
					weight =1.0f;
					if (label != NULL) {
						label->getPixel(x+source->sizex,y+source->sizey,pox);
						for(z=0;z<label->channels;z++) weight -= pox[z];
						if (weight< 0) weight = 0;
					}
					tmp = x - ave[0]; tmp2 = tmp*tmp;
					tmp = y - ave[1]; tmp2 += tmp*tmp;
					weight /= (tmp2 +10.0f);
					ave[2] += x*weight;
					ave[3] += y*weight;
					count+= weight;
//					if ((outb == false)||(count < best)) {count = best; out_coor[0] = source->sizex +x; out_coor[1] = source->sizey +y;outb = true;}
		}	}	}
		ave[0] = ave[2] / count;
		ave[1] = ave[3] / count;
		source->getPixel((int)ave[0],(int)ave[1],pix);
		
		weight =1.0f;
		if (label != NULL) {
			label->getPixel(((int)ave[0])+source->sizex,((int)ave[1])+source->sizey,pox);
			for(z=0;z<label->channels;z++) weight -= pox[z];
			if (weight< 0) weight = 0;
		}
		source->getPixel((int)ave[0],(int)ave[1],pix);
	//	printf("%f,%f\t%f,%f\n",ave[0],ave[1],weight,pix[2]);
	}
	if (looping == 100) return(false);
	out_coor[0] = source->sizex + ave[0];
	out_coor[1] = source->sizey + ave[1];
	 
	return(true);
}*/



void Madstructs::CellCover::cellLabel(Madstructs::Image<double>* source, Madstructs::Image<double>* label){
	double pox[32];
//	double pix[32];
	int x,y,z;
	double tmp,tmp2,dist;
//	double cellprob[256];
/*	for(z=0;z<label->channels;z++){
		cellprob[z] = (cover[z].error[0] + 0.12f) * 2;
		tmp = cover[z].error[1] * 50.0f;
		cellprob[z] = exp(-cellprob[z]*cellprob[z] -tmp);
	}*/
	//printf("Labeling start!\n");fflush(stdout);
	/*
	double* celw = new double[label->channels];

	for(z=0;z<label->channels;z++){
		if (cover[z].error[1] == 0.0f) celw[z] = 1.0f;
		else celw[z] = exp(-((cover[z].error[0]*cover[z].error[0]) / cover[z].error[1]));
		if ((z == 0)||(pox[0] < celw[z])) pox[0] = celw[z];
	}
	for(z=0;z<label->channels;z++) celw[z] /= pox[0];	//printf("%f\t",celw[z]);}
	*/
//	printf("   facts\n");
	
	
	for(y=0;y<label->sizey;y++){
		for(x=0;x<label->sizex;x++){
		//	if ((x < source->sizex)||(y<source->sizey)||(x>=2*source->sizex)||(y>=2*source->sizey)) pix[2] = 1.0f;
		//	else source->getPixel(x - source->sizex,y - source->sizey,pix);
		//	if (pix[2] != 0.0f)	pix[0] = ((1.0f / pix[2]) -1.0f) * 10.0f;
		//	else pix[0] = 50.0f;
			for(z=0;z<label->channels;z++){
				tmp = (x-cover[z].center[0]+cover[z].eccentric[0]); tmp2 = tmp*tmp;
				tmp = (y-cover[z].center[1]+cover[z].eccentric[1]); tmp2 += tmp*tmp;
				tmp = (x-cover[z].center[0]-cover[z].eccentric[0]); dist = tmp*tmp;
				tmp = (y-cover[z].center[1]-cover[z].eccentric[1]); dist = sqrt(tmp2) + sqrt(dist + tmp*tmp);
			//	if (dist == 0) pox[z] =1.0f;
			//	else 
				
		//		if (dist < cover[z].width){
		//			printf("whoot %f\n",1 / (1 + exp((dist - cover[z].width) *2)));
		//		}
				
				

				
		//		pox[z] = (cover[z].width - pix[0]*2 - dist);
		//		pox[z] = exp(-pox[z]*pox[z]/10);
				//if (dist > cover[z].width) pox[z] =0.0f;
				//else pox[z] = 1.0f - 1.0f / (1.0f + (cover[z].width-dist)*0.05f);
				dist = ( 1 - dist / cover[z].width) *10;
				//	pox[z] = cellprob[z] * MY_LOGISTIC_P(dist);
					pox[z] = (MY_LOGISTIC_P(dist));
			}
			label->setPixel(x,y,pox);
		}
	}
//	delete[](celw);
//	printf("Labeling done!\n");fflush(stdout);
}

void Madstructs::CellCover::cellDistanceLabel(Madstructs::Image<double>* source, Madstructs::Image<double>* label){
	double pox[32];
	//	double pix[32];
	int x,y,z;
	double tmp,tmp2,dist;

	
	
	for(y=0;y<label->sizey;y++){
		for(x=0;x<label->sizex;x++){
			for(z=0;z<label->channels;z++){
				tmp = (x-cover[z].center[0]+cover[z].eccentric[0]); tmp2 = tmp*tmp;
				tmp = (y-cover[z].center[1]+cover[z].eccentric[1]); tmp2 += tmp*tmp;
				tmp = (x-cover[z].center[0]-cover[z].eccentric[0]); dist = tmp*tmp;
				tmp = (y-cover[z].center[1]-cover[z].eccentric[1]); dist = sqrt(tmp2) + sqrt(dist + tmp*tmp);
				pox[z] = ( 1 - dist / cover[z].width) *10;
			}
			label->setPixel(x,y,pox);
		}
	}
}


void Madstructs::CellCover::cellCompleteLabel(Madstructs::Image<double>* source, Madstructs::Image<double>* label, LFHPrimitive::GaussianDistribution<1>* intdistribs){
	int x,y,z,w;
	
	double prior[32];
	double prob[32];
	double probd[32];
	double probi[32];
	double tmp,tmp2,sum;
	
	sum = 0.0f;
	
	for(z=0;z<label->channels;z++){
		tmp2 = cover[z].width /2.0f;
		prior[z] =  tmp2 * tmp2 * M_PI;
		sum += prior[z];
	}
	
	if (sum > 0.0f) {
		sum = 1.0f / sum;
		for(z=0;z<label->channels;z++) prior[z] *= sum;
	}else {
		sum = 1.0f / label->channels;
		for(z=0;z<label->channels;z++) prior[z] = sum;
	}
	
	
	//for(w=0;w<label->channels;w++) printf("%e\t", prior[w]);
	//printf("is the Prior\n");
	
	
	
//	for(z=0;z<label->channels+1;z++) prior[z] = 1.0f / (label->channels+1); 
	double pix[32];
	LFHPrimitive::Tuple<double,1> inten;
	double LL =0.0f;
	double LLd =0.0f;
	double LLi =0.0f;
	
	double CL =0.0f;
	double dists[32];
	LFHPrimitive::Vector< LFHPrimitive::KeyElem<double, int > > distdiff;
	
	
	double pairbuf[300000];
//	double* pairbuf = (label->channels > 1) ? new double[3*label->channels *(label->channels-1)/2] : NULL;
	if (label->channels > 1) memset(pairbuf,'\0',sizeof(double)*3*label->channels *(label->channels-1)/2);
	LFHPrimitive::FoldedGaussianDistribution fd[32];
	
	for(z=0;z<label->channels;z++) distdiff.push_back(LFHPrimitive::KeyElem<double, int >(0.0f,0) );
	for(z=0;z<label->channels;z++) fd[z] = LFHPrimitive::FoldedGaussianDistribution(cover[z].width, cover[z].width * 0.15f);
	LFHPrimitive::WeightElem<double,2> err[32];
	for(z=0;z<label->channels;z++) LFHPrimitive::ExOp::toZero(err[z]);
	for(y=0;y<label->sizey;y++){
		for(x=0;x<label->sizex;x++){
			source->getPixel(x,y,pix);
			inten[0] = pix[1]; 
			err[0] += LFHPrimitive::WeightElem<double,2>(pix[2], pix[0]);
			if (pix[0] > 0){

			//	if (pix[2] >= 1.0f) ccc++;
				/*
				if (label->channels > 1){
				for(z=0;z<label->channels;z++){
					dists[z] = cover[z].distsum(x,y);
					distdiff[z].k = dists[z] - cover[z].width;
					distdiff[z].d = z;
				}
				distdiff.sort();
				
					if ((distdiff[0].k + distdiff[1].k) < 0.0f){
						// overwrites distance to edge!!!!
						pindex = (distdiff[0].d > distdiff[1].d) ? distdiff[0].d + distdiff[1].d * (2* label->channels - distdiff[1].d +1) /2 : distdiff[1].d + distdiff[0].d * (2*  label->channels - distdiff[0].d +1) /2;
				//		printf("diffs! : %f,%f\n", distdiff[0].k , distdiff[1].k);

						
					//	printf("%i\t%i\n",distdiff[0].d,distdiff[1].d);
						if (pairbuf[pindex*3] < 1.0f){
							correct[0] = cover[distdiff[0].d].center[0] - cover[distdiff[1].d].center[0];
							correct[1] = cover[distdiff[0].d].center[1] - cover[distdiff[1].d].center[1];
							pairbuf[pindex*3] = correct[0]*correct[0] + correct[1]*correct[1]; 
						//	printf("triangle%i : %f\t%f\t%f\n",pindex, sqrt(pairbuf[pindex*3]),cover[distdiff[0].d].width,cover[distdiff[1].d].width);
							correct[0] = (cover[distdiff[0].d].width +cover[distdiff[1].d].width) *0.5f;
							correct[1] = (cover[distdiff[0].d].width -cover[distdiff[1].d].width) * (distdiff[0].d > distdiff[1].d ? 0.5f : -0.5f);
				
							
							pairbuf[pindex*3+1] = correct[0]*correct[1];
				//			printf("pindex %i , record%f\n", pindex,-(pairbuf[pindex*3] - correct[0]*correct[0])*(pairbuf[pindex*3] - correct[1]*correct[1]));
							pairbuf[pindex*3+2] = sqrt(-(pairbuf[pindex*3] - correct[0]*correct[0])*(pairbuf[pindex*3] - correct[1]*correct[1]));
							
							if (!LFHPrimitive::ExCo<double>::isValid(pairbuf[pindex*3+2])) pairbuf[pindex*3+2]= 0.0f; // happens if no intersection! a circle contains the other!
							
				//			printf("cell data: %f\t%f\t%f\n", pairbuf[pindex*3+1] / (2.0f * pairbuf[pindex*3]) ,pairbuf[pindex*3+1],pairbuf[pindex*3+2]);
						} 
						
						if (pairbuf[pindex*3+2] != 0.0f){
						
				//			printf("cell data%i: %f\t%f\t%f\n",pindex, pairbuf[pindex*3],pairbuf[pindex*3+1],pairbuf[pindex*3+2]);
						correct[0] = (dists[ distdiff[0].d] + dists[ distdiff[1].d]) *0.5f;
						correct[1] = (dists[ distdiff[0].d] - dists[ distdiff[1].d]) * (distdiff[0].d > distdiff[1].d ? 0.5f : -0.5f);
						
				//		printf("triangle : %f\t%f\t%f\n", sqrt(pairbuf[pindex*3]),dists[ distdiff[0].d],dists[ distdiff[1].d]);
				//		printf("triangle : %f\t%f\t%f\n", pairbuf[pindex*3],dists[ distdiff[0].d],dists[ distdiff[1].d]);
						
				//		printf("%f\t%f\n", dists[ distdiff[0].d],dists[ distdiff[0].d]-cover[distdiff[0].d].width);
				//		printf("%f\t%f\n", dists[ distdiff[1].d],dists[ distdiff[1].d]-cover[distdiff[1].d].width);
						
						correct[2] = pairbuf[pindex*3+1] - correct[0] * correct[1];
						correct[3] = pairbuf[pindex*3+2] - sqrt(-(pairbuf[pindex*3] - correct[0]*correct[0])*(pairbuf[pindex*3] - correct[1]*correct[1]));
						ccc = sqrt(correct[2]*correct[2] + correct[3]*correct[3]);
						ccc = -sqrt(pairbuf[pindex*3])*distdiff[0].k / ccc;
						pix[3] = (LFHPrimitive::ExCo<double>::isValid(ccc))? pix[2] *ccc : pix[2];
						}else pix[3] = pix[2];
					//	printf("correction factor!%f\n", -sqrt(pairbuf[pindex*3])*distdiff[0].k / ccc);
					} else 
						
						pix[3] = pix[2];
				}  else pix[3] = pix[2];
				*/
				pix[3] = pix[2]; // dont correct
				
				
				
				
				//pix[3] *= 0.95f;
				source->setPixel(x,y,pix);
				
			sum = 0.0f;
			for(z=0;z<label->channels;z++){
				tmp = dists[z] + 2.0f *pix[3];
				
			//	fd[z](probd[z+1], tmp);


				tmp = 0.5f * (tmp - cover[z].width);
				probd[z] = exp(-0.5f * tmp * tmp / (2.0f*2.0f) );
				
				
				intdistribs[z](tmp2, inten);
				probi[z] = tmp2;
				if (LFHPrimitive::ExCo<double>::isValid(probd[z] * probi[z])){ 
					sum += prior[z] * probd[z] * probi[z];
				} else {
					probi[z] =0.0f;
					probd[z] =0.0f;
				}
			}
			
				sum = 1.0f / sum;
				
				

				
				if (LFHPrimitive::ExCo<double>::isValid(sum)){
				for(z=0;z<label->channels;z++) {
					prob[z] = probd[z] * prior[z] * probi[z] * sum;
					if (prob[z] > 0.0f) {
						LL +=  pix[0] * prob[z] * log(prior[z]);
						LLd += pix[0] * prob[z] * log(probd[z]);
						LLi += pix[0] * prob[z] * log(probi[z]);
						CL += pix[0] * prior[z] * (log(probd[z]) + log(probi[z]) + log(prior[z]));
					}

					if (prob[z] > 1.1f) {
						tmp =0;
						for(w=0;w<label->channels;w++) {tmp += probd[w] * prior[w] * probi[w];  printf("%e\t", probi[w]);}
						printf("Prior... Peal___ly??? %e\t %e\t %e\t %e\n", prob[z], tmp * sum,sum,pix[0]);
					}
					
				}
				}else memcpy(prob, prior, sizeof(double) *label->channels);
				
			}else memcpy(prob, prior, sizeof(double) *label->channels);

			
		//		for(z=0;z<label->channels+1;z++) {
		//			if (prob[z] > 1.0f) printf("Really??? %e\t %e\t %i\n", prob[z], pix[0],z);
		//		}
			
				label->setPixel(x,y,prob);
		}
	}
//	printf("%e\t", ((double)ccc) / (label->sizex * label->sizey) );			
	
//	for(z=0;z<label->channels;z++)  printf("(%e,%e)\t", err[z].getMean(),err[z].getVar());
//		printf("LL prior%e\t LL int %e\t LL dist %e\t LL total: %e\n", LL, LLi, LLd, LL + LLi + LLd);
//		printf("CL %e\n", CL);
//	delete[](pairbuf);
}


void Madstructs::CellCover::computeerror(Madstructs::Image<double>* source){
	int x,y,i;
	
	Madstructs::Image<double> label = Madstructs::Image<double>();
	label.sizex = source->sizex;
	label.sizey = source->sizey;
	label.channels = cover.size();
	label.allocateBuffer();
	double tmp, dist, tmp2;
	double pix[32];
	double pox[32];
	
	LFHPrimitive::WeightElem<double,2>* errbuf = new LFHPrimitive::WeightElem<double,2>[label.channels*3];

	/*
	for(i=0;i<label.channels*3;i++) LFHPrimitive::ExOp::toZero(errbuf[i]);
	for(y=0;y<label.sizey;y++){
		for(x=0;x<label.sizex;x++){

			for(i=0;i<label.channels;i++){
				tmp = (x-cover[i].center[0]+cover[i].eccentric[0]); tmp2 = tmp*tmp;
				tmp = (y-cover[i].center[1]+cover[i].eccentric[1]); tmp2 += tmp*tmp;
				tmp = (x-cover[i].center[0]-cover[i].eccentric[0]); dist = tmp*tmp;
				tmp = (y-cover[i].center[1]-cover[i].eccentric[1]); dist = sqrt(tmp2) + sqrt(dist + tmp*tmp);
				dist = ( 1 - dist / cover[i].width) *10;
				pox[i] = (MY_LOGISTIC_P(dist));
			}
			
			tmp =0;
			for(i=0;i<label.channels;i++){
				tmp += pox[i];
			}
			if (tmp != 0.0f) tmp = 1.0f / tmp;
			
			source->getPixel(x,y,pix);
			for(i=0;i<label.channels;i++){
				pox[i] *= tmp;
				
				errbuf[i*3] += LFHPrimitive::WeightElem<double,2>((double)x,pox[i] *pix[0]);
				errbuf[i*3 +1] += LFHPrimitive::WeightElem<double,2>((double)y,pox[i] * pix[0]);
				errbuf[i*3 +2] += LFHPrimitive::WeightElem<double,2>((double)x*y,pox[i] * pix[0]);
				
			}
			
			
		}
	}
	
	for(i=0;i<label.channels;i++){
		cover[i].center[0] = errbuf[i*3].getMean();
		cover[i].center[1] = errbuf[i*3+1].getMean();
//		printf("%f\t%f\t", cover[i].center[0], cover[i].center[1]);
		
		pox[0] =  errbuf[i*3].getVar();
		pox[1] =  errbuf[i*3+1].getVar();
		pox[2] = errbuf[i*3+2].getMean() - cover[i].center[0]*cover[i].center[1];
		tmp = pox[0] - pox[1];
		tmp2 = tmp * tmp + 4 * pox[2] * pox[2];
		dist = sqrt(tmp2);
		cover[i].width = sqrt(pox[0] + pox[1] + dist) * sqrt(8.0f);
		cover[i].eccentric[0] = sqrt(2*(tmp + dist));
		cover[i].eccentric[1] = sqrt(2.0f*(dist-tmp)) * ((pox[2]< 0.0f) ? -1.0f :1.0f);
//		printf("%f\t%f\t%f\n", cover[i].width, cover[i].eccentric[0], cover[i].eccentric[1]);
	}
	*/
	
	
	for(y=0;y<label.sizey;y++){
		for(x=0;x<label.sizex;x++){
			
			for(i=0;i<label.channels;i++){
				tmp = (x-cover[i].center[0]+cover[i].eccentric[0]); tmp2 = tmp*tmp;
				tmp = (y-cover[i].center[1]+cover[i].eccentric[1]); tmp2 += tmp*tmp;
				tmp = (x-cover[i].center[0]-cover[i].eccentric[0]); dist = tmp*tmp;
				tmp = (y-cover[i].center[1]-cover[i].eccentric[1]); dist = sqrt(tmp2) + sqrt(dist + tmp*tmp);
				dist = ( 1 - dist / cover[i].width) *10;
				pox[i] = (MY_LOGISTIC_P(dist));
			}
			
			tmp =0;
			for(i=0;i<label.channels;i++){
				tmp += pox[i];
			}
						
			label.setPixel(x,y,pox);
		}
	}
	
	
	for(i=0;i<label.channels;i++) LFHPrimitive::ExOp::toZero(errbuf[i]);


	for(y=0;y<source->sizey;y++){
		for(x=0;x<source->sizex;x++){

			source->getPixel(x,y,pix);
			label.getPixel(x ,y ,pox);
			for(i=0;i<label.channels;i++){
				tmp = (x - cover[i].center[0]); dist = tmp*tmp;
				tmp = (y - cover[i].center[1]); dist = sqrt(tmp*tmp+ dist);
				if ((pix[0] >= 0.1)&&(dist != 0)&&(pox[i]  != 0.0f)) {
					if (LFHPrimitive::ExCo<double>::isValid(pox[i]*pix[0] * (pix[2]*2 + dist*2) / cover[i].width - 1)) errbuf[i] += LFHPrimitive::WeightElem<double,2>((pix[2]*2 + dist*2) / cover[i].width - 1,  pox[i]*pix[0]);
				}
			}
			
		}
	}
	
	for(i=0;i<label.channels;i++){
		cover[i].error[0] = errbuf[i].getMean();
		cover[i].error[1] = errbuf[i].getVar();
		
	}
	delete[](errbuf);
}

		/*			 
void Madstructs::CellCover::cellUpdate(Madstructs::Image<double>* source, Madstructs::Image<double>* label, double alpha){
	double pix[32];
	double pox[32];
	int x,y,z;
	double tmp,tmp2,tot,dist;
	double* shifts = new double[5*label->channels];
	memset(shifts,'\0',sizeof(double)*5*label->channels);
	for(y=0;y<label->sizey;y++){
		for(x=0;x<label->sizex;x++){
			
			if ((x < source->sizex)||(y<source->sizey)||(x>=2*source->sizex)||(y>=2*source->sizey)) pix[2] = 1.0f;
			else source->getPixel(x - source->sizex,y - source->sizey,pix);
			label->getPixel(x,y,pox);
			
			tot =0;
			for(z=0;z<label->channels;z++){
				tot += pox[z];
			}
			if (tot > 0.0f) {
				tmp2 = tot;	
				for(z=0;z<label->channels;z++){
					tot += pox[z] * (tmp2 - pox[z])*4;
				}
				for(z=0;z<label->channels;z++){
					pox[z] /= tot;
				}
				
				tmp2 = alpha *( 1 - pix[2] -tot);
				// if tmp < 1 attract circles, if tmp > 1 repulse circles
				// else tmp2 = alpha *(-tot); // always repulse
				
				for(z=0;z<label->channels;z++){
					tmp = (x - cover[z].center[0]); dist = tmp*tmp;
					tmp = (y - cover[z].center[1]); dist = sqrt(tmp*tmp+ dist);
					if ((dist != 0)&&(pox[z]  != 0.0f)){
						shifts[5*z+0] +=  tmp2 * pox[z] * (x - cover[z].center[0]) / (dist*cover[z].width);
						shifts[5*z+1] += tmp2 * pox[z] * (y - cover[z].center[1]) / (dist*cover[z].width);
						shifts[5*z+2] += tmp2 * pox[z] * dist / (cover[z].width * cover[z].width);
					}
				}
			}
		}
	}
	
	for(z=0;z<label->channels;z++){
		cover[z].center[0] += 3*shifts[5*z+0];
		cover[z].center[1] += 3*shifts[5*z+1];
		cover[z].width += 3*shifts[5*z+2];
	}
	delete[](shifts);
}
*/
void Madstructs::CellCover::cellUpdate(Madstructs::Image<double>* source, Madstructs::Image<double>* label, double alpha){
	double pix[32];
	double pox[32];
	int x,y,z;
	double tmp,tmp2,tot,dist;
	double* shifts = new double[5*label->channels];
	memset(shifts,'\0',sizeof(double)*5*label->channels);
//	printf("Update start!\n");fflush(stdout);

	for(y=0;y<label->sizey;y++){
		for(x=0;x<label->sizex;x++){
			
			if ((x < source->sizex)||(y<source->sizey)||(x>=2*source->sizex)||(y>=2*source->sizey)) pix[2] = 1.0f;
			else source->getPixel(x - source->sizex,y - source->sizey,pix);
			
				if (pix[2] != 0.0f)	pix[0] = ((1.0f / pix[2]) -1.0f) * 10.0f;
				else pix[0] = 50.0f;
			
			label->getPixel(x,y,pox);
			
			tot =0;
			for(z=0;z<label->channels;z++){
				tot += pox[z];
			}
			if (tot > 0.0f) {
		//		tmp2 = tot;	
		//	for(z=0;z<label->channels;z++){
		//		tot += pox[z] * (tmp2 - pox[z])*4;
		//	}
		//	for(z=0;z<label->channels;z++){
		//		pox[z] /= tot;
		//	}


			tmp2 = 1-tot;
				// if tmp < 1 attract circles, if tmp > 1 repulse circles
				// else tmp2 = alpha *(-tot); // always repulse
			
			for(z=0;z<label->channels;z++){
				tmp = (x - cover[z].center[0]); dist = tmp*tmp;
				tmp = (y - cover[z].center[1]); dist = sqrt(tmp*tmp+ dist);
				
				if (pix[0] == 0) tmp = -0.2;//-tot; // always repulse;
				else {
					tmp = (pix[0]*2 + dist*2) / cover[z].width - 1;
					//if (fabs(tmp) > 0.25f) tmp =0.0f; // tmp = 1.0f- 2.0f / (1.0f + exp(tmp));
					tmp = tmp / (tmp*tmp + 1);
				tmp += (pox[z] - tot);
					
					tmp += 0.2f; // anti repulse!
				}
				
				if ((dist != 0)&&(pox[z]  != 0.0f) ){
					shifts[5*z+0] += (tmp) * pox[z]  * (x - cover[z].center[0]) / (dist*cover[z].width);
					shifts[5*z+1] += (tmp) * pox[z]  * (y - cover[z].center[1]) / (dist*cover[z].width);
					shifts[5*z+2] += (tmp) * pox[z]  * dist / (cover[z].width * cover[z].width);
				}
			}
			}
		}
	}
	
	for(z=0;z<label->channels;z++){
		cover[z].center[0] +=  alpha *3*shifts[5*z+0];
		cover[z].center[1] +=  alpha *3*shifts[5*z+1];
		cover[z].width +=  alpha *3*shifts[5*z+2];
	}
	delete[](shifts);
//	printf("Update done!\n");fflush(stdout);
}




void Madstructs::CellCover::cellEllipseFit(Madstructs::Image<double>* source, Madstructs::Image<double>* label){
	double* buffer = new double[label->channels * 10];
	double pix[32];
	int x,y,z;
	double newell[8];
	memset(buffer,'\0',sizeof(double)*label->channels * 8);
	for(y=0;y<label->sizey;y++){
		for(x=0;x<label->sizex;x++){
			label->getPixel(x,y,pix);
			source-> getPixel(x,y,newell);
			for(z=0;z<label->channels;z++){
				pix[z] *= newell[0];
				
				//	newell[3] = 1.0f - ((cover[z].distsum(x,y) + newell[2]) / cover[z].width);
				//	newell[3] = pix[z] * exp(-newell[3]*newell[3]); // gaussian
				
				buffer[10 * z] += pix[z];
				buffer[10 * z+1] += pix[z]  * x;
				buffer[10 * z+2] += pix[z]  * y;
				buffer[10 * z+3] += pix[z]  * x*x;
				buffer[10 * z+4] += pix[z]  * y*y;
				buffer[10 * z+5] += pix[z]  * y*x;
				buffer[10 * z+6] += pix[z]  * newell[2] * pix[z];
				buffer[10 * z+7] += pix[z]  * newell[2];
				buffer[10 * z+8] += pix[z]  * newell[2] * x;
				buffer[10 * z+9] += pix[z]  * newell[2] * y;
				
				if (pix[z] > 1.0f) printf("R2 %e\t %e\n", pix[z], pix[0]);
			}
		}
	}
	
	
	
	for(z=0;z<label->channels;z++){
		
		newell[0] = buffer[10 * z+1] / buffer[10 * z]; 
		newell[1] = buffer[10 * z+2] / buffer[10 * z]; 
		
		//	newell[6] = buffer[10 * z+8] / buffer[10 * z +7]; 
		//	newell[7] = buffer[10 * z+9] / buffer[10 * z+ 7]; 
		
		//	newell[0] = 1.5f*newell[0] -0.5f*newell[6];
		//	newell[1] = 1.5f*newell[1] -0.5f*newell[7];
		
		
		
		buffer[10 * z+3] -= newell[0] * buffer[10 * z+1];
		buffer[10 * z+4] -= newell[1] * buffer[10 * z+2];
		buffer[10 * z+5] -= newell[0] * buffer[10 * z+2];
		
		pix[0] = buffer[10 * z+3] - buffer[10 * z+4];
		//	pix[1] = pix[0] * pix[0] + 4* buffer[10 * z+5] * buffer[10 * z+5];
		
		
		pix[3] = sqrt(-1.0f + 2 * (buffer[10 * z+3] + buffer[10 * z+4])/(buffer[10 * z+3] + buffer[10 * z+4] + hypot(pix[0],2* buffer[10 * z+5])));
		pix[4] = atan2(2* buffer[10 * z+5], pix[0]); // 2angle 
		
		if ((!LFHPrimitive::ExCo<double>::isValid(pix[3]))||(!LFHPrimitive::ExCo<double>::isValid(pix[4]))){
			pix[3] = 1.0f; // is a circle if that is unstable!
			pix[4] = 0.0f;
		}
		if (pix[3] < 0.75) pix[3] =0.75f;
			if (!LFHPrimitive::ExCo<double>::isValid(newell[0])) newell[0] =0;
			else cover[z].center[0] = (cover[z].center[0]*255.0f + newell[0]) / 256.0f;
			if (!LFHPrimitive::ExCo<double>::isValid(newell[1])) newell[1] =0;
			else cover[z].center[1] = (cover[z].center[1]*255.0f + newell[1]) / 256.0f;
			
			newell[2] = 2.0f * sqrt(buffer[10 * z+7] / (pix[3] * M_PI));
			//newell[2] = buffer[10 * z + 6] * 6.0f / (pix[3]*buffer[10 * z]);
			pix[1] = sqrt(1 - pix[3]*pix[3]);
			newell[3]= cos(pix[4] *0.5f) * newell[2] * pix[1] *0.5f;if (!LFHPrimitive::ExCo<double>::isValid(newell[3])) newell[3] =0;
			newell[4]= sin(pix[4] *0.5f) * newell[2] * pix[1] *0.5f;if (!LFHPrimitive::ExCo<double>::isValid(newell[4])) newell[4] =0;
			if ((cover[z].width < 0.5f)||(!LFHPrimitive::ExCo<double>::isValid(newell[2]))) newell[2] =0.5f;
			cover[z].width= (cover[z].width *255.0f  + newell[2]) / 256.0f;
			cover[z].eccentric[0]= (cover[z].eccentric[0]*7.0f + newell[3]) *0.125f;
			cover[z].eccentric[1]= (cover[z].eccentric[1]*7.0f + newell[4]) *0.125f;

		
	}
	
	delete[](buffer);
}
void Madstructs::CellCover::cellUpdateEllipse(Madstructs::Image<double>* source, Madstructs::Image<double>* label, bool ellipseMode){

	double* buffer = new double[label->channels * 10];
	double pix[32];
	int x,y,z;
	double newell[8];
	memset(buffer,'\0',sizeof(double)*label->channels * 8);
	for(y=0;y<label->sizey;y++){
		for(x=0;x<label->sizex;x++){
			label->getPixel(x,y,pix);
			source-> getPixel(x,y,newell);
			for(z=0;z<label->channels;z++){
				
				
			//	newell[3] = 1.0f - ((cover[z].distsum(x,y) + newell[2]) / cover[z].width);
			//	newell[3] = pix[z] * exp(-newell[3]*newell[3]); // gaussian
				
				buffer[10 * z] += pix[z];
				buffer[10 * z+1] += pix[z]  * x;
				buffer[10 * z+2] += pix[z]  * y;
				buffer[10 * z+3] += pix[z]  * x*x;
				buffer[10 * z+4] += pix[z]  * y*y;
				buffer[10 * z+5] += pix[z]  * y*x;
				buffer[10 * z+6] += pix[z]  * newell[2] * pix[z];
				buffer[10 * z+7] += pix[z] * newell[2];
				buffer[10 * z+8] += pix[z] * newell[2] * x;
				buffer[10 * z+9] += pix[z] * newell[2] * y;
				
				if (pix[z] > 1.0f) printf("R2 %e\t %e\n", pix[z], pix[0]);
			}
		}
	}
	

	
	for(z=0;z<label->channels;z++){
		
		newell[0] = buffer[10 * z+1] / buffer[10 * z]; 
		newell[1] = buffer[10 * z+2] / buffer[10 * z]; 
		
	//	newell[6] = buffer[10 * z+8] / buffer[10 * z +7]; 
	//	newell[7] = buffer[10 * z+9] / buffer[10 * z+ 7]; 
		
	//	newell[0] = 1.5f*newell[0] -0.5f*newell[6];
	//	newell[1] = 1.5f*newell[1] -0.5f*newell[7];
		

		
		buffer[10 * z+3] -= newell[0] * buffer[10 * z+1];
		buffer[10 * z+4] -= newell[1] * buffer[10 * z+2];
		buffer[10 * z+5] -= newell[0] * buffer[10 * z+2];
		
		pix[0] = buffer[10 * z+3] - buffer[10 * z+4];
	//	pix[1] = pix[0] * pix[0] + 4* buffer[10 * z+5] * buffer[10 * z+5];
		

		pix[3] = sqrt(-1.0f + 2 * (buffer[10 * z+3] + buffer[10 * z+4])/(buffer[10 * z+3] + buffer[10 * z+4] + hypot(pix[0],2* buffer[10 * z+5])));
		pix[4] = atan2(2* buffer[10 * z+5], pix[0]); // 2angle 
		
		if ((!LFHPrimitive::ExCo<double>::isValid(pix[3]))||(!LFHPrimitive::ExCo<double>::isValid(pix[4]))){
			 pix[3] = 1.0f; // is a circle if that is unstable!
			 pix[4] = 0.0f;
			 }
		if (pix[3] < 0.75) pix[3] =0.75f;

		
		if (ellipseMode){
			if (!LFHPrimitive::ExCo<double>::isValid(newell[0])) newell[0] =0;
			else cover[z].center[0] = (cover[z].center[0]*255.0f + newell[0]) / 256.0f;
			if (!LFHPrimitive::ExCo<double>::isValid(newell[1])) newell[1] =0;
			else cover[z].center[1] = (cover[z].center[1]*255.0f + newell[1]) / 256.0f;
			
			//			newell[2] = 2.0f * sqrt(buffer[10 * z+7] / (pix[3] * M_PI));
						newell[2] = buffer[10 * z + 6] * 6.0f / (pix[3]*buffer[10 * z]);
			pix[1] = sqrt(1 - pix[3]*pix[3]);
			newell[3]= cos(pix[4] *0.5f) * newell[2] * pix[1] *0.5f;if (!LFHPrimitive::ExCo<double>::isValid(newell[3])) newell[3] =0;
			newell[4]= sin(pix[4] *0.5f) * newell[2] * pix[1] *0.5f;if (!LFHPrimitive::ExCo<double>::isValid(newell[4])) newell[4] =0;
			if ((cover[z].width < 0.5f)||(!LFHPrimitive::ExCo<double>::isValid(newell[2]))) newell[2] =0.5f;
			cover[z].width= (cover[z].width *255.0f  + newell[2]) / 256.0f;
			cover[z].eccentric[0]= (cover[z].eccentric[0]*7.0f + newell[3]) *0.125f;
			cover[z].eccentric[1]= (cover[z].eccentric[1]*7.0f + newell[4]) *0.125f;
		}else{
			if (!LFHPrimitive::ExCo<double>::isValid(newell[0])) newell[0] =0;
			else cover[z].center[0] = (cover[z].center[0]+ newell[0]) *0.5f;
			if (!LFHPrimitive::ExCo<double>::isValid(newell[1])) newell[1] =0;
			else cover[z].center[1] = (cover[z].center[1] + newell[1]) *0.5f;			
			
		//	newell[2] = 2.0f * sqrt(buffer[10 * z+7] / (pix[3] * M_PI));
			newell[2] = buffer[10 * z + 6] * 6.0f / (buffer[10 * z]);
			if ((cover[z].width < 0.5f)||(!LFHPrimitive::ExCo<double>::isValid(newell[2]))) newell[2] =0.5f;
			cover[z].width= (cover[z].width + newell[2]) *0.5f;
			cover[z].eccentric[0]= 0.0f;
			cover[z].eccentric[1]= 0.0f;
			
		
		}
		
	}

	delete[](buffer);

}


void Madstructs::CellCover::cellUpdateEllipse_EM(Madstructs::Image<double>* source, Madstructs::Image<double>* label, bool ellipseMode){
	
	double* buffer = new double[label->channels * 10];
	double pix[32];
	int x,y,z;
	double newell[8];
	memset(buffer,'\0',sizeof(double)*label->channels * 8);
	for(y=0;y<label->sizey;y++){
		for(x=0;x<label->sizex;x++){
			label->getPixel(x,y,pix);
			source-> getPixel(x,y,newell);
			for(z=0;z<label->channels;z++){
				
				
				//	newell[3] = 1.0f - ((cover[z].distsum(x,y) + newell[2]) / cover[z].width);
				//	newell[3] = pix[z] * exp(-newell[3]*newell[3]); // gaussian
				
				buffer[10 * z] += pix[z];
				buffer[10 * z+1] += pix[z]  * x;
				buffer[10 * z+2] += pix[z]  * y;
				buffer[10 * z+3] += pix[z]  * x*x;
				buffer[10 * z+4] += pix[z]  * y*y;
				buffer[10 * z+5] += pix[z]  * y*x;
				buffer[10 * z+6] += pix[z]  * newell[2] * pix[z];
				buffer[10 * z+7] += pix[z] * newell[2];
				buffer[10 * z+8] += pix[z] * newell[2] * x;
				buffer[10 * z+9] += pix[z] * newell[2] * y;
				
				if (pix[z] > 1.0f) printf("R2 %e\t %e\n", pix[z], pix[0]);
			}
		}
	}
	
	
	
	for(z=0;z<label->channels;z++){
		
		newell[0] = buffer[10 * z+1] / buffer[10 * z]; 
		newell[1] = buffer[10 * z+2] / buffer[10 * z]; 
		
		newell[6] = buffer[10 * z+8] / buffer[10 * z +7]; 
		newell[7] = buffer[10 * z+9] / buffer[10 * z+ 7]; 
		
		newell[0] = 1.5f*newell[0] -0.5f*newell[6];
		newell[1] = 1.5f*newell[1] -0.5f*newell[7];
		
		
		
		buffer[10 * z+3] -= newell[0] * buffer[10 * z+1];
		buffer[10 * z+4] -= newell[1] * buffer[10 * z+2];
		buffer[10 * z+5] -= newell[0] * buffer[10 * z+2];
		
		pix[0] = buffer[10 * z+3] - buffer[10 * z+4];
		//	pix[1] = pix[0] * pix[0] + 4* buffer[10 * z+5] * buffer[10 * z+5];
		
		
		pix[3] = sqrt(-1.0f + 2 * (buffer[10 * z+3] + buffer[10 * z+4])/(buffer[10 * z+3] + buffer[10 * z+4] + hypot(pix[0],2* buffer[10 * z+5])));
		pix[4] = atan2(2* buffer[10 * z+5], pix[0]); // 2angle 
		
		if ((!LFHPrimitive::ExCo<double>::isValid(pix[3]))||(!LFHPrimitive::ExCo<double>::isValid(pix[4]))){
			pix[3] = 1.0f; // is a circle if that is unstable!
			pix[4] = 0.0f;
		}
		if (pix[3] < 0.75) pix[3] =0.75f;
		
		
		if (ellipseMode){
			if (!LFHPrimitive::ExCo<double>::isValid(newell[0])) newell[0] =0;
			else cover[z].center[0] = (cover[z].center[0]*255.0f + newell[0]) / 256.0f;
			if (!LFHPrimitive::ExCo<double>::isValid(newell[1])) newell[1] =0;
			else cover[z].center[1] = (cover[z].center[1]*255.0f + newell[1]) / 256.0f;
			
			//			newell[2] = 2.0f * sqrt(buffer[10 * z+7] / (pix[3] * M_PI));
			newell[2] = buffer[10 * z + 6] * 6.0f / (pix[3]*buffer[10 * z]);
			pix[1] = sqrt(1 - pix[3]*pix[3]);
			newell[3]= cos(pix[4] *0.5f) * newell[2] * pix[1] *0.5f;if (!LFHPrimitive::ExCo<double>::isValid(newell[3])) newell[3] =0;
			newell[4]= sin(pix[4] *0.5f) * newell[2] * pix[1] *0.5f;if (!LFHPrimitive::ExCo<double>::isValid(newell[4])) newell[4] =0;
			if ((cover[z].width < 0.5f)||(!LFHPrimitive::ExCo<double>::isValid(newell[2]))) newell[2] =0.5f;
			cover[z].width= (cover[z].width *255.0f  + newell[2]) / 256.0f;
			cover[z].eccentric[0]= (cover[z].eccentric[0]*7.0f + newell[3]) *0.125f;
			cover[z].eccentric[1]= (cover[z].eccentric[1]*7.0f + newell[4]) *0.125f;
		}else{
			if (!LFHPrimitive::ExCo<double>::isValid(newell[0])) newell[0] =0;
			else cover[z].center[0] = (cover[z].center[0]+ newell[0]) *0.5f;
			if (!LFHPrimitive::ExCo<double>::isValid(newell[1])) newell[1] =0;
			else cover[z].center[1] = (cover[z].center[1] + newell[1]) *0.5f;			
			
			//	newell[2] = 2.0f * sqrt(buffer[10 * z+7] / (pix[3] * M_PI));
			newell[2] = buffer[10 * z + 6] * 6.0f / (buffer[10 * z]);
			if ((cover[z].width < 0.5f)||(!LFHPrimitive::ExCo<double>::isValid(newell[2]))) newell[2] =0.5f;
			cover[z].width= (cover[z].width + newell[2]) *0.5f;
			cover[z].eccentric[0]= 0.0f;
			cover[z].eccentric[1]= 0.0f;
			
			
		}
		
	}
	
	delete[](buffer);
	
}

void randomvector(double norm, LFHPrimitive::Vector<double> &target){
	int i;
	double sum =0;
	double u,v;
	int lenght = target.size();
	for(i=0;i<lenght-1;i+=2){
		v = (2.0f * M_PI  *rand()) / (((double)RAND_MAX)+1);
		u = -log(1.0f + 2.0f*rand()) + log((double)(2.0f*RAND_MAX+2.0f)); 
		sum += u; u = sqrt(u);
		target[i] = u * cos(v);
		target[i+1] = u * sin(v);
	}
	if (i < lenght){
		v = (2.0f * M_PI  *rand()) / (((double)RAND_MAX)+1);
		u = -log(1.0f + 2.0f*rand()) + log((double)(2.0f*RAND_MAX+2.0f));
		u = sqrt(u);
		target[i] = u * cos(v);
		sum += target[i]*target[i];
	}
	sum = norm * pow(sum,-0.5f);
	for(i=0;i<lenght;i++) target[i] *=sum;
}

void randomnormalvector(double norm, LFHPrimitive::Vector<double> &target, LFHPrimitive::Vector<double> &normalto){
	int i;
	double sum =0;
	double u,v;
	int lenght = target.size();
	double proj =0.0f;
	for(i=0;i<lenght-1;i+=2){
		v = (2.0f * M_PI  *rand()) / (((double)RAND_MAX)+1);
		u = -log(1.0f + 2.0f*rand()) + log((double)(2.0f*RAND_MAX+2.0f)); 
		sum += u; u = sqrt(u);
		target[i] = u * cos(v); proj += target[i] * normalto[i];
		target[i+1] = u * sin(v); proj += target[i+1] * normalto[i+1];
	}
	if (i < lenght){
		v = (2.0f * M_PI  *rand()) / (((double)RAND_MAX)+1);
		u = -log(1.0f + 2.0f*rand()) + log((double)(2.0f*RAND_MAX+2.0f));
		u = sqrt(u);
		target[i] = u * cos(v);
		sum += target[i]*target[i]; proj += target[i] * normalto[i];
	}
	
	
	
	sum = norm * pow(sum,-0.5f);
	for(i=0;i<lenght;i++) target[i] *=sum;
}

double vectoreval(Madstructs::Image<double>* source, Madstructs::Image<double>* label, LFHPrimitive::Vector<double> &target, double* areas, double *_partial){
	int x,y,z,w;
	double _out =0.0f;
	double pix[32];
	double pox[32];
	double tmpsum;
	double tmp, dist,sum;
	double prior[32];
	
	
	
	
	sum = 0.0f;
	
	for(z=0;z<label->channels;z++){
		prior[z] =   exp(2.0f * target[z*3]) * M_PI;
		sum += prior[z];
	}
	
	
	tmpsum =  0.5f * (log(areas[label->channels]) - log(sum)); // observed area / seen area
	
	if (LFHPrimitive::ExCo<double>::isValid(tmpsum)) for(z=0;z<label->channels;z++) target[z*3] += tmpsum;
	
	
	
	
	if (sum > 0.0f) {
		sum = 1.0f / sum;
		for(z=0;z<label->channels;z++) prior[z] *= sum;
		
	}else {
		sum = 1.0f / label->channels;
		for(z=0;z<label->channels;z++) prior[z] = sum;
	}
	
	/*
	sum = 0.0f;
	for(z=0;z<label->channels;z++) {printf("%e\t", prior[z]); sum += areas[z];}
	printf(" is da prior\n");
    
	for(z=0;z<label->channels;z++) printf("%e\t", areas[z] / sum);
	printf(" is da areas\n");
	

	printf("%e\t is da ll\n", _out);*/
	
	for(z=0;z<label->channels;z++){
		_out += areas[z] * log(prior[z]);
	}
	
	if (_partial != NULL) (*_partial) = _out;
	bool yok = false;
	
	for(y=-label->sizey;y<label->sizey *2;y++)	{
		if (y == 0) yok = true;
		else if (y == label->sizey) yok = false;
		for(x=-label->sizex;x<label->sizex*2;x++){
			for(z=0;z<label->channels;z++){
				tmp = x - target[z*3+1]; prior[z]  = tmp * tmp;
				tmp = y - target[z*3+2]; prior[z] = sqrt(prior[z] + tmp * tmp);
				if ((z == 0)||(prior[z] - exp(target[z*3]) < dist)) {
					dist = prior[z] - exp(target[z*3]);
					w = z;
				}
			}
			dist /= exp(target[w*3]);
			dist *= 10.0f; // prob of background
			
			

			if ((yok)&&(x>=0)&&(x<label->sizex)){
		
		label->getPixel(x,y,pix);
		source->getPixel(x,y,pox);
				
				_out += (1.0f - pox[0]) * MY_LOGOF_LOGISTIC_P(dist);
				_out += pox[0] * MY_LOGOF_LOGISTIC_P(-dist);
		
		tmpsum = 0.0f; 
			for(z=0;z<label->channels;z++){
		
				tmp = (pox[3] + prior[z]) -exp(target[z*3]);
				tmpsum +=  pix[z] * ( tmp * tmp / 2.0f*2.0f);
			}
			_out += -0.5f * tmpsum* pox[0];
			}else{
				_out += MY_LOGOF_LOGISTIC_P(dist);
			
			}
			
		}
	}
	
	
	return(_out);
}


void Madstructs::CellCover::cellUpdateEllipse_EM_steps(Madstructs::Image<double>* source, Madstructs::Image<double>* label, bool ellipseMode){
	int z;	
	LFHPrimitive::Vector<double> current;
	LFHPrimitive::Vector<double> move;
	LFHPrimitive::Vector<double> myrandom;
	LFHPrimitive::Vector<double> direct;
	current.setSize(3 * label->channels);
	move.setSize(3 * label->channels);
	myrandom.setSize(3 * label->channels);
	for(z=0;z<label->channels;z++){
		current[z*3] = log(cover[z].width * 0.5f);
		current[z*3 + 1] = cover[z].center[0];
		current[z*3 + 2] = cover[z].center[1];
	}
	

	double* areas = new double[label->channels+1];
	
		double gradiant;
	int x,y;
	double pix[32];
	double pox[32];
	memset(areas,'\0', sizeof(double)* (label->channels+1));
	for(y=0;y<label->sizey;y++)	for(x=0;x<label->sizex;x++){
		label->getPixel(x,y,pix);
		source->getPixel(x,y,pox);
		areas[label->channels] += pox[0];
		for(z=0;z<label->channels;z++){
			if (LFHPrimitive::ExCo<double>::isValid(pix[z])) areas[z] += pix[z] * pox[0];
		}
	}


	
	
	double best = vectoreval(source,label,current,areas,&gradiant);
//	 printf("LL = %e,%e (INITIAL)\n", best ,gradiant);
	
	
	int k;
	double last[2];

	int i;
	double norm = 2.0f;
	while(true){
	
		do {
			norm *=0.25f;
			randomvector(norm, myrandom); // for(z=0;z<label->channels;z++){myrandom[z*3+0]=0.0f;} 
			move = current;
			move += myrandom;
			last[0] = vectoreval(source,label,move,areas,NULL);i++;
		} while((fabs(norm) > DBL_EPSILON)&&(last[0] <= best));
		
		if (fabs(norm) <= DBL_EPSILON) break;
		direct = myrandom;
		current = move;
		gradiant = last[0] - best;
		best = last[0]; // printf("LL = %e (random) \n", best);
		while(true){
	
			// scan step;
		randomnormalvector(norm,myrandom,direct); // for(z=0;z<label->channels;z++){myrandom[z*3+0]=0.0f;} 
		move = current;
		move += direct;
		move += myrandom;
		last[0] = vectoreval(source,label,move,areas,NULL);i++;
		move = current;
		move += direct;
		move -= myrandom;
		last[1] = vectoreval(source,label,move,areas,NULL);i++;
	//	current.show(stdout);

		if ((best > last[0])&&(best > last[1])){
			norm *= 0.5f;
			break; // we are lost, start over
		}
			
		// we weakly belive that best -gradient is thevalue inth middle, we choose the next direction under that belief
		
			k = (last[0] > last[1]) ? 0:1;
			if (best + gradiant  < last[k]){
				if (k==0) direct += myrandom;
				else direct -= myrandom;
				gradiant = last[k] - best;
				norm *= sqrt(2);
				current += direct;
				best = last[k]; 
			//	printf("LL = %e (scan and turn) \n", best);
			}else{
				current += direct;
				if (k==0) gradiant = 0.75f * last[0] + 0.25f * last[1] - best;
				else gradiant = 0.25f * last[0] + 0.75f * last[1] - best;
				best = last[k]; 
			//	printf("LL = %e (scan) \n", best);
			}
			
			
			// depth step
			move = current;
			move += direct;
			last[0] = vectoreval(source,label,move,areas,NULL);i++;
			
			if ((best > last[0])){
				norm *= 0.5f;
				break; // we are lost, start over
			}
			
			// we believe 1 = (last[0] - best) / gradient, if that is so true, double step size
			
			last[1] = log(last[0] - best) - log(gradiant);
			last[1] = 0.5f + 3.0f / (2.0f + last[1] * last[1] );
			if (!LFHPrimitive::ExCo<double>::isValid(last[1])) last[1] =0.5f;
			norm *= last[1];
			gradiant = (last[0] - best) * last[1];
			best = last[0]; //printf("LL = %e (depth fact %f) \n", best, last[1]);
			
		}
		
			
		}
	
	best = vectoreval(source,label,current,areas,&gradiant);
	
	
//	printf("LL = %e,%e (FINAL)\n", best, gradiant);
	
	
	for(z=0;z<label->channels;z++){
		cover[z].width = 2.0f * exp(current[z*3]);
		cover[z].center[0] = current[z*3 + 1];
		cover[z].center[1] = current[z*3 + 2];
	}
	delete[](areas);
	
}


void Madstructs::CellCover::cellGenPrattFit(Madstructs::Image<double>* source, Madstructs::Image<double>* target, bool lowconf){

	
	
//	LFHPrimitive::Matrix<double,double,5> minstats[32];
//	int i,x,y;
//	for(i=0;i< label.;i++}
	
	
	


}

void Madstructs::CellCover::cellUpdate3(Madstructs::Image<double>* source, Madstructs::Image<double>* label, double alpha, bool issearching){
	double pix[32];
	double pox[32];
	int x,y,z;
	double tmp,tmp2,tot,dist;
	double* shifts = new double[8*label->channels];
	memset(shifts,'\0',sizeof(double)*8*label->channels);
	//	printf("Update start!\n");fflush(stdout);
	double realerr;
	
	for(y=0;y<label->sizey;y++){
		for(x=0;x<label->sizex;x++){
	
			
			// old_scale!
			//		if ((x < source->sizex)||(y<source->sizey)||(x>=2*source->sizex)||(y>=2*source->sizey)) pix[2] = 1.0f;
			//		else source->getPixel(x - source->sizex,y - source->sizey,pix);
			//		if (pix[2] != 0.0f)	pix[0] = ((1.0f / pix[2]) -1.0f) * 10.0f;
			//		else pix[0] = 50.0f;

					if ((x < source->sizex)||(y<source->sizey)||(x>=2*source->sizex)||(y>=2*source->sizey)) {pix[0] = 0.0f;pix[2] = 0.0f;}
					else source->getPixel(x - source->sizex,y - source->sizey,pix);
					
			
			
			
			label->getPixel(x,y,pox);
			
			tot =0;
			for(z=0;z<label->channels;z++){
				tot += pox[z];
			}
			if (tot > 0.0f) {
				//		tmp2 = tot;	
				//	for(z=0;z<label->channels;z++){
				//		tot += pox[z] * (tmp2 - pox[z])*4;
				//	}
				//	for(z=0;z<label->channels;z++){
				//		pox[z] /= tot;
				//	}
				
				
				tmp2 = 1-tot;
				// if tmp < 1 attract circles, if tmp > 1 repulse circles
				// else tmp2 = alpha *(-tot); // always repulse
			//	if (pix[0] >= 0.1) printf("%f\t", pix[2]*2);

				for(z=0;z<label->channels;z++){
					tmp = (x - cover[z].center[0]); dist = tmp*tmp;
					tmp = (y - cover[z].center[1]); dist = sqrt(tmp*tmp+ dist);
					
					if (pix[0] < 0.1) tmp = -0.2;//-tot; // always repulse;
					else {
						realerr = (pix[2]*2 + dist*2) / cover[z].width - 1;
			//			printf("%f\t",  cover[z].width - dist*2);
						//if (fabs(tmp) > 0.25f) tmp =0.0f; // tmp = 1.0f- 2.0f / (1.0f + exp(tmp));
						tmp = realerr / (1 + realerr*realerr);
						tmp += (pox[z] - tot) ;
						
						tmp += 0.2f; // anti repulse!
					}
					
					realerr = pox[z] - pix[0];
					tmp2 = pox[z] / tot;

					shifts[8*z+5] +=  realerr * tmp2;shifts[8*z+6] +=  realerr  * realerr  * tmp2; shifts[8*z+7] += tmp2;
					

					
					if ((dist != 0)&&(pox[z]  != 0.0f) ){
						shifts[8*z+0] += (tmp) * pox[z]  * (x - cover[z].center[0]) / (dist*cover[z].width);
						shifts[8*z+1] += (tmp) * pox[z]  * (y - cover[z].center[1]) / (dist*cover[z].width);
						shifts[8*z+2] += (tmp) * pox[z]  * dist / (cover[z].width * cover[z].width);
					}
				}
			//	if (pix[0] >= 0.1)printf("\n");
			}
		}
	}
	
	for(z=0;z<label->channels;z++){
		cover[z].center[0] +=  alpha *3*shifts[8*z+0];
		cover[z].center[1] +=  alpha *3*shifts[8*z+1];
		cover[z].width +=  alpha *3*shifts[8*z+2];
		if (cover[z].width < 1.0f) cover[z].width = 1.0f;
		if (shifts[8*z+7] == 0.0f) {cover[z].error[0] = 0.0f; cover[z].error[1] = 0.0f;}
			else {cover[z].error[0] = shifts[8*z+5] / shifts[8*z+7];
			cover[z].error[1] = shifts[8*z+6] / shifts[8*z+7] - cover[z].error[0] *cover[z].error[0];}
		cover[z].area = shifts[8*z+7];
		if (issearching){
			if (cover[z].error[0] < -0.05f){
				// illegal! too large cell and error!
				cover[z].error[0] = (20.0f * cover[z].error[0] + 1.0f) / 19.0f;
				cover[z].width *= 0.95f;
			} else if (cover[z].error[0] > 0.05f){
				// illegal! too large cell and error!
				cover[z].error[0] = (20.0f * cover[z].error[0] - 1.0f) / 21.0f;
				cover[z].width *= 1.05f;
			}
		}
		
	}
	delete[](shifts);
	//	printf("Update done!\n");fflush(stdout);
}

void Madstructs::CellCover::cellIntUpdate(Madstructs::Image<double>* source, Madstructs::Image<double>* label, LFHPrimitive::GaussianDistribution<1>* distribs){
	int x,y,z;
	for(z=0;z<label->channels;z++) distribs[z].EMinit();
	double pix[32];
	LFHPrimitive::Tuple<double,1> inten;
	double isum;
	for(y=0;y<source->sizey;y++) for(x=0;x<source->sizex;x++){
		source->getPixel(x,y,pix);
		inten[0] = pix[1];
		isum = pix[0];
		label->getPixel(x,y,pix); 
		for(z=0;z<label->channels;z++) distribs[z].EMregist(inten, pix[z] * isum);
	}
	
	for(z=0;z<label->channels;z++) distribs[z].EMfinit();	
}
void Madstructs::CellCover::cellUpdate_EM(Madstructs::Image<double>* source, Madstructs::Image<double>* label, double alpha, bool issearching){
	double pix[32];
	int x,y,z,w,k;
	double tmp,tmp2;
	double* shifts = new double[10*label->channels];
	memset(shifts,'\0',sizeof(double)*10*label->channels);
	//	printf("Update start!\n");fflush(stdout);

	
	LFHPrimitive::DataGrid<double, 2> linearsys;
	
	double* target = new double [cover.size() *5];
	double* innerderiv = new double [cover.size() *5];
	double* innerdderiv = new double [cover.size() *25];
	unsigned int coor[2];
	coor[0] = cover.size() *5;
	coor[1] = cover.size() *5;
	linearsys.setSizes(coor);
	
	
	double* dists = new double [cover.size()*3];
	
	// DIFF CELLS
	//	double testss = (1 - (S / (1 + exp(data[0])))) * (((I * P / (1 + exp(data[1])))  - 1) - (((I * P - S) * (   (P- 2*S) + (S * P / (1 + exp(data[1]))) )   )/(S*(P-S)))) ;
	
	//	printf("%f == %f ? \n",testss , firstt);
	//	return( (exp(data[1]) * exp(data[0])/(S*(P-S))) * (testss  - ((I * P - S)  / (1 + exp(data[0])))) );

	
	// SAME CELL
	//double testss = (1 + exp(data[0]) - S) * (I * P  - 1 - exp(data[0]) *(( S*(P-S) + (I * P - S) * ( (P- 2*S))  )/(S*(P-S))) - (((I * P - S) * ( (P- 2*S) + S * P)  )/(S*(P-S))) ) ;
	
	//printf("%f == %f ? \n",exp(data[0]) *exp(data[0]) *testss /(S*(P-S))  , firstt);
	//return( (exp(data[0]) * exp(data[0])/(S*(P-S)* (1 + exp(data[0]))* (1 + exp(data[0])) )) * (testss  + (I * P - S) * (1 + exp(data[0]) - S)) );
	
	/*
	coef[0] = (1 - S) * (I * P - 1  - (((I * P - S) * ( (P- 2*S) + S * P)  )/(S*(P-S))));
//	coef[1] = I * P - 2 + S - 2 * (((I * P - S) * ( (P- 2*S) + S * S) )/(S*(P-S)));
	coef[2] = -(( S*S + I * P * (P- 2*S) )/(S*(P-S)));
	
	coef[3] = (I * P  - 1 - (((I * P - S) * ( (P- 2*S) + S * P)  )/(S*(P-S))));
	coef[4] = -(1 - S) * ((( S*(P-S) + (I * P - S) * ( (P- 2*S))  )/(S*(P-S)))  );
	*/

	// self
	/*
	//	coef[0] += (I * P - S) * (1 - S); // self mod
	//	coef[1] += (I * P - S);
	// other
	coef[0] -= (I * P - S);
	coef[4] -= (I * P - S);
	*/
	
	for(z=0;z<label->channels*5;z++) target[z] =0.0f;
	LFHPrimitive::ExOp::toZero(linearsys);
	
	double sum, prod;
	double leadfact[5];
	for(y=0;y<label->sizey;y++){
		for(x=0;x<label->sizex;x++){
			
			sum =0.0f;
			prod = 1.0f;
			for(z=0;z<label->channels;z++){
				tmp = (x-cover[z].center[0]+cover[z].eccentric[0]); tmp2 = tmp*tmp;
				tmp = (y-cover[z].center[1]+cover[z].eccentric[1]); dists[z*3+ 1] = sqrt(tmp2 + tmp*tmp);
				tmp = (x-cover[z].center[0]-cover[z].eccentric[0]); tmp2 = tmp*tmp;
				tmp = (y-cover[z].center[1]-cover[z].eccentric[1]); dists[z*3 +2] = sqrt(tmp2 + tmp*tmp);
				
				dists[z*3] = exp( 10 - ((dists[z*3+2] + dists[z*3 +1]) / cover[z].width));
				sum += dists[z*3 ];
				prod *= (1 + dists[z*3]);
				
				// the division by cover[z].width is exported
				innerderiv[5*z + 0] = (dists[z*3+2] + dists[z*3 +1])/ (cover[z].width);
				leadfact[0] = (x -cover[z].center[0]+cover[z].eccentric[0]) / dists[z*3+1];
				leadfact[1] = (y -cover[z].center[1]+cover[z].eccentric[1]) / dists[z*3+1];
				leadfact[2] = (x -cover[z].center[0]-cover[z].eccentric[0]) / dists[z*3+2];
				leadfact[3] = (y -cover[z].center[1]-cover[z].eccentric[1]) / dists[z*3+2];
				innerderiv[5*z + 1] = leadfact[0] + leadfact[2];
				innerderiv[5*z + 2] = leadfact[1] + leadfact[3];
				innerderiv[5*z + 3] = -leadfact[0] + leadfact[2];
				innerderiv[5*z + 4] = -leadfact[1] + leadfact[3];
				
				innerderiv[25*z + 0] = - 2 *  (dists[z*3+2] + dists[z*3 +1])/ (cover[z].width*cover[z].width);
				for(k=1;k<5;k++) innerderiv[25*z + 5 * k] = innerderiv[25*z + k] = -innerderiv[5*z + k] / (cover[z].width);
				
				// diag
				innerderiv[25*z + 6] = (-1 / dists[z*3+1]) + (-1 / dists[z*3+2]) -(leadfact[0] * leadfact[0]/ (2*dists[z*3+1])) -(leadfact[2] * leadfact[2]/ (2*dists[z*3+2]));
				innerderiv[25*z + 12] = (-1 / dists[z*3+1]) + (-1 / dists[z*3+2]) -(leadfact[1] * leadfact[1]/ (2*dists[z*3+1])) -(leadfact[3] * leadfact[3]/ (2*dists[z*3+2]));
				innerderiv[25*z + 18] = (-1 / dists[z*3+1]) + (-1 / dists[z*3+2]) -(leadfact[0] * leadfact[0]/ (2*dists[z*3+1])) -(leadfact[2] * leadfact[2]/ (2*dists[z*3+2]));
				innerderiv[25*z + 24] = (-1 / dists[z*3+1]) + (-1 / dists[z*3+2]) -(leadfact[1] * leadfact[1]/ (2*dists[z*3+1])) -(leadfact[3] * leadfact[3]/ (2*dists[z*3+2]));
				
				
				innerderiv[25*z + 16] = innerderiv[25*z + 8] = (1 / dists[z*3+1]) + (-1 / dists[z*3+2]) + (leadfact[0] * leadfact[0]/ (2*dists[z*3+1])) -(leadfact[2] * leadfact[2]/ (2*dists[z*3+2]));
				innerderiv[25*z + 22] = innerderiv[25*z + 14] = (1 / dists[z*3+1]) + (-1 / dists[z*3+2]) + (leadfact[1] * leadfact[1]/ (2*dists[z*3+1])) -(leadfact[3] * leadfact[3]/ (2*dists[z*3+2]));

				// cx cy
				innerderiv[25*z + 11] = innerderiv[25*z + 7] = -(leadfact[0] * leadfact[1]/ (2*dists[z*3+1])) -(leadfact[2] * leadfact[3]/ (2*dists[z*3+2]));
				// cx ey 
				innerderiv[25*z + 21] = innerderiv[25*z + 9] = (leadfact[0] * leadfact[1]/ (2*dists[z*3+1])) -(leadfact[2] * leadfact[3]/ (2*dists[z*3+2]));
				// ex cy 
				innerderiv[25*z + 13] = innerderiv[25*z + 17] = (leadfact[0] * leadfact[1]/ (2*dists[z*3+1])) -(leadfact[2] * leadfact[3]/ (2*dists[z*3+2]));
				// ex ey 
				innerderiv[25*z + 23] = innerderiv[25*z + 19] = -(leadfact[0] * leadfact[1]/ (2*dists[z*3+1])) -(leadfact[2] * leadfact[3]/ (2*dists[z*3+2]));

				
				
			}
			if (!LFHPrimitive::ExCo<double>::isValid(1.0f / sum)) continue;
			
			// pixels are owned by D3 / sum, and the state probability is sum / prod

			if ((x < source->sizex)||(y<source->sizey)||(x>=2*source->sizex)||(y>=2*source->sizey)) {pix[0] = 0.0f;pix[2] = 0.0f;}
			else source->getPixel(x - source->sizex,y - source->sizey,pix);
			
			
			pix[0] *= prod;
			leadfact[0] = (1-sum) * (pix[0] - 1 -((pix[0] - sum)* (prod +sum*(prod-2)) /(sum * (prod-sum))));
			leadfact[1] = (pix[0]  - 1 - (((pix[0] - sum) * ( (prod- 2*sum) + sum * prod)  )/(sum*(prod-sum))));
			leadfact[2] = -(1 - sum) * ((( sum*(prod-sum) + (pix[0] - sum) * ( (prod- 2*sum))  )/(sum*(prod-sum)))  );
			leadfact[3] = -((sum*sum + pix[0]*(prod-2*sum)) /(sum * (prod-sum))); 
			
			
			
			leadfact[0] -= pix[0] - sum;
			leadfact[2] -= pix[0] - sum;
			
			for(z=0;z<label->channels;z++){
				for(w=0;w<label->channels;w++){
					if (w == z) continue;
					coor[1] = z *5;
					leadfact[4] = (dists[z*3] * dists[w*3] / ((1 + dists[z*3])*(1+dists[w*3])*sum*(prod-sum) * cover[z].width * cover[w].width))* (leadfact[0] + leadfact[1] * dists[z*3] + dists[w*3] * (leadfact[2] + dists[z*3] * leadfact[3]));
					coor[0] = w *5;for(k=0;k<5;k++,coor[0]++)linearsys(coor) += leadfact[4] * innerderiv[5*z] * innerderiv[5*w+k];
					coor[1]++;
					coor[0] = w *5;for(k=0;k<5;k++,coor[0]++)linearsys(coor) += leadfact[4] * innerderiv[5*z+1] * innerderiv[5*w+k];
					coor[1]++;
					coor[0] = w *5;for(k=0;k<5;k++,coor[0]++)linearsys(coor) += leadfact[4] * innerderiv[5*z+2] * innerderiv[5*w+k];
					coor[1]++;
					coor[0] = w *5;for(k=0;k<5;k++,coor[0]++)linearsys(coor) += leadfact[4] * innerderiv[5*z+3] * innerderiv[5*w+k];
					coor[1]++;
					coor[0] = w *5;for(k=0;k<5;k++,coor[0]++)linearsys(coor) += leadfact[4] * innerderiv[5*z+4] * innerderiv[5*w+k];
				}
			}
			
			leadfact[0] += (2- sum) *(pix[0] - sum);
			leadfact[1] += 2 *(pix[0] - sum) + leadfact[2];
			
			for(z=0;z<label->channels;z++){
				coor[0] = z *5;
				coor[1] = z *5;
				leadfact[4] = (dists[z*3] * dists[w*3] / ((1 + dists[z*3])*(1+dists[w*3])*sum*(prod-sum) * cover[z].width * cover[w].width))* (leadfact[0] + dists[z*3] * (leadfact[1] + dists[z*3] * leadfact[3]));
				for(k=0;k<5;k++,coor[0]++) linearsys(coor) += leadfact[4] * innerdderiv[25*z+k];
				coor[1]++; coor[0] = w *5;
				for( ;k<10;k++,coor[0]++) linearsys(coor) += leadfact[4] * innerdderiv[25*z+k];
				coor[1]++; coor[0] = w *5;
				for( ;k<15;k++,coor[0]++) linearsys(coor) += leadfact[4] * innerdderiv[25*z+k];
				coor[1]++; coor[0] = w *5;
				for( ;k<20;k++,coor[0]++) linearsys(coor) += leadfact[4] * innerdderiv[25*z+k];
				coor[1]++; coor[0] = w *5;
				for( ;k<25;k++,coor[0]++) linearsys(coor) += leadfact[4] * innerdderiv[25*z+k];
			}
		}
	}
	
	for(z=0;z<label->channels;z++){
		cover[z].center[0] +=  alpha *3*shifts[8*z+0];
		cover[z].center[1] +=  alpha *3*shifts[8*z+1];
		cover[z].width +=  alpha *3*shifts[8*z+2];
		if (cover[z].width < 1.0f) cover[z].width = 1.0f;
		if (shifts[8*z+7] == 0.0f) {cover[z].error[0] = 0.0f; cover[z].error[1] = 0.0f;}
		else {cover[z].error[0] = shifts[8*z+5] / shifts[8*z+7];
		cover[z].error[1] = shifts[8*z+6] / shifts[8*z+7] - cover[z].error[0] *cover[z].error[0];}
		cover[z].area = shifts[8*z+7];
		if (issearching){
			if (cover[z].error[0] < -0.05f){
				// illegal! too large cell and error!
				cover[z].error[0] = (20.0f * cover[z].error[0] + 1.0f) / 19.0f;
				cover[z].width *= 0.95f;
			} else if (cover[z].error[0] > 0.05f){
				// illegal! too large cell and error!
				cover[z].error[0] = (20.0f * cover[z].error[0] - 1.0f) / 21.0f;
				cover[z].width *= 1.05f;
			}
		}
		
	}
			   

	delete[](shifts);
	delete[](target);
	delete[](innerderiv);
	delete[](innerdderiv);
	//	printf("Update done!\n");fflush(stdout);
}


void Madstructs::CellCover::cellUpdate4(Madstructs::Image<double>* source, Madstructs::Image<double>* label, double alpha){
	double pix[32];
	double pox[32];
	int x,y,z;
	double tmp,tmp2,tot,dist, dist2;
	double* shifts = new double[8*label->channels];
	memset(shifts,'\0',sizeof(double)*8*label->channels);
	
	double realerr;
	//	printf("Update start!\n");fflush(stdout);
	
	for(y=0;y<label->sizey;y++){
		for(x=0;x<label->sizex;x++){
			
			if ((x < source->sizex)||(y<source->sizey)||(x>=2*source->sizex)||(y>=2*source->sizey)) pix[2] = 1.0f;
			else source->getPixel(x - source->sizex,y - source->sizey,pix);
			
			if (pix[2] != 0.0f)	pix[0] = ((1.0f / pix[2]) -1.0f) * 10.0f;
			else pix[0] = 50.0f;
			
			label->getPixel(x,y,pox);
			
			tot =0;
			for(z=0;z<label->channels;z++){
				tot += pox[z];
			}
			if (tot > 0.0f) {
				//		tmp2 = tot;	
				//	for(z=0;z<label->channels;z++){
				//		tot += pox[z] * (tmp2 - pox[z])*4;
				//	}
				//	for(z=0;z<label->channels;z++){
				//		pox[z] /= tot;
				//	}
				
				
				tmp2 = 1-tot;
				// if tmp < 1 attract circles, if tmp > 1 repulse circles
				// else tmp2 = alpha *(-tot); // always repulse
				
				for(z=0;z<label->channels;z++){
					tmp = (x - cover[z].center[0] + cover[z].eccentric[0]); dist = tmp*tmp;
					tmp = (y - cover[z].center[1] + cover[z].eccentric[1]); dist = sqrt(tmp*tmp+ dist);
					tmp = (x - cover[z].center[0] - cover[z].eccentric[0]); dist2= tmp*tmp;
					tmp = (y - cover[z].center[1] - cover[z].eccentric[1]); dist2= sqrt(tmp*tmp+ dist2);
					
					if (pix[0] == 0) tmp = -0.2;//-tot; // always repulse;
					else {
						realerr = (pix[0]*2 + dist + dist2) / cover[z].width - 1;
						//if (fabs(tmp) > 0.25f) tmp =0.0f; // tmp = 1.0f- 2.0f / (1.0f + exp(tmp));
						tmp = realerr / (realerr*realerr + 1);
						tmp += (pox[z] - tot);
						
						tmp += 0.2f; // anti repulse!
					}
					
					if ((dist != 0)&&(pox[z]  != 0.0f) ){
						shifts[8*z+0] +=  (tmp * pox[z] / (cover[z].width)) * ((x - cover[z].center[0] + cover[z].eccentric[0]) /dist + (x - cover[z].center[0] - cover[z].eccentric[0]) /dist2);
						shifts[8*z+1] += (tmp * pox[z] / (cover[z].width)) * ((y - cover[z].center[1] + cover[z].eccentric[1]) /dist + (y - cover[z].center[1] - cover[z].eccentric[1]) /dist2);
						shifts[8*z+2] += tmp * pox[z] * (dist+ dist2) / (cover[z].width*cover[z].width );
						shifts[8*z+3] +=  -(tmp * pox[z] / (cover[z].width)) * ((x - cover[z].center[0] + cover[z].eccentric[0]) /dist - (x - cover[z].center[0] - cover[z].eccentric[0]) /dist2);
						shifts[8*z+4] += -(tmp * pox[z] / (cover[z].width)) * ((y - cover[z].center[1] + cover[z].eccentric[1]) /dist - (y - cover[z].center[1] - cover[z].eccentric[1]) /dist2);
						
						if (pix[0] != 0) {shifts[8*z+5] +=  realerr * pox[z];shifts[8*z+6] +=  realerr *realerr * pox[z]; shifts[8*z+7] += pox[z];}
					}
				}
			}
		}
	}
	
	for(z=0;z<label->channels;z++){
		cover[z].center[0] +=  alpha *3*shifts[8*z+0];
		cover[z].center[1] +=  alpha *3*shifts[8*z+1];
		cover[z].width +=  alpha *3*shifts[8*z+2];
		tmp2 = 2.0f * sqrt(cover[z].eccentric[0]*cover[z].eccentric[0] + cover[z].eccentric[1]*cover[z].eccentric[1]) / cover[z].width;
		tmp2 = ((tmp2 - 2.0f)/(2 * (tmp2 -1.0f))) ;
		cover[z].eccentric[0] = cover[z].eccentric[0]*tmp2 + alpha *shifts[5*z+3];
		cover[z].eccentric[1] = cover[z].eccentric[1]*tmp2 + alpha *shifts[5*z+4];
		dist = cover[z].width / (2.0f * sqrt(cover[z].eccentric[0]*cover[z].eccentric[0] + cover[z].eccentric[1]*cover[z].eccentric[1]));
		tmp2 = 1.0f + dist - sqrt(dist*dist +1.0f);
		cover[z].eccentric[0] *= tmp2;
		cover[z].eccentric[1] *= tmp2;
		
		cover[z].error[0] = shifts[8*z+5] / shifts[8*z+7];
		cover[z].error[1] = shifts[8*z+6] / shifts[8*z+7] - cover[z].error[0] *cover[z].error[0];
		cover[z].area = shifts[8*z+7];
	}
	delete[](shifts);
	//	printf("Update done!\n");fflush(stdout);
}

void Madstructs::CellCover::cellUpdate2(Madstructs::Image<double>* source, Madstructs::Image<double>* label,double expc, double alpha, double constrex){
	double pix[32];
	double pox[32];
	int x,y,z;
	double tmp,tmp2,tot,dist,dist2;
	double* shifts = new double[5*label->channels];
	memset(shifts,'\0',sizeof(double)*5*label->channels);
	double expget = (cover.size() / expc);
	if (expget > 1) expget = 1;
	
	for(y=0;y<label->sizey;y++){
		for(x=0;x<label->sizex;x++){
			
			if ((x < source->sizex)||(y<source->sizey)||(x>=2*source->sizex)||(y>=2*source->sizey)) pix[2] = 1.0f;
			else source->getPixel(x - source->sizex,y - source->sizey,pix);
			
			if (pix[2] != 0.0f)	pix[0] = ((1.0f / pix[2]) -1.0f) * 10.0f;
			else pix[0] = 50.0f;
			
			label->getPixel(x,y,pox);
			
			tot =0;
			for(z=0;z<label->channels;z++){
				tot += pox[z];
			}
			if (tot > 0.0f){
			tmp2 = 0;
			for(z=0;z<label->channels;z++){
				tmp2 += pox[z] * (tot - pox[z]);
			}
			tmp2 /= tot*tot;
			}
			

			
			for(z=0;z<label->channels;z++){
				tmp = (x - cover[z].center[0] + cover[z].eccentric[0]); dist = tmp*tmp;
				tmp = (y - cover[z].center[1] + cover[z].eccentric[1]); dist = sqrt(tmp*tmp+ dist);
				tmp = (x - cover[z].center[0] - cover[z].eccentric[0]); dist2= tmp*tmp;
				tmp = (y - cover[z].center[1] - cover[z].eccentric[1]); dist2= sqrt(tmp*tmp+ dist2);
				
				if (pix[0] == 0) tmp = -0.2;//-tot; // always repulse;
				else {
					tmp = (pix[0]*2 + dist + dist2) / cover[z].width - 1;
					//if (fabs(tmp) > 0.25f) tmp =0.0f; // tmp = 1.0f- 2.0f / (1.0f + exp(tmp));
					tmp = tmp / (tmp*tmp + 1);
					tmp += (pox[z] - tot);
					
					tmp += 0.2f; // anti repulse!
				}
				
				if (dist != 0){
					shifts[5*z+0] +=  (tmp * pox[z] / (cover[z].width)) * ((x - cover[z].center[0] + cover[z].eccentric[0]) /dist + (x - cover[z].center[0] - cover[z].eccentric[0]) /dist2);
					shifts[5*z+1] += (tmp * pox[z] / (cover[z].width)) * ((y - cover[z].center[1] + cover[z].eccentric[1]) /dist + (y - cover[z].center[1] - cover[z].eccentric[1]) /dist2);
					shifts[5*z+2] += tmp * pox[z] * (dist+ dist2) / (cover[z].width*cover[z].width );
					shifts[5*z+3] +=  -(tmp * pox[z] / (cover[z].width)) * ((x - cover[z].center[0] + cover[z].eccentric[0]) /dist - (x - cover[z].center[0] - cover[z].eccentric[0]) /dist2);
					shifts[5*z+4] += -(tmp * pox[z] / (cover[z].width)) * ((y - cover[z].center[1] + cover[z].eccentric[1]) /dist - (y - cover[z].center[1] - cover[z].eccentric[1]) /dist2);
				}
			}
			
		}
	}
	dist = 2.0f;
	for(z=0;z<label->channels;z++){
		cover[z].center[0] += alpha * dist *shifts[5*z+0];
		cover[z].center[1] += alpha * dist *shifts[5*z+1];
		dist2 = (1 - exp((cover[z].width+ alpha * dist *shifts[5*z+2]-75)/75.0f));
		if (dist2 > 0) cover[z].width += alpha * dist *shifts[5*z+2] * dist2;
		tmp = (cover[z].eccentric[0] + alpha * dist *shifts[5*z+3]); dist2 = tmp*tmp;
		tmp2 = (cover[z].width > 50)? 50 : cover[z].width;
		tmp2 = tmp2*tmp2/6;
		tmp = (cover[z].eccentric[1] + alpha * dist *shifts[5*z+4]);
		if ((tmp*tmp + dist2) == 0) dist2 = 1.0f;
		else dist2 = 1-exp((1 - tmp2/(tmp*tmp + dist2))* constrex);
		if (dist2 > 0) cover[z].eccentric[0] += alpha * dist *shifts[5*z+3]*dist2;
		if (dist2 > 0) cover[z].eccentric[1] += alpha * dist *shifts[5*z+4]*dist2;
	}
	delete[](shifts);
}

/*

for(y=0;y<label->sizey;y++){
	for(x=0;x<label->sizex;x++){
		if ((x < source->sizex)||(y<source->sizey)||(x>=2*source->sizex)||(y>=2*source->sizey)) pix[2] = 1.0f;
			else source->getPixel(x - source->sizex,y - source->sizey,pix);
				// sets pix[0] to be the distance to the edge
				if (pix[2] != 0.0f)	pix[0] = ((1.0f / pix[2]) -1.0f) * 10.0f; // archaic scaling of the distance to the edge
				else pix[0] = 50.0f;
				label->getPixel(x,y,pox); // store in POX the pixel ownership for the cells 
				tot =0;
				for(z=0;z<label->channels;z++){
					tot += pox[z];
				}
		if (tot > 0.0f) { // our pixel is from the foreground
			tmp2 = 1-tot;
			for(z=0;z<label->channels;z++){ // for each cell in our group
				tmp = (x - cover[z].center[0]); dist = tmp*tmp;
				tmp = (y - cover[z].center[1]); dist = sqrt(tmp*tmp+ dist); // dist is the computed distance to cell center
				if (pix[0] > (ExCo<double>::epsilon)) { // current pixel is owned by cell of interest
				if ((dist*2 < cover[z].width)&&(dist >0)){
					realerr = (pix[0]*2 + dist*2) / cover[z].width - 1; // deviation to the expected distance to the edge (normalized)
				}else realerr = ((pix[0]*2) / cover[z].width); // outside circle
				tmp = realerr / (realerr*realerr + 1);
				if ((dist != 0)&&(pox[z]  != 0.0f) ){
					shifts[8*z+0] += (tmp) * pox[z]  * (x - cover[z].center[0]) / (dist*cover[z].width); // update for x coordinate
					shifts[8*z+1] += (tmp) * pox[z]  * (y - cover[z].center[1]) / (dist*cover[z].width); // update for y coordinate
					shifts[8*z+2] += (tmp) * pox[z]  * dist / (cover[z].width * cover[z].width); // update for radius
				}
			}
		}
	}
}


*/



void Madstructs::CellCover::cellUpdate6(Madstructs::Image<double>* source, Madstructs::Image<double>* label, double alpha){
	double pix[32];
	double pox[32];
	int x,y,z,k;
	double tmp,tmp2,tot,dist;
	double* shifts = new double[8*label->channels];
	memset(shifts,'\0',sizeof(double)*8*label->channels);
	//	printf("Update start!\n");fflush(stdout);
	double realerr;
	
	
	double poxpr[4];
	
	
	double* interpts = new double[label->channels *label->channels*4];
	for(z=0;z<label->channels;z++){
		for(k=label->channels -1;k>z;k--){
			interpts[4*(k + z * label->channels)] = (cover[z].center[0] * cover[k].width + cover[k].center[0] * cover[z].width) / (cover[z].width + cover[k].width);
			interpts[4*(k + z * label->channels)+1] = (cover[z].center[1] * cover[k].width + cover[k].center[1] * cover[z].width) / (cover[z].width + cover[k].width);
			
			dist = Madstructs::L2norm( cover[z].center[0] - cover[k].center[0], cover[z].center[1] - cover[k].center[1]) *2.0f;
			
			tmp = (dist + cover[k].width + cover[z].width) /2.0f;
			tmp = tmp * (tmp - dist) * (tmp -cover[k].width)* (tmp -cover[z].width);
			
			tmp = (tmp <=0.0f) ? 0.0f : 2.0f*sqrt(tmp) /(dist * dist); // height of the neck
			
			
			interpts[4*(k + z * label->channels)+2] = tmp *(cover[z].center[1] - cover[k].center[1]);
			interpts[4*(k + z * label->channels)+3] = -tmp *(cover[z].center[0] - cover[k].center[0]);
		}
		for(;k>=0;k--){
			memcpy( interpts +(4*(k + z * label->channels)), interpts + (4*(z + k * label->channels)), sizeof(double)*4);
		}
	}
	

	for(y=0;y<label->sizey;y++){
		for(x=0;x<label->sizex;x++){
			
			if ((x < source->sizex)||(y<source->sizey)||(x>=2*source->sizex)||(y>=2*source->sizey)) pix[2] = 1.0f;
			else source->getPixel(x - source->sizex,y - source->sizey,pix);
			
			if (pix[2] != 0.0f)	pix[0] = ((1.0f / pix[2]) -1.0f) * 10.0f;
			else pix[0] = 50.0f;
			
			label->getPixel(x,y,pox);
			
			tot =0;
			for(z=0;z<label->channels;z++){
				tot += pox[z];
			}
			if (tot > 0.0f) {
				//		tmp2 = tot;	
				//	for(z=0;z<label->channels;z++){
				//		tot += pox[z] * (tmp2 - pox[z])*4;
				//	}
				//	for(z=0;z<label->channels;z++){
				//		pox[z] /= tot;
				//	}
				
				
				tmp2 = 1-tot;
				// if tmp < 1 attract circles, if tmp > 1 repulse circles
				// else tmp2 = alpha *(-tot); // always repulse
				
				for(z=0;z<label->channels;z++){
					tmp = (x - cover[z].center[0]); dist = tmp*tmp;
					tmp = (y - cover[z].center[1]); dist = sqrt(tmp*tmp+ dist);
					
					if (pix[0] == 0) tmp = -0.2;//-tot; // always repulse;
					else {
						
						
						
						
						
						
						if ((dist*2 < cover[z].width)&&(dist >0)){
							poxpr[0] = cover[z].center[0] + cover[z].width * (x - cover[z].center[0]) / (dist*2);
							poxpr[1] = cover[z].center[1] + cover[z].width * (y - cover[z].center[1]) / (dist*2);
							poxpr[3] = cover[z].width;
							for(k=0;k<label->channels;k++){
								if (k != z){
								tmp = (poxpr[0] - cover[k].center[0]); poxpr[2] = tmp*tmp;
								tmp = (poxpr[1] - cover[k].center[1]); poxpr[2] = sqrt(tmp*tmp+ poxpr[2]);
								if (poxpr[2]*2 < cover[k].width){
								// obstructed pixel, changing its aim
									poxpr[2] = Madstructs::L2norm(x - interpts[4*(k + z * label->channels)+0] - interpts[4*(k + z * label->channels)+2],
																  y - interpts[4*(k + z * label->channels)+1] - interpts[4*(k + z * label->channels)+3]);
									if (poxpr[3] > poxpr[2]) poxpr[3] = poxpr[2];
									poxpr[2] = Madstructs::L2norm(x - interpts[4*(k + z * label->channels)+0] + interpts[4*(k + z * label->channels)+2],
																  y - interpts[4*(k + z * label->channels)+1] + interpts[4*(k + z * label->channels)+3]);
									if (poxpr[3] > poxpr[2]) poxpr[3] = poxpr[2];
								}
								}
								}
							
								if (poxpr[3] == cover[z].width) realerr = (pix[0]*2 + dist*2) / cover[z].width - 1;
								else realerr = (pix[0]*2 - poxpr[3]*2) / cover[z].width;
							
								}else realerr = (pix[0]*2 + dist*2) / cover[z].width - 1;
						
						
						//if (fabs(tmp) > 0.25f) tmp =0.0f; // tmp = 1.0f- 2.0f / (1.0f + exp(tmp));
						tmp = realerr / (realerr*realerr + 1);
						tmp += (pox[z] - tot);
						
						tmp += 0.2f; // anti repulse!
					}
					
					if ((dist != 0)&&(pox[z]  != 0.0f) ){
						shifts[8*z+0] += (tmp) * pox[z]  * (x - cover[z].center[0]) / (dist*cover[z].width);
						shifts[8*z+1] += (tmp) * pox[z]  * (y - cover[z].center[1]) / (dist*cover[z].width);
						shifts[8*z+2] += (tmp) * pox[z]  * dist / (cover[z].width * cover[z].width);
						if (pix[0] != 0) {shifts[8*z+5] +=  (tmp -0.2f) * pox[z];shifts[8*z+6] +=  (tmp -0.2f) *(tmp -0.2f) * pox[z]; shifts[8*z+7] += pox[z];}
					}
				}
			}
		}
	}
	
	for(z=0;z<label->channels;z++){
		cover[z].center[0] +=  alpha *3*shifts[8*z+0];
		cover[z].center[1] +=  alpha *3*shifts[8*z+1];
		cover[z].width +=  alpha *3*shifts[8*z+2];
		if (cover[z].width < 1.0f) cover[z].width = 1.0f;
		if (shifts[8*z+7] == 0.0f) {cover[z].error[0] = 0.0f; cover[z].error[1] = 0.0f;}
		else {cover[z].error[0] = shifts[8*z+5] / shifts[8*z+7];
		cover[z].error[1] = shifts[8*z+6] / shifts[8*z+7] - cover[z].error[0] *cover[z].error[0];}
		cover[z].area = shifts[8*z+7];
	}
	delete[](shifts);
	delete[](interpts);
	//	printf("Update done!\n");fflush(stdout);
}


/*
void Madstructs::CellCover::cellUpdate2(Madstructs::Image<double>* source, Madstructs::Image<double>* label,double expc, double alpha, double constrex){
	double pix[32];
	double pox[32];
	int x,y,z;
	double tmp,tmp2,tot,dist,dist2;
	double* shifts = new double[5*label->channels];
	memset(shifts,'\0',sizeof(double)*5*label->channels);
	double expget = (cover.size() / expc);
	if (expget > 1) expget = 1;
	
	for(y=0;y<label->sizey;y++){
		for(x=0;x<label->sizex;x++){
			
			if ((x < source->sizex)||(y<source->sizey)||(x>=2*source->sizex)||(y>=2*source->sizey)) pix[2] = 1.0f;
			else source->getPixel(x - source->sizex,y - source->sizey,pix);
			label->getPixel(x,y,pox);
			
			tot =0;
			for(z=0;z<label->channels;z++){
				tot += pox[z];
			}
			if (tot > 0.0f){
				tmp2 = 0;
				for(z=0;z<label->channels;z++){
					tmp2 += pox[z] * (tot - pox[z]);
				}
				tmp2 /= tot*tot;
			}
			if (pix[2] == 0.0f){
				// in cell
				
				tmp2 = alpha * (-tmp2*4 + (expget-tot) / tot);
				// if tmp < 1 attract circles, if tmp > 1 repulse circles
				
				
			}else tmp2 = -alpha; // always repulse
			
			for(z=0;z<label->channels;z++){
				tmp = (x - cover[z].center[0] + cover[z].eccentric[0]); dist = tmp*tmp;
				tmp = (y - cover[z].center[1] + cover[z].eccentric[1]); dist = sqrt(tmp*tmp+ dist);
				tmp = (x - cover[z].center[0] - cover[z].eccentric[0]); dist2= tmp*tmp;
				tmp = (y - cover[z].center[1] - cover[z].eccentric[1]); dist2= sqrt(tmp*tmp+ dist2);
				if (dist != 0){
					shifts[5*z+0] +=  (tmp2 * pox[z] / (cover[z].width)) * ((x - cover[z].center[0] + cover[z].eccentric[0]) /dist + (x - cover[z].center[0] - cover[z].eccentric[0]) /dist2);
					shifts[5*z+1] += (tmp2 * pox[z] / (cover[z].width)) * ((y - cover[z].center[1] + cover[z].eccentric[1]) /dist + (y - cover[z].center[1] - cover[z].eccentric[1]) /dist2);
					shifts[5*z+2] += tmp2 * pox[z] * (dist+ dist2) / (cover[z].width*cover[z].width );
					shifts[5*z+3] +=  -(tmp2 * pox[z] / (cover[z].width)) * ((x - cover[z].center[0] + cover[z].eccentric[0]) /dist - (x - cover[z].center[0] - cover[z].eccentric[0]) /dist2);
					shifts[5*z+4] += -(tmp2 * pox[z] / (cover[z].width)) * ((y - cover[z].center[1] + cover[z].eccentric[1]) /dist - (y - cover[z].center[1] - cover[z].eccentric[1]) /dist2);
				}
			}
			
		}
	}
	dist = 2.0f;
	for(z=0;z<label->channels;z++){
		cover[z].center[0] += dist *shifts[5*z+0];
		cover[z].center[1] += dist *shifts[5*z+1];
		dist2 = (1 - exp((cover[z].width+ dist *shifts[5*z+2]-75)/75.0f));
		if (dist2 > 0) cover[z].width += dist *shifts[5*z+2] * dist2;
		tmp = (cover[z].eccentric[0] + dist *shifts[5*z+3]); dist2 = tmp*tmp;
		tmp2 = (cover[z].width > 50)? 50 : cover[z].width;
		tmp2 = tmp2*tmp2/6;
		tmp = (cover[z].eccentric[1] + dist *shifts[5*z+4]);
		if ((tmp*tmp + dist2) == 0) dist2 = 1.0f;
		else dist2 = 1-exp((1 - tmp2/(tmp*tmp + dist2))* constrex);
		if (dist2 > 0) cover[z].eccentric[0] += dist *shifts[5*z+3]*dist2;
		if (dist2 > 0) cover[z].eccentric[1] += dist *shifts[5*z+4]*dist2;
	}
	delete[](shifts);
}*/



LFHPrimitive::WeightElem<double, 2>* Madstructs::CellCover::computeErrorunderHeuristic(const LFHPrimitive::DataGrid< LFHPrimitive::Tuple<double,1>, 2 > &source, LFHPrimitive::DataGrid< int ,2> incmessage) const{
	int nbc = cover.size();
	stack<LFHPrimitive::Tuple<unsigned int,2> > pts;
	
	LFHPrimitive::WeightElem<double, 2>* _out = new LFHPrimitive::WeightElem<double, 2>[nbc];
	
	LFHPrimitive::Tuple< LFHPrimitive::Tuple<unsigned int,2 >, 8> neigh;
	
	LFHPrimitive::Tuple<int,2> curpt;
	
	
	LFHPrimitive::DataGrid< double* ,2> wei;
	
	double* cura;
				 
	wei.setSizes(incmessage.dims);
	
	LFHPrimitive::ExOp::toZero(wei);
	int i,j;
	for(i=0;i<nbc;i++){
		curpt[0] = (int) cover[i].center[0];
		curpt[1] = (int) cover[i].center[1];
		
		if ((cura = wei(curpt)) == NULL){
			wei(curpt) = cura = new double[nbc];
			for(j=0;j<nbc;j++) cura[j] = (j == i) ? 1.0f : 0.0f;
		}else for(j=0;j<nbc;j++) cura[j] += (j == i) ? 1.0f : 0.0f;
		
//		printf("found a pix!, %i sinks\n",incmessage(curpt) );
	}
	
	double pix[32];
	
	LFHPrimitive::DataGrid< int ,2>::KeyIterator ite = incmessage.getKeyIterator();

	LFHPrimitive::Tuple<unsigned int, 3> metapt;
	
	

	
	if (ite.first()) do{
		if (incmessage(ite()) == 0) {
		pts.push(ite());
			
		}
	} while(ite.next());
	
	double tmp, tmp2, dist;
	
	LFHPrimitive::WeightElem<double, 1>* curw = new LFHPrimitive::WeightElem<double, 1>[cover.size()];
//	printf("nb max %i\n", pts.size());
	
	while(!pts.empty()){
		curpt = pts.top(); pts.pop();
		int nbn = incmessage.get_indirectNeightbor(curpt, neigh);

		pix[0] = source(curpt)[0];
//		printf("dist! %f, %i\n", pix[0], nbn);
		if (pix[0] >= 0.1f){
		
		cura = wei(curpt);
			
		
				
		if (cura != NULL) {
				 // default value, dont change!
			
			for(i=0;i<nbn;i++){
				pix[1] = source(neigh[i])[0];
				if (pix[1] < pix[0]){
					incmessage(neigh[i])--;
					if (incmessage(neigh[i]) == 0) pts.push(neigh[i]);
				}
			}
			
		}else{
			
			for(j=0;j<nbc;j++) LFHPrimitive::ExOp::toZero(curw[j]);
				
			
			for(i=0;i<nbn;i++){
				pix[1] = source(neigh[i])[0];
				if (pix[1] > pix[0]){
					tmp = (pix[1] - pix[0]) / (((curpt[0] + curpt[1] -neigh[i][0]-neigh[i][1] ) & 1) ? 1.0f : sqrt(2.0f));
					tmp = tmp * tmp;
					if (wei(neigh[i]) == NULL) printf("WTF!!!\n");
					else for(j=0;j<nbc;j++){
		//				printf("%f\t%f\n", wei(neigh[i])[j],  tmp);
						curw[j] += LFHPrimitive::WeightElem<double, 1>( wei(neigh[i])[j],  tmp);
					}
	//				printf("hoho %i\n", incmessage(neigh[i]));
					
				}else if (pix[1] < pix[0]){
	//				printf("Down from %i\n", incmessage(neigh[i]));
					incmessage(neigh[i])--;
					if (incmessage(neigh[i]) == 0) pts.push(neigh[i]);
				}
			}
				wei(curpt) = cura = new double[nbc];
				if (curw[0].w[0] == 0.0f){				
				for(j=0;j<nbc;j++) cura[j] = 0.0f; 
				}else{
					for(j=0;j<nbc;j++) cura[j] = curw[j].getMean();
				}
		}
		tmp =0;
		for(j=0;j<nbc;j++) tmp += cura[j];
			if (tmp != 0) tmp = 1 / tmp;
			for(j=0;j<nbc;j++) {
				tmp2 = cover[j].center[0] - curpt[0]; dist = tmp2* tmp2;
				tmp2 = cover[j].center[1] - curpt[1]; dist = sqrt(tmp2*tmp2 + dist);
				
				_out[j] += LFHPrimitive::WeightElem<double, 2>( pix[0] + dist, cura[j]*tmp);
			}
		
			
		}	 
		

	}
	
	delete[](curw);
	
	if (ite.first()) do{
		if (wei(ite()) != NULL) delete[](wei(ite()));
	}while(ite.next());
	
	return(_out);
}





void Madstructs::CellCover::findCellCoverHeuristic(Madstructs::Image<double>* source, double epsilon, LFHPrimitive::Classifier<LFHPrimitive::Tuple<double,1>,2> * intdistrib){
	LFHPrimitive::Vector< LFHPrimitive::KeyElem< double, LFHPrimitive::Tuple<int,2> > > areas;
	LFHPrimitive::DataGrid< LFHPrimitive::WeightElem<double, 2> ,2> areamap; // area, distsum, dist2sum
	LFHPrimitive::DataGrid< LFHPrimitive::WeightElem<double, 1> ,2> intenstitymap; // area, distsum, dist2sum
	LFHPrimitive::DataGrid< int ,2> incmessage; 
	LFHPrimitive::Tuple<unsigned int, 2> coor;
	unsigned int dim[2];
	dim[0] = source->sizex;
	dim[1] = source->sizey;
	incmessage.setSizes(dim); incmessage *= 0;
	if (intdistrib) intenstitymap.setSizes(dim);
	areamap.setSizes(dim);
	LFHPrimitive::WeightElem<double, 2> tmppix = LFHPrimitive::WeightElem<double, 2>(0.0f,1.0f);
	LFHPrimitive::Tuple<double,1> que;
	LFHPrimitive::Tuple<double,2> ans;
	int i;
	double pix[32];
	double pox[32];
	
	LFHPrimitive::Tuple<unsigned int, 2> neigh[8];
	double dist[8][2];
	
	
	for(coor[1]=0;coor[1]<source->sizey;coor[1]++) for(coor[0]=0;coor[0]<source->sizex;coor[0]++){
		source->getPixel(coor[0],coor[1],pix);
		if (!LFHPrimitive::ExCo<double>::isValid(pix[0])) {pix[0] = 0.0f; source->setPixel(coor[0],coor[1],pix);} 
		areamap(coor) =(pix[0] > 0.1f) ? tmppix : LFHPrimitive::WeightElem<double, 2>(pix[2],pix[0]);
		
		if (intdistrib) intenstitymap(coor) = LFHPrimitive::WeightElem<double, 1>(pix[1],pix[2] * pix[2] * pix[0]); // the weight is the distance!
		
	//	printf("%f\t%f\n", pix[2], pix[0]);
	//	printf("%f\t%f\n", areamap(coor).getMean(), areamap(coor).getVar());
		if (pix[0] > 0.1f){

		
		if (coor[1] < source->sizey-1){
			source->getPixel(coor[0],coor[1]+1,pox);
			
			if (pox[0] > 0.1f){
			if (pix[2] > pox[2]) incmessage(coor) += 1;
			else if (pix[2] < pox[2]) {	coor[1] ++; incmessage(coor) += 1; 	coor[1] --;}	
			}
			coor[1]++;
			if (coor[0] < source->sizex-1){
				source->getPixel(coor[0]+1,coor[1],pox);
				if (pox[0] > 0.1f){
				if (pix[2] > pox[2]) {	coor[1] --; incmessage(coor) += 1; 	coor[1] ++;}
				else if (pix[2] < pox[2]) {	coor[0] ++; incmessage(coor) += 1; 	coor[0] --;}	
				}
				
			}
			
			if (coor[0] > 0){
				source->getPixel(coor[0]-1,coor[1],pox);
				if (pox[0] > 0.1f){
				if (pix[2] > pox[2]) {	coor[1] --; incmessage(coor) += 1; 	coor[1] ++;}
				else if (pix[2] < pox[2]) {	coor[0] --; incmessage(coor) += 1; 	coor[0]++;}	
				}

			}
			coor[1]--;
		}
		
		if (coor[0] < source->sizex-1){
			source->getPixel(coor[0]+1,coor[1],pox);
			if (pox[0] > 0.1f){
			if (pix[2] > pox[2]) incmessage(coor) += 1;
			else if (pix[2] < pox[2]) {	coor[0] ++; incmessage(coor) += 1; 	coor[0] --;}	
			}
		}
			
		}
		
	}
	
	stack<LFHPrimitive::Tuple<int,2> > pts;

	for(coor[1]=0;coor[1]<source->sizey;coor[1]++) for(coor[0]=0;coor[0]<source->sizex;coor[0]++){
		source->getPixel(coor[0],coor[1],pix);
		if ((incmessage(coor) == 0)&&(pix[0] > 0.1f)) {pts.push(coor);}
		

	}
	
	double sum;
	LFHPrimitive::WeightElem<double,2> pub;
	LFHPrimitive::WeightElem<double,1> pub_2;
	int j=0;
	while(!pts.empty()) {
		j++;
			coor = pts.top();pts.pop();
			int nbn=0;
			tmppix = areamap(coor);
			sum =0;
		
			source->getPixel(coor[0],coor[1],pix);
		
			if (coor[0] > 0){
				coor[0]--;
				if (coor[1] > 0){
				coor[1]--;
					source->getPixel(coor[0],coor[1],pox);
					if (pix[2] < pox[2]){
						neigh[nbn][0] = coor[0];neigh[nbn][1] = coor[1];dist[nbn][0]=(pox[2] - pix[0])/sqrt(2); dist[nbn][1]=pix[0];dist[nbn][0] *= dist[nbn][0];sum += dist[nbn][0]* dist[nbn][1]; nbn++; 
					}
				coor[1]++;
				}
				
				
				source->getPixel(coor[0],coor[1],pox);
				if (pix[2] < pox[2]){
					neigh[nbn][0] = coor[0];neigh[nbn][1] = coor[1];dist[nbn][0]=(pox[2] - pix[0]); dist[nbn][1]=pix[0];dist[nbn][0] *= dist[nbn][0];sum += dist[nbn][0]* dist[nbn][1]; nbn++;
				}
				
				if (coor[1] < source->sizey-1){
					coor[1]++;
					source->getPixel(coor[0],coor[1],pox);
					if (pix[2] < pox[2]){
						neigh[nbn][0] = coor[0];neigh[nbn][1] = coor[1];dist[nbn][0]=(pox[2] - pix[0])/sqrt(2); dist[nbn][1]=pix[0];dist[nbn][0] *= dist[nbn][0];sum += dist[nbn][0]* dist[nbn][1]; nbn++;
					}
					coor[1]--;
				}
				coor[0]++;
			}
		
		
		if (coor[0] < source->sizex-1){
			coor[0]++;
			if (coor[1] > 0){
				coor[1]--;
				source->getPixel(coor[0],coor[1],pox);
				if (pix[2] < pox[2]){
					neigh[nbn][0] = coor[0];neigh[nbn][1] = coor[1];dist[nbn][0]=(pox[2] - pix[0])/sqrt(2); dist[nbn][1]=pix[0];dist[nbn][0] *= dist[nbn][0];sum += dist[nbn][0]* dist[nbn][1]; nbn++;
				}
				coor[1]++;
			}
			
			
			source->getPixel(coor[0],coor[1],pox);
			if (pix[2] < pox[2]){
				neigh[nbn][0] = coor[0];neigh[nbn][1] = coor[1];dist[nbn][0]=(pox[2] - pix[0]); dist[nbn][1]=pix[0];dist[nbn][0] *= dist[nbn][0];sum += dist[nbn][0]* dist[nbn][1]; nbn++;
			}
			
			if (coor[1] < source->sizey-1){
				coor[1]++;
				source->getPixel(coor[0],coor[1],pox);
				if (pix[2] < pox[2]){
					neigh[nbn][0] = coor[0];neigh[nbn][1] = coor[1];dist[nbn][0]=(pox[2] - pix[0])/sqrt(2); dist[nbn][1]=pix[0];dist[nbn][0] *= dist[nbn][0];sum += dist[nbn][0]* dist[nbn][1]; nbn++;
				}
				coor[1]--;
			}
			
			
			coor[0]--;
		}

		if (coor[1] > 0){
			coor[1]--;
			source->getPixel(coor[0],coor[1],pox);
			if (pix[2] < pox[2]){
				neigh[nbn][0] = coor[0];neigh[nbn][1] = coor[1];dist[nbn][0]=(pox[2] - pix[0]); dist[nbn][1]=pix[0];dist[nbn][0] *= dist[nbn][0];sum += dist[nbn][0]* dist[nbn][1]; nbn++;

			}
			coor[1]++;
		}
		
		if (coor[1] < source->sizey-1){
			coor[1]++;
			source->getPixel(coor[0],coor[1],pox);
			if (pix[2] < pox[2]){
				neigh[nbn][0] = coor[0];neigh[nbn][1] = coor[1];dist[nbn][0]=(pox[2] - pix[0]); dist[nbn][1]=pix[0];dist[nbn][0] *= dist[nbn][0]; sum += dist[nbn][0] * dist[nbn][1]; nbn++;
			}
			coor[1]--;
		}
				
		if (sum != 0){
			sum = 1.0f / sum;
			 
				for(i=0;i<nbn;i++) {
					pub = areamap(coor);
					pub += ((coor[0] + coor[1] - neigh[i][0] - neigh[i][1]) & 1) ? 1.0f : sqrt(2.0f);
					pub *=  LFHPrimitive::Weight(dist[i][0]*dist[i][1] * sum); //printf("%f\n", dist[i][0]*dist[i][1] * sum);
					areamap(neigh[i]) += pub;
				
					if (intdistrib){
						pub_2 = intenstitymap(coor);
						pub_2 *= LFHPrimitive::Weight(dist[i][0]*dist[i][1] * sum);
						intenstitymap(neigh[i]) += pub_2;
					}
					incmessage(neigh[i]) -= 1;
					if (incmessage(neigh[i]) == 0) pts.push(neigh[i]);
				}
			pox[10]  = areamap(coor).getMean();
		//	printf("ecart %f != %f,\n", pox[10], pix[2] * (1.0f + epsilon));
			pox[10] -= pix[2] * (1.0f + epsilon);
			pox[11] =  areamap(coor).getVar();
			
			if ((pox[11] == 0)||(isnan(pox[11]))){ // variance is zero!
				pox[10] = (pox[10] < 0.0f) ? areamap(coor).w[0] : 0.0f;
			}else{
				pox[10] /= sqrt(2.0f * pox[11]);
				pox[10] = (1.0f - erf(pox[10])) * 0.5f * areamap(coor).w[0];
			}
		//	printf("%f\t%f\n",pox[10], pox[11]);
			
			if (!isnan(pix[10])) {
				
				
			
		//	printf("%f\n",pox[10]);

				if (intdistrib){
					que[0] =pix[1];
					pub_2 = intenstitymap(coor); que[0] = pub_2.getMean();
					if (!isnan(que[0])){
					(*intdistrib)(ans,que);
					printf("%e!\n", ans[1]);
					if ((!isnan(pox[10] * ans[1]))&&(pox[10] *ans[1] >= 16.0f)) areas.push_back(LFHPrimitive::KeyElem< double , LFHPrimitive::Tuple<int,2> >( pox[10] *ans[1] , coor));
					}
				}else if (pox[10] >= 16.0f) areas.push_back(LFHPrimitive::KeyElem< double , LFHPrimitive::Tuple<int,2> >( pox[10], coor));
			}
		}
				
			
		
		
				
			

			
			
		}
		
	areas.sort();
	
	
	i = areas.size()-1;
	for(;i>=0;i--){
		source->getPixel(areas[i].d[0],areas[i].d[1],pix);
		for(j=0;j<cover.size();j++){
			dist[0][0] = cover[j].center[0] - areas[i].d[0];
			dist[0][1] = cover[j].center[1] - areas[i].d[1];
			dist[1][0] = sqrt(dist[0][0]*dist[0][0] + dist[0][1]*dist[0][1]);
			if (((dist[1][0] - pix[2])/ cover[j].width)  < 0.5f) break;
		}
		if (j == cover.size()){
			if ( LFHPrimitive::ExCo<double>::isValid(pix[2]) ){
			cover.push_back(Madstructs::CellPose());
			cover[j].center[0] = areas[i].d[0];
			cover[j].center[1] = areas[i].d[1];
			cover[j].width = pix[2] * 2.0f;			
			}
		}
	}


	

	computeerror(source);
	
	
	
	
}


void Madstructs::CellCover::findCellCoverHeuristic_Sep2011(Madstructs::Image<double>* source, double epsilon, LFHPrimitive::Classifier<LFHPrimitive::Tuple<double,1>,2> * intdistrib){
	LFHPrimitive::Vector< LFHPrimitive::KeyElem< double, LFHPrimitive::Tuple<int,2> > > areas;
	LFHPrimitive::DataGrid< LFHPrimitive::WeightElem<double, 2> ,2> areamap; // area, distsum, dist2sum
	LFHPrimitive::DataGrid< LFHPrimitive::WeightElem<double, 1> ,2> intenstitymap; // area, distsum, dist2sum
	LFHPrimitive::DataGrid< int ,2> incmessage; 
	LFHPrimitive::Tuple<unsigned int, 2> coor;
	unsigned int dim[2];
	dim[0] = source->sizex;
	dim[1] = source->sizey;
	incmessage.setSizes(dim); incmessage *= 0;
	if (intdistrib) intenstitymap.setSizes(dim);
	areamap.setSizes(dim);
	LFHPrimitive::WeightElem<double, 2> tmppix = LFHPrimitive::WeightElem<double, 2>(0.0f,1.0f);
	LFHPrimitive::Tuple<double,1> que;
	LFHPrimitive::Tuple<double,2> ans;
	int i;
	double pix[32];
	double pox[32];
	
	LFHPrimitive::Tuple<unsigned int, 2> neigh[8];
	double dist[8][2];
	
	
	for(coor[1]=0;coor[1]<source->sizey;coor[1]++) for(coor[0]=0;coor[0]<source->sizex;coor[0]++){
		source->getPixel(coor[0],coor[1],pix);
		if (!LFHPrimitive::ExCo<double>::isValid(pix[0])) {pix[0] = 0.0f; source->setPixel(coor[0],coor[1],pix);} 
		areamap(coor) =(pix[0] > 0.1f) ? tmppix : LFHPrimitive::WeightElem<double, 2>(pix[2],pix[0]);
		
		if (intdistrib) intenstitymap(coor) = LFHPrimitive::WeightElem<double, 1>(pix[1],pix[2] * pix[2] * pix[0]); // the weight is the distance!
		
		//	printf("%f\t%f\n", pix[2], pix[0]);
		//	printf("%f\t%f\n", areamap(coor).getMean(), areamap(coor).getVar());
		if (pix[0] > 0.1f){
			
			
			if (coor[1] < source->sizey-1){
				source->getPixel(coor[0],coor[1]+1,pox);
				
				if (pox[0] > 0.1f){
					if (pix[2] > pox[2]) incmessage(coor) += 1;
					else if (pix[2] < pox[2]) {	coor[1] ++; incmessage(coor) += 1; 	coor[1] --;}	
				}
				coor[1]++;
				if (coor[0] < source->sizex-1){
					source->getPixel(coor[0]+1,coor[1],pox);
					if (pox[0] > 0.1f){
						if (pix[2] > pox[2]) {	coor[1] --; incmessage(coor) += 1; 	coor[1] ++;}
						else if (pix[2] < pox[2]) {	coor[0] ++; incmessage(coor) += 1; 	coor[0] --;}	
					}
					
				}
				
				if (coor[0] > 0){
					source->getPixel(coor[0]-1,coor[1],pox);
					if (pox[0] > 0.1f){
						if (pix[2] > pox[2]) {	coor[1] --; incmessage(coor) += 1; 	coor[1] ++;}
						else if (pix[2] < pox[2]) {	coor[0] --; incmessage(coor) += 1; 	coor[0]++;}	
					}
					
				}
				coor[1]--;
			}
			
			if (coor[0] < source->sizex-1){
				source->getPixel(coor[0]+1,coor[1],pox);
				if (pox[0] > 0.1f){
					if (pix[2] > pox[2]) incmessage(coor) += 1;
					else if (pix[2] < pox[2]) {	coor[0] ++; incmessage(coor) += 1; 	coor[0] --;}	
				}
			}
			
		}
		
	}
	
	stack<LFHPrimitive::Tuple<int,2> > pts;
	
	for(coor[1]=0;coor[1]<source->sizey;coor[1]++) for(coor[0]=0;coor[0]<source->sizex;coor[0]++){
		source->getPixel(coor[0],coor[1],pix);
		if ((incmessage(coor) == 0)&&(pix[0] > 0.1f)) {pts.push(coor);}
		
		
	}
	
	double sum;
	LFHPrimitive::WeightElem<double,2> pub;
	LFHPrimitive::WeightElem<double,1> pub_2;
	int j=0;
	while(!pts.empty()) {
		j++;
		coor = pts.top();pts.pop();
		int nbn=0;
		tmppix = areamap(coor);
		sum =0;
		
		source->getPixel(coor[0],coor[1],pix);
		
		if (coor[0] > 0){
			coor[0]--;
			if (coor[1] > 0){
				coor[1]--;
				source->getPixel(coor[0],coor[1],pox);
				if (pix[2] < pox[2]){
					neigh[nbn][0] = coor[0];neigh[nbn][1] = coor[1];dist[nbn][0]=(pox[2] - pix[0])/sqrt(2); dist[nbn][1]=pix[0];dist[nbn][0] *= dist[nbn][0];sum += dist[nbn][0]* dist[nbn][1]; nbn++; 
				}
				coor[1]++;
			}
			
			
			source->getPixel(coor[0],coor[1],pox);
			if (pix[2] < pox[2]){
				neigh[nbn][0] = coor[0];neigh[nbn][1] = coor[1];dist[nbn][0]=(pox[2] - pix[0]); dist[nbn][1]=pix[0];dist[nbn][0] *= dist[nbn][0];sum += dist[nbn][0]* dist[nbn][1]; nbn++;
			}
			
			if (coor[1] < source->sizey-1){
				coor[1]++;
				source->getPixel(coor[0],coor[1],pox);
				if (pix[2] < pox[2]){
					neigh[nbn][0] = coor[0];neigh[nbn][1] = coor[1];dist[nbn][0]=(pox[2] - pix[0])/sqrt(2); dist[nbn][1]=pix[0];dist[nbn][0] *= dist[nbn][0];sum += dist[nbn][0]* dist[nbn][1]; nbn++;
				}
				coor[1]--;
			}
			coor[0]++;
		}
		
		
		if (coor[0] < source->sizex-1){
			coor[0]++;
			if (coor[1] > 0){
				coor[1]--;
				source->getPixel(coor[0],coor[1],pox);
				if (pix[2] < pox[2]){
					neigh[nbn][0] = coor[0];neigh[nbn][1] = coor[1];dist[nbn][0]=(pox[2] - pix[0])/sqrt(2); dist[nbn][1]=pix[0];dist[nbn][0] *= dist[nbn][0];sum += dist[nbn][0]* dist[nbn][1]; nbn++;
				}
				coor[1]++;
			}
			
			
			source->getPixel(coor[0],coor[1],pox);
			if (pix[2] < pox[2]){
				neigh[nbn][0] = coor[0];neigh[nbn][1] = coor[1];dist[nbn][0]=(pox[2] - pix[0]); dist[nbn][1]=pix[0];dist[nbn][0] *= dist[nbn][0];sum += dist[nbn][0]* dist[nbn][1]; nbn++;
			}
			
			if (coor[1] < source->sizey-1){
				coor[1]++;
				source->getPixel(coor[0],coor[1],pox);
				if (pix[2] < pox[2]){
					neigh[nbn][0] = coor[0];neigh[nbn][1] = coor[1];dist[nbn][0]=(pox[2] - pix[0])/sqrt(2); dist[nbn][1]=pix[0];dist[nbn][0] *= dist[nbn][0];sum += dist[nbn][0]* dist[nbn][1]; nbn++;
				}
				coor[1]--;
			}
			
			
			coor[0]--;
		}
		
		if (coor[1] > 0){
			coor[1]--;
			source->getPixel(coor[0],coor[1],pox);
			if (pix[2] < pox[2]){
				neigh[nbn][0] = coor[0];neigh[nbn][1] = coor[1];dist[nbn][0]=(pox[2] - pix[0]); dist[nbn][1]=pix[0];dist[nbn][0] *= dist[nbn][0];sum += dist[nbn][0]* dist[nbn][1]; nbn++;
				
			}
			coor[1]++;
		}
		
		if (coor[1] < source->sizey-1){
			coor[1]++;
			source->getPixel(coor[0],coor[1],pox);
			if (pix[2] < pox[2]){
				neigh[nbn][0] = coor[0];neigh[nbn][1] = coor[1];dist[nbn][0]=(pox[2] - pix[0]); dist[nbn][1]=pix[0];dist[nbn][0] *= dist[nbn][0]; sum += dist[nbn][0] * dist[nbn][1]; nbn++;
			}
			coor[1]--;
		}
		
		if (sum != 0){
			sum = 1.0f / sum;
			
			for(i=0;i<nbn;i++) {
				pub = areamap(coor);
				pub += ((coor[0] + coor[1] - neigh[i][0] - neigh[i][1]) & 1) ? 1.0f : sqrt(2.0f);
				pub *=  LFHPrimitive::Weight(dist[i][0]*dist[i][1] * sum); //printf("%f\n", dist[i][0]*dist[i][1] * sum);
				areamap(neigh[i]) += pub;
				
				if (intdistrib){
					pub_2 = intenstitymap(coor);
					pub_2 *= LFHPrimitive::Weight(dist[i][0]*dist[i][1] * sum);
					intenstitymap(neigh[i]) += pub_2;
				}
				incmessage(neigh[i]) -= 1;
				if (incmessage(neigh[i]) == 0) pts.push(neigh[i]);
			}
			pox[10]  = areamap(coor).getMean();
			//	printf("ecart %f != %f,\n", pox[10], pix[2] * (1.0f + epsilon));
			pox[10] -= pix[2] * (1.0f + epsilon);
			pox[11] =  areamap(coor).getVar();
			
			if ((pox[11] == 0)||(isnan(pox[11]))){ // variance is zero!
				pox[10] = (pox[10] < 0.0f) ? areamap(coor).w[0] : 0.0f;
			}else{
				pox[10] /= sqrt(2.0f * pox[11]);
				pox[10] = (1.0f - erf(pox[10])) * 0.5f * areamap(coor).w[0];
			}
			//	printf("%f\t%f\n",pox[10], pox[11]);
			
			if (!isnan(pix[10])) {
				
				
				
				//	printf("%f\n",pox[10]);
				
				if (intdistrib){
					que[0] =pix[1];
					pub_2 = intenstitymap(coor); que[0] = pub_2.getMean();
					if (!isnan(que[0])){
						(*intdistrib)(ans,que);
						printf("%e!\n", ans[1]);
						if ((!isnan(pox[10] * ans[1]))&&(pox[10]*ans[1] >= 16.0f)) areas.push_back(LFHPrimitive::KeyElem< double , LFHPrimitive::Tuple<int,2> >( pox[10] *ans[1] , coor));
					}
				}else if (pox[10] >= 16.0f) areas.push_back(LFHPrimitive::KeyElem< double , LFHPrimitive::Tuple<int,2> >( pox[10], coor));
			}
		}
		
		
		
		
		
		
		
		
		
	}
	
	areas.sort();
	
	
	i = areas.size()-1;
	for(;i>=0;i--){
		source->getPixel(areas[i].d[0],areas[i].d[1],pix);
		for(j=0;j<cover.size();j++){
			dist[0][0] = cover[j].center[0] - areas[i].d[0];
			dist[0][1] = cover[j].center[1] - areas[i].d[1];
			dist[1][0] = sqrt(dist[0][0]*dist[0][0] + dist[0][1]*dist[0][1]);
			if (((dist[1][0] - pix[2])/ cover[j].width)  < 0.5f) break;
		}
		if (j == cover.size()){
			if ( LFHPrimitive::ExCo<double>::isValid(pix[2]) ){
				cover.push_back(Madstructs::CellPose());
				cover[j].center[0] = areas[i].d[0];
				cover[j].center[1] = areas[i].d[1];
				cover[j].width = pix[2] * 2.0f;			
			}
		}
	}

	computeerror(source);
}


void Madstructs::CellCover::findCellCoverHeuristic_agglo(Madstructs::Image<double>* source){

	LFHPrimitive::DataGrid< unsigned int , 2> areasmap;
	LFHPrimitive::DataGrid< LFHPrimitive::Tuple<unsigned int, 2> , 2> loopy;
	
	LFHPrimitive::Tuple<unsigned int, 2> coor;
	unsigned int dim[2];
	dim[0] = source->sizex;
	dim[1] = source->sizey;
	areasmap.setSizes(dim);
	loopy.setSizes(dim);
	
	LFHPrimitive::ExOp::toZero(areasmap);
	unsigned int cur_area =0;
	
	LFHPrimitive::Vector< LFHPrimitive::KeyElem< double, LFHPrimitive::Tuple<int,2> > > intensities;
	
	LFHPrimitive::KeyElem< double, LFHPrimitive::Tuple<int,2> > inint;
	double pix[32];
	for(coor[1]=0;coor[1]<source->sizey;coor[1]++) for(coor[0]=0;coor[0]<source->sizex;coor[0]++){
		source->getPixel(coor[0],coor[1],pix);
		if (pix[0] > 0.1f){
		inint.d[0] = coor[0];
		inint.d[1] = coor[1];
		inint.k = pix[1];
		intensities.push_back(inint);
		}
	}
	
	intensities.sort();
	
	
	printf("%i pix!\n", intensities.size() );
	double circles;
	
	
	unsigned int pixite;
	unsigned int i;
	unsigned int n[5];
	LFHPrimitive::Tuple<unsigned int,2> n_coor;
	LFHPrimitive::Tuple<unsigned int,2> t_coor;
	
	
	map<unsigned int, LFHPrimitive::WeightElem< LFHPrimitive::Tuple<double, 5 > > > suffi;
	
	LFHPrimitive::Tuple<double, 5 > ex;
	
	for(pixite=intensities.size()-1;pixite != 0xFFFFFFFF;pixite--){
		coor = intensities[pixite].d;
		ex[0] = coor[0];
		ex[1] = coor[1];
		ex[2] = coor[0] * coor[0];
		ex[3] = coor[1] * coor[1];
		ex[4] = coor[1] * coor[0];

		coor[0]--;n[0] = (coor[0] !=0xFFFFFFFF) ? areasmap(coor) : 0 ; coor[0]++;
		coor[1]--;n[1] = (coor[1] !=0xFFFFFFFF) ? areasmap(coor) : 0 ; coor[1]++;
		coor[0]++;n[2] = (coor[0] != areasmap.dims[0]) ? areasmap(coor) : 0 ; coor[0]--;
		coor[1]++;n[3] = (coor[1] != areasmap.dims[1]) ? areasmap(coor) : 0 ; coor[1]--;

		n[4] = 0xFFFFFFFF;
		if (n[0] != 0) {n[4] = n[0];}
		if (n[1] != 0) {n[4] = (n[4] == 0xFFFFFFFF)? n[1] :  (n[4] != n[1]) ? 0 : n[4];}
		if (n[2] != 0) {n[4] = (n[4] == 0xFFFFFFFF)? n[2] :  (n[4] != n[2]) ? 0 : n[4];}
		if (n[3] != 0) {n[4] = (n[4] == 0xFFFFFFFF)? n[3] :  (n[4] != n[3]) ? 0 : n[4];}
		
	//	printf("%i\t%i\t%i\t%i\t%i\n", n[0], n[1], n[2], n[3], n[4]);
		if (n[4] != 0){ // create to join
		
		
		if (n[4] == 0xFFFFFFFF) { 
			// new areas
			loopy(coor) = coor;
			cur_area++;
			areasmap(coor) = cur_area;
			suffi[cur_area] = LFHPrimitive::WeightElem< LFHPrimitive::Tuple<double, 5 > >(ex,1.0f);
		} else {areasmap(coor) = n[4];
			suffi[n[4]] = suffi[n[4]] + LFHPrimitive::WeightElem< LFHPrimitive::Tuple<double, 5 > >(ex,1.0f);

			
			if (n[0] != 0) {t_coor[0] = coor[0]-1;t_coor[1] = coor[1]; loopy(coor) = loopy(t_coor); loopy(t_coor) = coor;}
			else if (n[1] != 0) {t_coor[0] = coor[0];t_coor[1] = coor[1]-1; loopy(coor) = loopy(t_coor); loopy(t_coor) = coor;}
			else if (n[2] != 0) {t_coor[0] = coor[0]+1;t_coor[1] = coor[1]; loopy(coor) = loopy(t_coor); loopy(t_coor) = coor;}
			else if (n[3] != 0) {t_coor[0] = coor[0];t_coor[1] = coor[1]+1; loopy(coor) = loopy(t_coor); loopy(t_coor) = coor;}
			
		
		}
			
		}else{ // MERGE AREA!!!
			// check area before merge!
			n[4] = 0xFFFFFFFF;
			if (n[0] != 0) {n[4] = n[0];}
			if (n[1] != 0) {if (n[1] < n[4]) n[4] = n[1];}
			if (n[2] != 0) {if (n[2] < n[4]) n[4] = n[2];}
			if (n[3] != 0) {if (n[3] < n[4]) n[4] = n[3];}
			
			printf("Merge in Area %i: %f pts \n", n[4], suffi[n[4]].w[0]);
			LFHPrimitive::ExOp::show(suffi[n[4]].getMean());
			
			suffi[n[4]] = suffi[n[4]] + LFHPrimitive::WeightElem< LFHPrimitive::Tuple<double, 5 > >(ex,1.0f);
			
			for(i=0;i<4;i++)
			if (n[i] > n[4]){
				if (suffi.end() != suffi.find(n[i])) {
				printf("Area %i: %f pts \n", n[i], suffi[n[i]].w[0]);
				LFHPrimitive::ExOp::show(suffi[n[i]].getMean());
				suffi[n[4]] += suffi[n[i]];
				suffi.erase(n[i]);
					
					switch (i) {
						case 0: t_coor[0] = coor[0]-1;t_coor[1] = coor[1]; break;
						case 1: t_coor[0] = coor[0];t_coor[1] = coor[1]-1; break;
						case 2: t_coor[0] = coor[0]+1;t_coor[1] = coor[1]; break;
						case 3: t_coor[0] = coor[0];t_coor[1] = coor[1]+1; break;
					}
					n_coor = loopy(t_coor);
					while((n_coor[0] != t_coor[0])||(n_coor[1] != t_coor[1])){
						areasmap(n_coor) = n[4];
						n_coor = loopy(n_coor);
					}
					areasmap(n_coor) = n[4];
					
				}
			} 
				
			
			n_coor = coor;
			if (n[0] != 0) {t_coor[0] = coor[0]-1;t_coor[1] = coor[1]; loopy(n_coor) = loopy(t_coor); n_coor = t_coor;}
			if (n[1] != 0) {t_coor[0] = coor[0];t_coor[1] = coor[1]-1; loopy(n_coor) = loopy(t_coor); n_coor = t_coor;}
			if (n[2] != 0) {t_coor[0] = coor[0]+1;t_coor[1] = coor[1]; loopy(n_coor) = loopy(t_coor); n_coor = t_coor;}
			if (n[3] != 0) {t_coor[0] = coor[0];t_coor[1] = coor[1]+1; loopy(n_coor) = loopy(t_coor); n_coor = t_coor;}
			loopy(n_coor) = coor;
			
			
		}
	}	
	
	

}

void Madstructs::CellCover::findCellCoverHeuristic_agglo2(Madstructs::Image<double>* source, double min_area){
	

	
	LFHPrimitive::DataGrid< LFHPrimitive::Tuple<unsigned int, 2> , 2> loopy;
	
	LFHPrimitive::DataGrid< double , 2> tr_map;
	
	LFHPrimitive::Tuple<unsigned int, 2> coor;
	unsigned int dim[2];
	dim[0] = source->sizex;
	dim[1] = source->sizey;
	loopy.setSizes(dim);
	tr_map.setSizes(dim);
	
	
	double pix[32];

	
	for(coor[1]=0;coor[1]<source->sizey;coor[1]++) for(coor[0]=0;coor[0]<source->sizex;coor[0]++){
		source->getPixel(coor[0],coor[1],pix);
		tr_map(coor) = pix[1];
	}
	
	unsigned int nb_area;
	LFHPrimitive::DataGrid< unsigned int , 2> areasmap = tr_map.SegementClimbToMax(nb_area);
	
	
	LFHPrimitive::WeightElem< LFHPrimitive::Tuple<double, 6 >,1 > *areasdata = new LFHPrimitive::WeightElem< LFHPrimitive::Tuple<double, 6 >,1 >[nb_area]; 
	unsigned int *damerge = new unsigned int[nb_area]; 
	
	unsigned int i,nb,j,k;
	for(i=0;i<nb_area;i++) {LFHPrimitive::ExOp::toZero(areasdata[i]); damerge[i] = i;} 
	
	
	LFHPrimitive::Tuple<double, 6 > ex;
	

	
//	orderings.setsize(nb_area * nb_area);
	
//	ExOp::toZero(orderings);
	double* max_x = new double[nb_area * nb_area];
	
	

	for(i=0;i<nb_area*nb_area;i++) max_x[i] = LFHPrimitive::ExCo<double>::min();
	
	
	LFHPrimitive::Tuple<LFHPrimitive::Tuple<unsigned int,2>,8 > ncoor;
	
	for(coor[1]=0;coor[1]<source->sizey;coor[1]++) for(coor[0]=0;coor[0]<source->sizex;coor[0]++){
		source->getPixel(coor[0],coor[1],pix);
		if (pix[0] > 0.1f){
			
			ex[0] = coor[0];
			ex[1] = coor[1];
			ex[2] = coor[0] * coor[0];
			ex[3] = coor[1] * coor[1];
			ex[4] = coor[1] * coor[0];
			ex[5] = pix[2];
			areasdata[ areasmap(coor)-1 ] += LFHPrimitive::WeightElem< LFHPrimitive::Tuple<double, 6 >,1 >(ex, pix[0]); 
			ex = areasdata[ areasmap(coor)-1 ].getMean();
			
			nb = areasmap.get_indirectNeightbor(coor, ncoor);
			j = areasmap(coor)-1;
			for(i=0;i<nb;i++){
				k = areasmap(ncoor[i])-1;
				if (j != k){
					source->getPixel(ncoor[i][0],ncoor[i][1],pix+4);
					if (pix[4] > 0.1f){
						if (pix[1] < pix[5]) pix[5] = pix[1];
						if (j < k) k += j * nb_area;
						else k = j + k * nb_area;
						if (max_x[k] < pix[5]) max_x[k] = pix[5];
					}
				}
			}
		}
	}
	
	LFHPrimitive::Vector< LFHPrimitive::KeyElem< double, LFHPrimitive::Tuple<unsigned int, 2> > > orderings;
	
	LFHPrimitive::KeyElem< double, LFHPrimitive::Tuple<unsigned int, 2> > ord_in;
	
	
	
	for(ord_in.d[0]=0;ord_in.d[0]<nb_area;ord_in.d[0]++){
		ex = areasdata[ord_in.d[0]].getMean();
		pix[0] = ex[2] - ex[0] * ex[0]; //vx
		pix[1] = ex[3] - ex[1] * ex[1]; //vy
		pix[2] = ex[4] - ex[0] * ex[1]; //cv
		max_x[ ord_in.d[0] ] = sqrt(pix[0] * pix[1] - pix[2] * pix[2]); // area / nbpts
		
		if (!LFHPrimitive::ExCo<double>::isValid(max_x[ ord_in.d[0] ])) areasdata[ord_in.d[0]].w[0] = 0.0f;
		
		if (areasdata[ord_in.d[0]].w[0] < 1.0f) continue;
	for(ord_in.d[1]=ord_in.d[0]+1;ord_in.d[1]<nb_area;ord_in.d[1]++){
		if (areasdata[ord_in.d[1]].w[0] < 1.0f) continue;
		ord_in.k = max_x[ord_in.d[1]+ord_in.d[0] * nb_area];
		if (ord_in.k != LFHPrimitive::ExCo<double>::min()) {
			orderings.push_back(ord_in);
		}
		}
		
		// computes compactness
		
		}
	
	
//	for(i=0;i<nb_area;i++) {
//		printf("compactness %i: %e on %e\n", i, max_x[i] ,  areasdata[i].w[0]);
//	}

	
	orderings.sort();
	
	double best = 0.0f;
	double current = 0.0f;
	
	LFHPrimitive::WeightElem< LFHPrimitive::Tuple<double, 6 >,1 > *dupldata = new LFHPrimitive::WeightElem< LFHPrimitive::Tuple<double, 6 >,1 >[nb_area]; 
	
	for(j=0;j<nb_area;j++) dupldata[j] = areasdata[j];
	
	k = orderings.size();
	for(i=orderings.size()-1;i!= 0xFFFFFFFF;i--) {
		while( damerge[orderings[i].d[0]] != orderings[i].d[0]  ) orderings[i].d[0] = damerge[orderings[i].d[0]];
		while( damerge[orderings[i].d[1]] != orderings[i].d[1]  ) orderings[i].d[1] = damerge[orderings[i].d[1]];

		if (orderings[i].d[1]  ==  orderings[i].d[0]) continue;
		
		ex = (areasdata[orderings[i].d[0]] + areasdata[orderings[i].d[1]] ).getMean();
		pix[0] = ex[2] - ex[0] * ex[0]; //vx
		pix[1] = ex[3] - ex[1] * ex[1]; //vy
		pix[2] = ex[4] - ex[0] * ex[1]; //cv
		pix[3] = areasdata[orderings[i].d[0]].w[0] + areasdata[orderings[i].d[1]].w[0];
		pix[4] = sqrt(pix[0] * pix[1] - pix[2] * pix[2]);
		current = current - max_x[ orderings[i].d[0] ] - max_x[  orderings[i].d[1] ]  + pix[4];
		
		if (current < best){
			best = current; k = i;
		}
		
		//if ((max_x[ orderings[i].d[0] ] + max_x[  orderings[i].d[1] ] > sqrt(pix[0] * pix[1] - pix[2] * pix[2]) )||(areasdata[orderings[i].d[1]].w[0] <  min_area)||(areasdata[orderings[i].d[0]].w[0] <  min_area)||(3.0f * ex[5]*ex[5] > pix[3]) ) {
		//if (max_x[ orderings[i].d[0] ] + max_x[  orderings[i].d[1] ] > sqrt(pix[0] * pix[1] - pix[2] * pix[2])) {
		//if ((max_x[ orderings[i].d[0] ] + max_x[  orderings[i].d[1] ] > sqrt(pix[0] * pix[1] - pix[2] * pix[2]) )||(areasdata[orderings[i].d[1]].w[0] <  min_area)||(areasdata[orderings[i].d[0]].w[0] <  min_area)||(0.1f * ex[5]*ex[5] > pix[3]) ) {
		//if (max_x[ orderings[i].d[0] ] + max_x[  orderings[i].d[1] ] > sqrt(pix[0] * pix[1] - pix[2] * pix[2])) {
			// a good merge!
		//	printf("merge %i, %i at %e.... newcomp %e -> %e\n", orderings[i].d[0],orderings[i].d[1],orderings[i].k, (max_x[ orderings[i].d[0] ] + max_x[  orderings[i].d[1] ] ) / ( areasdata[orderings[i].d[0]].w[0] + areasdata[orderings[i].d[1]].w[0]), sqrt(pix[0] * pix[1] - pix[2] * pix[2]) / ( areasdata[orderings[i].d[0]].w[0] + areasdata[orderings[i].d[1]].w[0])  );
			
		//	for(j=0;j<nb_area;j++) if (orderings[i].d[1] == damerge[ j ] ) 
				
			damerge[ orderings[i].d[1] ] = orderings[i].d[0];
			max_x[ orderings[i].d[0] ] = pix[4];
			areasdata[orderings[i].d[0]] += areasdata[orderings[i].d[1]];
		//	i=0;
		//}
	}
	
	
	if (k != 0){
		for(j=0;j<nb_area;j++) { areasdata[j] = dupldata[j] ;damerge[ j ] = j;}
	for(i=orderings.size()-1;i >= k;i--) {
		while( damerge[orderings[i].d[0]] != orderings[i].d[0]  ) orderings[i].d[0] = damerge[orderings[i].d[0]];
		while( damerge[orderings[i].d[1]] != orderings[i].d[1]  ) orderings[i].d[1] = damerge[orderings[i].d[1]];
		if (orderings[i].d[1]  ==  orderings[i].d[0]) continue;
		areasdata[orderings[i].d[0]] += areasdata[orderings[i].d[1]];
		damerge[ orderings[i].d[1] ] = orderings[i].d[0];
	}
		for(j=0;j<nb_area;j++) {if (damerge[ j ] == j){
			ex = areasdata[j].getMean();
			pix[0] = ex[2] - ex[0] * ex[0]; //vx
			pix[1] = ex[3] - ex[1] * ex[1]; //vy
			pix[2] = ex[4] - ex[0] * ex[1]; //cv
			max_x[ j ] = sqrt(pix[0] * pix[1] - pix[2] * pix[2]);
		}	}
		
		for(;i!= 0xFFFFFFFF;i--) {
			while( damerge[orderings[i].d[0]] != orderings[i].d[0]  ) orderings[i].d[0] = damerge[orderings[i].d[0]];
			while( damerge[orderings[i].d[1]] != orderings[i].d[1]  ) orderings[i].d[1] = damerge[orderings[i].d[1]];
			
			if (orderings[i].d[1]  ==  orderings[i].d[0]) continue;
			
			ex = (areasdata[orderings[i].d[0]] + areasdata[orderings[i].d[1]] ).getMean();
			pix[0] = ex[2] - ex[0] * ex[0]; //vx
			pix[1] = ex[3] - ex[1] * ex[1]; //vy
			pix[2] = ex[4] - ex[0] * ex[1]; //cv
			pix[3] = areasdata[orderings[i].d[0]].w[0] + areasdata[orderings[i].d[1]].w[0];
			pix[4] = sqrt(pix[0] * pix[1] - pix[2] * pix[2]);
			

			
			if ((max_x[ orderings[i].d[0] ] + max_x[  orderings[i].d[1] ] > pix[4] )||(areasdata[orderings[i].d[1]].w[0] <  min_area)||(areasdata[orderings[i].d[0]].w[0] <  min_area)) {
			//if (max_x[ orderings[i].d[0] ] + max_x[  orderings[i].d[1] ] > sqrt(pix[0] * pix[1] - pix[2] * pix[2])) {
			//if ((max_x[ orderings[i].d[0] ] + max_x[  orderings[i].d[1] ] > sqrt(pix[0] * pix[1] - pix[2] * pix[2]) )||(areasdata[orderings[i].d[1]].w[0] <  min_area)||(areasdata[orderings[i].d[0]].w[0] <  min_area)||(0.1f * ex[5]*ex[5] > pix[3]) ) {
			//if (max_x[ orderings[i].d[0] ] + max_x[  orderings[i].d[1] ] > sqrt(pix[0] * pix[1] - pix[2] * pix[2])) {
			// a good merge!
		//	printf("merge %i, %i at %e.... newcomp %e -> %e\n", orderings[i].d[0],orderings[i].d[1],orderings[i].k, (max_x[ orderings[i].d[0] ] + max_x[  orderings[i].d[1] ] ) / ( areasdata[orderings[i].d[0]].w[0] + areasdata[orderings[i].d[1]].w[0]), sqrt(pix[0] * pix[1] - pix[2] * pix[2]) / ( areasdata[orderings[i].d[0]].w[0] + areasdata[orderings[i].d[1]].w[0])  );
			
			//	for(j=0;j<nb_area;j++) if (orderings[i].d[1] == damerge[ j ] ) 
			
			damerge[ orderings[i].d[1] ] = orderings[i].d[0];
			max_x[ orderings[i].d[0] ] = pix[4];
			areasdata[orderings[i].d[0]] += areasdata[orderings[i].d[1]];
			}
			
			
		}
		
		/*
		for(i=k;i!= 0xFFFFFFFF;i--) {
			while( damerge[orderings[i].d[0]] != orderings[i].d[0]  ) {orderings[i].d[0] = damerge[orderings[i].d[0]]; printf("%i\n", orderings[i].d[0]);}
			while( damerge[orderings[i].d[1]] != orderings[i].d[1]  ) orderings[i].d[1] = damerge[orderings[i].d[1]];
			
			if (orderings[i].d[1]  ==  orderings[i].d[0]) continue;
			
			ex = (areasdata[orderings[i].d[0]] + areasdata[orderings[i].d[1]] ).getMean();
			pix[0] = ex[2] - ex[0] * ex[0]; //vx
			pix[1] = ex[3] - ex[1] * ex[1]; //vy
			pix[2] = ex[4] - ex[0] * ex[1]; //cv
			pix[3] = areasdata[orderings[i].d[0]].w[0] + areasdata[orderings[i].d[1]].w[0];
			pix[4] = sqrt(pix[0] * pix[1] - pix[2] * pix[2]);
			
			
			
		/*	if ((max_x[ orderings[i].d[0] ] + max_x[  orderings[i].d[1] ] > pix[4] )||(areasdata[orderings[i].d[1]].w[0] <  min_area)||(areasdata[orderings[i].d[0]].w[0] <  min_area)) {
				//if (max_x[ orderings[i].d[0] ] + max_x[  orderings[i].d[1] ] > sqrt(pix[0] * pix[1] - pix[2] * pix[2])) {
				//if ((max_x[ orderings[i].d[0] ] + max_x[  orderings[i].d[1] ] > sqrt(pix[0] * pix[1] - pix[2] * pix[2]) )||(areasdata[orderings[i].d[1]].w[0] <  min_area)||(areasdata[orderings[i].d[0]].w[0] <  min_area)||(0.1f * ex[5]*ex[5] > pix[3]) ) {
				//if (max_x[ orderings[i].d[0] ] + max_x[  orderings[i].d[1] ] > sqrt(pix[0] * pix[1] - pix[2] * pix[2])) {
				// a good merge!
			//	printf("merge %i, %i at %e.... newcomp %e -> %e\n", orderings[i].d[0],orderings[i].d[1],orderings[i].k, (max_x[ orderings[i].d[0] ] + max_x[  orderings[i].d[1] ] ) / ( areasdata[orderings[i].d[0]].w[0] + areasdata[orderings[i].d[1]].w[0]), sqrt(pix[0] * pix[1] - pix[2] * pix[2]) / ( areasdata[orderings[i].d[0]].w[0] + areasdata[orderings[i].d[1]].w[0])  );
				
				//	for(j=0;j<nb_area;j++) if (orderings[i].d[1] == damerge[ j ] ) 
				
				damerge[ orderings[i].d[1] ] = orderings[i].d[0];
				max_x[ orderings[i].d[0] ] = pix[4];
				areasdata[orderings[i].d[0]] += areasdata[orderings[i].d[1]];
			}
			
			
		}*/
		
		
	}
	
	
//	printf("\n");
	

	

	
	

	
	for(i=0;i<nb_area;i++) {
		if ((damerge[i] == i)&&( areasdata[i].w[0] > min_area)){
			ex = areasdata[i].getMean();
			cover.push_back(Madstructs::CellPose());
			cover[cover.size()-1].center[0] = ex[0];
			cover[cover.size()-1].center[1] = ex[1];
			cover[cover.size()-1].eccentric[0] = 0.0f;
			cover[cover.size()-1].eccentric[1] = 0.0f;
			coor[0] = (unsigned int) (ex[0] +0.5f); if (coor[0] >= source->sizex) coor[0] = source->sizex-1;
			coor[1] = (unsigned int) (ex[1] +0.5f); if (coor[1] >= source->sizex) coor[1] = source->sizey-1;
			source->getPixel(coor[0],coor[1],pix);
			cover[cover.size()-1].width = pix[1] *2.0f;
		}
	}
	printf("%i/%i out\n",cover.size(),nb_area);
	
	
	
	
	// to render
	/*
	for(j=0;j<nb_area;j++) {
		while( damerge[j] != damerge[damerge[j]] ) damerge[j] = damerge[damerge[j]];
	}
	 for(coor[1]=0;coor[1]<source->sizey;coor[1]++) for(coor[0]=0;coor[0]<source->sizex;coor[0]++){
	 areasmap(coor) = damerge[areasmap(coor)-1] + 1;
	 }
	 LFHPrimitive::TiffFile* tf = new LFHPrimitive::TiffFile("../../../../tmpmini.tif");
	 
	 tf->put(areasmap, (unsigned int)0, (unsigned int)255, true) ;
	 tr_map *= 1000000.0f;
	 tf->put(tr_map, (unsigned int)0, (unsigned int)255, true) ;
	 
	 delete(tf);

	 */
	 // to render
	 
	 
	 
	 
	 
	 
	
	
	delete[](max_x);
	delete[](areasdata);

	delete[](dupldata);
	delete[](damerge);

	/*
	
	LFHPrimitive::Vector< LFHPrimitive::KeyElem< double, LFHPrimitive::Tuple<int,2> > > intensities;
	
	LFHPrimitive::KeyElem< double, LFHPrimitive::Tuple<int,2> > inint;
	
	
	LFHPrimitive::Tuple<unsigned int,2> t_coor;
	
	
	
	for(coor[1]=0;coor[1]<source->sizey;coor[1]++) for(coor[0]=0;coor[0]<source->sizex;coor[0]++){
		
		
		source->getPixel(coor[0],coor[1],pix);
		if (pix[0] > 0.1f){
			inint.d[0] = coor[0];
			inint.d[1] = coor[1];
			inint.k = pix[1];
			intensities.push_back(inint);
		}
	
//		tr_map(coor) = pix[1];
		
//		n_coor = coor;
//		loopy(coor) = coor;
		
//		n_coor[0]--;pix[5] = (n_coor[0] !=0xFFFFFFFF) ? areasmap(n_coor) : pix[1] ; if (pix[5] > pix[1]) {pix[1] = pix[5];  loopy(coor) = n_coor;} n_coor[0]++; 
//		n_coor[1]--;pix[5] = (n_coor[1] !=0xFFFFFFFF) ? areasmap(n_coor) : pix[1] ; if (pix[5] > pix[1]) {pix[1] = pix[5];  loopy(coor) = n_coor;} n_coor[1]++;
//		n_coor[0]++;pix[5] = (n_coor[0] != areasmap.dims[0]) ? areasmap(n_coor) : pix[1] ; if (pix[5] > pix[1]) {pix[1] = pix[5];  loopy(coor) = n_coor;} n_coor[0]--;
//		n_coor[1]++;pix[5] = (n_coor[1] != areasmap.dims[1]) ? areasmap(n_coor) : pix[1] ; if (pix[5] > pix[1]) {pix[1] = pix[5];  loopy(coor) = n_coor;}n_coor[1]--;
		
	}
	
	
	
	
	
	intensities.sort();
	
	
	
	
	printf("%i pix!\n", intensities.size() );
	double circles;
	
	
	unsigned int pixite;
	unsigned int i,j;
	

	
	
	map<unsigned int, LFHPrimitive::WeightElem< LFHPrimitive::Tuple<double, 5 > > > suffi;
	

	
	
	stack<>
	
	for(pixite=intensities.size()-1;pixite != 0xFFFFFFFF;pixite--){

		if (areasmap(coor) == 0) {
			// new segment
			cur_area++;
			
			
		
		}
		
		
		coor = intensities[pixite].d;
		ex[0] = coor[0];
		ex[1] = coor[1];
		ex[2] = coor[0] * coor[0];
		ex[3] = coor[1] * coor[1];
		ex[4] = coor[1] * coor[0];
		
		
		n[4] = 0xFFFFFFFF;
		if (n[0] != 0) {n[4] = n[0];}
		if (n[1] != 0) {n[4] = (n[4] == 0xFFFFFFFF)? n[1] :  (n[4] != n[1]) ? 0 : n[4];}
		if (n[2] != 0) {n[4] = (n[4] == 0xFFFFFFFF)? n[2] :  (n[4] != n[2]) ? 0 : n[4];}
		if (n[3] != 0) {n[4] = (n[4] == 0xFFFFFFFF)? n[3] :  (n[4] != n[3]) ? 0 : n[4];}
		
		//	printf("%i\t%i\t%i\t%i\t%i\n", n[0], n[1], n[2], n[3], n[4]);
		if (n[4] != 0){ // create to join
			
			
			if (n[4] == 0xFFFFFFFF) { 
				// new areas
				loopy(coor) = coor;
				cur_area++;
				areasmap(coor) = cur_area;
				suffi[cur_area] = LFHPrimitive::WeightElem< LFHPrimitive::Tuple<double, 5 > >(ex,1.0f);
			} else {areasmap(coor) = n[4];
				suffi[n[4]] = suffi[n[4]] + LFHPrimitive::WeightElem< LFHPrimitive::Tuple<double, 5 > >(ex,1.0f);
				
				
				if (n[0] != 0) {t_coor[0] = coor[0]-1;t_coor[1] = coor[1]; loopy(coor) = loopy(t_coor); loopy(t_coor) = coor;}
				else if (n[1] != 0) {t_coor[0] = coor[0];t_coor[1] = coor[1]-1; loopy(coor) = loopy(t_coor); loopy(t_coor) = coor;}
				else if (n[2] != 0) {t_coor[0] = coor[0]+1;t_coor[1] = coor[1]; loopy(coor) = loopy(t_coor); loopy(t_coor) = coor;}
				else if (n[3] != 0) {t_coor[0] = coor[0];t_coor[1] = coor[1]+1; loopy(coor) = loopy(t_coor); loopy(t_coor) = coor;}
				
				
			}
			
		}else{ // MERGE AREA!!!
			// check area before merge!
			n[4] = 0xFFFFFFFF;
			if (n[0] != 0) {n[4] = n[0];}
			if (n[1] != 0) {if (n[1] < n[4]) n[4] = n[1];}
			if (n[2] != 0) {if (n[2] < n[4]) n[4] = n[2];}
			if (n[3] != 0) {if (n[3] < n[4]) n[4] = n[3];}
			
			printf("Merge in Area %i: %f pts \n", n[4], suffi[n[4]].w[0]);
			LFHPrimitive::ExOp::show(suffi[n[4]].getMean());
			
			suffi[n[4]] = suffi[n[4]] + LFHPrimitive::WeightElem< LFHPrimitive::Tuple<double, 5 > >(ex,1.0f);
			
			for(i=0;i<4;i++)
				if (n[i] > n[4]){
					if (suffi.end() != suffi.find(n[i])) {
						printf("Area %i: %f pts \n", n[i], suffi[n[i]].w[0]);
						LFHPrimitive::ExOp::show(suffi[n[i]].getMean());
						suffi[n[4]] += suffi[n[i]];
						suffi.erase(n[i]);
						
						switch (i) {
							case 0: t_coor[0] = coor[0]-1;t_coor[1] = coor[1]; break;
							case 1: t_coor[0] = coor[0];t_coor[1] = coor[1]-1; break;
							case 2: t_coor[0] = coor[0]+1;t_coor[1] = coor[1]; break;
							case 3: t_coor[0] = coor[0];t_coor[1] = coor[1]+1; break;
						}
						n_coor = loopy(t_coor);
						while((n_coor[0] != t_coor[0])||(n_coor[1] != t_coor[1])){
							areasmap(n_coor) = n[4];
							n_coor = loopy(n_coor);
						}
						areasmap(n_coor) = n[4];
						
					}
				} 
			
			
			n_coor = coor;
			if (n[0] != 0) {t_coor[0] = coor[0]-1;t_coor[1] = coor[1]; loopy(n_coor) = loopy(t_coor); n_coor = t_coor;}
			if (n[1] != 0) {t_coor[0] = coor[0];t_coor[1] = coor[1]-1; loopy(n_coor) = loopy(t_coor); n_coor = t_coor;}
			if (n[2] != 0) {t_coor[0] = coor[0]+1;t_coor[1] = coor[1]; loopy(n_coor) = loopy(t_coor); n_coor = t_coor;}
			if (n[3] != 0) {t_coor[0] = coor[0];t_coor[1] = coor[1]+1; loopy(n_coor) = loopy(t_coor); n_coor = t_coor;}
			loopy(n_coor) = coor;
			
			
		}
	}	*/
	
	
	
}




void Madstructs::CellCover::findCellCover(Madstructs::Image<double>* source){
	bool found;
	int nbc;
		int i,j;
	int maxcell =32;
	Madstructs::Image<double> label = Madstructs::Image<double>();
	label.sizex = source->sizex*3;
	label.sizey = source->sizey*3;
	double expc=0.0f;
	int x,y;
	double pix[8];
	for(y=0;y<source->sizey;y++){
		for(x=0;x<source->sizex;x++){
			source->getPixel(x,y,pix);
			if (pix[2] >= 0.990f)	expc +=1.0f;
		}
	}
	expc = expc / 1300.0f +0.5f; 
	if (cover.size() == 0) {cover.push_back(Madstructs::CellPose()); nbc=0;}
	else {
		nbc = cover.size()-1;
		label.channels = nbc+1;
		label.allocateBuffer();
		for(j=0;j<cover.size();j++){
			cover[j].center[0] += source->sizex;
			cover[j].center[1] += source->sizey;
		}
	}
	for(;nbc<maxcell;nbc++){
		
		if (nbc> 0){
			cellLabel(source,&label);
			found = findUnclassifCellpt_2(source,&label,cover[nbc].center,&(cover[nbc].width));
		} else found = findUnclassifCellpt_2(source,NULL,cover[0].center,&(cover[nbc].width));
		if (found == false) {
			cover.pop_back();nbc--;
			if (nbc < 0) return;
			break;
		}  //assumes at least 1 cell exists
		if (cover[nbc].width > 30.0f) cover[nbc].width =30.0f;
		if (cover[nbc].width < 10.0f) cover[nbc].width =10.0f;
		cover[nbc].center[0] += source->sizex;
		cover[nbc].center[1] += source->sizey;

		
		//		cover[nbc].eccentric[0] = cover[nbc].width / 25.0f; // eccentricity vector
		//		cover[nbc].eccentric[1] = cover[nbc].width / 25.0f;
				cover[nbc].eccentric[0] = 0.0f; // eccentricity vector
				cover[nbc].eccentric[1] = 0.0f;
		label.channels = nbc+1;
		label.allocateBuffer();
		

		for(i=0;i<20+3*nbc;i++){
		if ((i % 5) == 4) 
			{
				for(j=0;j<=nbc;j++) printf("[%f,%f] %f\t",cover[j].error[0],cover[j].error[1],cover[j].width);
			printf("\n");}
			cellLabel(source,&label);
			cellUpdate3(source,&label, 0.35);
		//	cellUpdate2(source,&label, expc,0.05,0.1f);
		}
		found = false;
		for(j=0;j<=nbc;j++) found |= cover[j].width < 0;
		for(j=0;j<=nbc;j++) found |= (14 >  sqrt(cover[j].width * cover[j].width - 4*cover[j].eccentric[0]*cover[j].eccentric[0] - 4*cover[j].eccentric[1]*cover[j].eccentric[1]));
		if (found){
			for(i=0;i<30+5*nbc;i++){
			/*	if ((i % 10) == 9) 
				{
					for(j=0;j<=nbc;j++) printf("(%f,%f) [%f,%f] %f\t",cover[j].center[0]-source->sizex,cover[j].center[1]-source->sizey,cover[j].error[0],cover[j].error[1],cover[j].width);
				printf("\n");}*/
				cellLabel(source,&label);
				cellUpdate3(source,&label, 0.35);
	//			cellUpdate2(source,&label, expc,0.05,0.2f);
			}
		found = false;
			for(j=0;j<=nbc;j++) found |= cover[j].width < 0;

		for(j=0;j<=nbc;j++) found |= (6 >  sqrt(cover[j].width * cover[j].width - 4 *cover[j].eccentric[0]*cover[j].eccentric[0] - 4 *cover[j].eccentric[1]*cover[j].eccentric[1]));
		if (found) {
			for(j=0;j<cover.size();j++){
				if  ((cover[j].width < 0)||(10 >  sqrt(cover[j].width*cover[j].width - 4*cover[j].eccentric[0]*cover[j].eccentric[0] - 4*cover[j].eccentric[1]*cover[j].eccentric[1]))){
					cover[j] = cover[cover.size()-1];
					cover.pop_back();
					j--;
					nbc--;
				}
			}
		}		
		}
		if (nbc == maxcell) break;
		if (found) break;
		cover.push_back(Madstructs::CellPose());
		}
	if ((nbc <= maxcell)&&(nbc>=0)){
		/*
		for(j=0;j<cover.size();j++){
				cover[j].eccentric[0] = cover[j].width / 25.0f; // eccentricity vector
				cover[j].eccentric[1] = cover[j].width / 25.0f;
		}*/
		
		if (nbc == maxcell) label.channels = maxcell; 
		else label.channels = nbc+1;
		label.allocateBuffer();
		for(i=0;i<30+5*nbc;i++){
	/*		if ((i % 10) == 0) 
			{
				for(j=0;j<=nbc;j++) printf("(%f,%f) <%f,%f> [%f,%f] %f\t",cover[j].center[0]-source->sizex,cover[j].center[1]-source->sizey,cover[j].eccentric[0],cover[j].eccentric[1],cover[j].error[0],cover[j].error[1],cover[j].width);
				printf("\n");
			}*/
			cellLabel(source,&label);
			cellUpdate3(source,&label, 0.35, false);
	//		cellUpdate2(source,&label, expc,0.05,0.5f);
		}
	}
	for(j=0;j<cover.size();j++){
		cover[j].center[0] -= source->sizex;
		cover[j].center[1] -= source->sizey;
	}
	printf("%i cells found\n",nbc+1);fflush(stdout);
}

void colorfunction(double* in, double* out, int nbchan){
	
	if (nbchan < 5){
		if (nbchan == 4) out[0] = out[1] = out[2] = in[3];
		else out[0] = out[1] = out[2] = 0.0f;
		if (nbchan > 0) out[0] += in[0] * 0.9f;
		if (nbchan > 1) out[1] += in[1] * 0.75f;
		if (nbchan > 2) out[2] += in[2] * 1.0f;
	}else{
	out[0] = in[0] * 0.9f + in[3] * 1.0f;
	out[1] = in[1] * 0.75f + in[3] * 1.0f + in[4] * 0.75f;
	out[2] = in[2] * 1.0f + in[3] * 1.0f + in[4];
		if (nbchan < 8){
			if (nbchan > 5) {out[0] += in[5] * 0.9f; out[2] += in[5] * 1.0f;} 
			if (nbchan > 6) {out[1] += in[6] * 0.75f; out[0] += in[6] * 0.9f;} 
		}else{
			out[0] += in[5] * 0.9f + in[6] * 0.9f;
			out[1] += in[7] * 0.375f + in[6] * 0.75f;
			out[2] += in[7] * 0.5f + in[5] * 1.0f;
			if (nbchan > 8) {out[1] += in[8]*0.375f; out[0] += in[8]*0.45f;}
			if (nbchan > 9) {out[2] += in[9]*0.5f; out[0] += in[9]*0.45f;}
			if (nbchan > 10) {out[0] += in[10]*0.45f; out[1] += in[10]*0.375f; out[2] += in[10]*0.5f;}
		}
	}
}

void Madstructs::CellCover::addframe_errormap(vector<Madstructs::Image<unsigned char>*> &_out, Madstructs::Image<double> *source){
	int i = _out.size();
	_out.push_back(new Madstructs::Image<unsigned char>());
	_out[i]->sizex = source->sizex;
	_out[i]->sizey = source->sizey;
	_out[i]->channels = 3;
	_out[i]->allocateBuffer();
	int x,y;
	double pix[32];
	double pox[32];
	
	for(y=0;y<source->sizey;y++){
		for(x=0;x<source->sizex;x++){
			source->getPixel(x,y,pix);
			pox[0] = pix[2] / 100.0f;
			pox[1] = (pix[2] - pix[3]) / 100.0f;
			pox[2] = pix[3] / 100.0f;
			_out[i]->setPixel(x,y,pox);
		}}}

void Madstructs::CellCover::addframe_distancemap(vector<Madstructs::Image<unsigned char>*> &_out, Madstructs::Image<double> *source){
	int i = _out.size();
	_out.push_back(new Madstructs::Image<unsigned char>());
	_out[i]->sizex = source->sizex;
	_out[i]->sizey = source->sizey;
	_out[i]->channels = 3;
	_out[i]->allocateBuffer();
	int x,y;
	double pix[32];
	double pox[32];
	
	for(y=0;y<source->sizey;y++){
		for(x=0;x<source->sizex;x++){
			source->getPixel(x,y,pix);
			pox[0] = pix[3] / 10.0f;
			pox[1] = pix[0];
			pox[2] = pix[3] / 10.0f;
			_out[i]->setPixel(x,y,pox);
		}}}

void Madstructs::CellCover::addframe(vector<Madstructs::Image<unsigned char>*> &_out, Madstructs::Image<double> *label){
	int i = _out.size();
	_out.push_back(new Madstructs::Image<unsigned char>());
	_out[i]->sizex = label->sizex;
	_out[i]->sizey = label->sizey;
	_out[i]->channels = 3;
	_out[i]->allocateBuffer();
	int x,y,z;
	double pix[32];
	double pox[32];
	
	for(y=0;y<label->sizey;y++){
		for(x=0;x<label->sizex;x++){
			label->getPixel(x,y,pix);
			colorfunction(pix,pox, label->channels);
			_out[i]->setPixel(x,y,pox);
		}}
	for(z=0;z<label->channels;z++){
		x = (int)(cover[z].center[0]);
		y = (int)(cover[z].center[1]);
		if ((x >= 0)&&(x<label->sizex-1)&&(y >= 0)&&(y<label->sizey-1)){
			_out[i]->getPixel(x,y,pox);
			pox[0] = 1.0f - pox[0];
			pox[1] = 1.0f - pox[1];
			pox[2] = 1.0f - pox[2];
			_out[i]->setPixel(x,y,pox);
			_out[i]->getPixel(x+1,y,pox);
			pox[0] = 1.0f - pox[0];
			pox[1] = 1.0f - pox[1];
			pox[2] = 1.0f - pox[2];
			_out[i]->setPixel(x+1,y,pox);
			_out[i]->getPixel(x,y+1,pox);
			pox[0] = 1.0f - pox[0];
			pox[1] = 1.0f - pox[1];
			pox[2] = 1.0f - pox[2];
			_out[i]->setPixel(x,y+1,pox);
			_out[i]->getPixel(x+1,y+1,pox);
			pox[0] = 1.0f - pox[0];
			pox[1] = 1.0f - pox[1];
			pox[2] = 1.0f - pox[2];
			_out[i]->setPixel(x+1,y+1,pox);
		}
		x = (int)(cover[z].center[0] - cover[z].width *0.5f);
		y = (int)(cover[z].center[1]);
		if ((x >= 0)&&(x<label->sizex)&&(y >= 0)&&(y<label->sizey-1)){
			_out[i]->getPixel(x,y,pox);
			pox[0] = 1.0f - pox[0];
			pox[1] = 1.0f - pox[1];
			pox[2] = 1.0f - pox[2];
			_out[i]->setPixel(x,y,pox);
			_out[i]->getPixel(x,y+1,pox);
			pox[0] = 1.0f - pox[0];
			pox[1] = 1.0f - pox[1];
			pox[2] = 1.0f - pox[2];
			_out[i]->setPixel(x,y+1,pox);
		}
		x = (int)(cover[z].center[0] + cover[z].width *0.5f);
		y = (int)(cover[z].center[1]);
		if ((x >= 0)&&(x<label->sizex)&&(y >= 0)&&(y<label->sizey-1)){
			_out[i]->getPixel(x,y,pox);
			pox[0] = 1.0f - pox[0];
			pox[1] = 1.0f - pox[1];
			pox[2] = 1.0f - pox[2];
			_out[i]->setPixel(x,y,pox);
			_out[i]->getPixel(x,y+1,pox);
			pox[0] = 1.0f - pox[0];
			pox[1] = 1.0f - pox[1];
			pox[2] = 1.0f - pox[2];
			_out[i]->setPixel(x,y+1,pox);
		}
		x = (int)(cover[z].center[0]);
		y = (int)(cover[z].center[1]+ cover[z].width *0.5f);
		if ((x >= 0)&&(x<label->sizex-1)&&(y >= 0)&&(y<label->sizey)){
			_out[i]->getPixel(x,y,pox);
			pox[0] = 1.0f - pox[0];
			pox[1] = 1.0f - pox[1];
			pox[2] = 1.0f - pox[2];
			_out[i]->setPixel(x,y,pox);
			_out[i]->getPixel(x+1,y,pox);
			pox[0] = 1.0f - pox[0];
			pox[1] = 1.0f - pox[1];
			pox[2] = 1.0f - pox[2];
			_out[i]->setPixel(x+1,y,pox);
		}
		x = (int)(cover[z].center[0]);
		y = (int)(cover[z].center[1]- cover[z].width *0.5f);
		if ((x >= 0)&&(x<label->sizex-1)&&(y >= 0)&&(y<label->sizey)){
			_out[i]->getPixel(x,y,pox);
			pox[0] = 1.0f - pox[0];
			pox[1] = 1.0f - pox[1];
			pox[2] = 1.0f - pox[2];
			_out[i]->setPixel(x,y,pox);
			_out[i]->getPixel(x+1,y,pox);
			pox[0] = 1.0f - pox[0];
			pox[1] = 1.0f - pox[1];
			pox[2] = 1.0f - pox[2];
			_out[i]->setPixel(x+1,y,pox);
		}
	}
}



// does not assume the cover is empty
void Madstructs::CellCover::findCellCover_2(Madstructs::Image<double>* source, const LFHPrimitive::GaussianDistribution<1>& prbg, const LFHPrimitive::GaussianDistribution<1>& prcell,bool movie){
	bool found;
	int nbc;
	int i,j;
	int maxcell =31;
	Madstructs::Image<double> label = Madstructs::Image<double>();
	label.sizex = source->sizex;
	label.sizey = source->sizey;
	double expc=0.0f;
	int x,y;
	LFHPrimitive::Tuple<unsigned int,2> coor;
	double pix[8];
	double pox[32];
	vector<Madstructs::Image<unsigned char>*> show;
	bool firststep =true;
	LFHPrimitive::GaussianDistribution<1> pixdist[32];
	for(y=0;y<source->sizey;y++){
		for(x=0;x<source->sizex;x++){
			source->getPixel(x,y,pix);
			if (pix[2] >= 0.990f)	expc +=1.0f;
		}
	}
	expc = expc / 1300.0f +0.5f; 
	if (cover.size() == 0) {cover.push_back(Madstructs::CellPose()); nbc=0;pixdist[0] = prcell;}
	else {
		nbc = cover.size()-1;
		label.channels = nbc+1;
		label.allocateBuffer();
		for(j=0;j<=nbc;j++) {
		pixdist[j] = prcell;
		cover[j].eccentric[0] = 0.0f; 
		cover[j].eccentric[1] = 0.0f; 
			

			
			
		}
		for(i=0;i<10+3*nbc;i++){
			cellCompleteLabel(source,&label,pixdist); if (movie) addframe(show,&label); 
			cellIntUpdate(source,&label, pixdist);
		}
	}
	
	for(;nbc<maxcell;nbc++){
		printf("addcell!\n");

		if (nbc> 0){
			

			
			pixdist[nbc] = prcell;
			cellCompleteLabel(source,&label,pixdist);
			if (firststep == false)	found = findUnclassifCellpt_2(source,&label,cover[nbc].center,&(cover[nbc].width));
			else{ found = true;firststep = false;}
		} else found = findUnclassifCellpt_2(source,NULL,cover[0].center,&(cover[nbc].width));
		if (found == false) {
			cover.pop_back();nbc--;
			if (nbc < 0) return;
			break;
		}  //assumes at least 1 cell exists
		if (cover[nbc].width > 30.0f) cover[nbc].width =30.0f;
		if (cover[nbc].width < 10.0f) cover[nbc].width =10.0f;
	//	cover[nbc].center[0] += source->sizex;
	//	cover[nbc].center[1] += source->sizey;
		
		for(j=0;j<=nbc;j++) {
			cover[j].width *= 0.25f;
			cover[j].eccentric[0] = 0.0f;
			cover[j].eccentric[1] = 0.0f;
		}
		//		cover[nbc].eccentric[0] = cover[nbc].width / 25.0f; // eccentricity vector
		//		cover[nbc].eccentric[1] = cover[nbc].width / 25.0f;
		cover[nbc].eccentric[0] = 0.0f; // eccentricity vector
		cover[nbc].eccentric[1] = 0.0f;
		label.channels = nbc+1;
		label.allocateBuffer();
		
		
		for(i=0;i<20+3*nbc;i++){
//			if ((i % 5) != 14) {	for(j=0;j<=nbc;j++) printf(" [%f,%f] %f\t",cover[j].eccentric[0],cover[j].eccentric[1],cover[j].width);	printf("\n");}
			cellCompleteLabel(source,&label,pixdist); 
			cellUpdateEllipse_EM_steps(source,&label,false);
			cellCompleteLabel(source,&label,pixdist); 
			cellIntUpdate(source,&label, pixdist);
			if (movie) addframe(show,&label);
			
			//	cellUpdate2(source,&label, expc,0.05,0.1f);
		}
		

		found = false;
		for(j=0;j<=nbc;j++) found |= cover[j].width < 0;
		for(j=0;j<=nbc;j++) found |= (3 >  sqrt(cover[j].width * cover[j].width - 4*cover[j].eccentric[0]*cover[j].eccentric[0] - 4*cover[j].eccentric[1]*cover[j].eccentric[1]));
		if (found){
			for(i=0;i<30+5*nbc;i++){
				if ((i % 10) != 9) {
				 for(j=0;j<=nbc;j++) printf("(%f,%f) [%f,%f] %f\t",cover[j].center[0],cover[j].center[1],cover[j].eccentric[0],cover[j].eccentric[1],cover[j].width);
				 printf("\n");}
				cellCompleteLabel(source,&label,pixdist); 

				
				cellUpdateEllipse_EM_steps(source,&label,false);
				cellCompleteLabel(source,&label,pixdist); 
				cellIntUpdate(source,&label, pixdist);
				if (movie) addframe(show,&label);

				//			cellUpdate2(source,&label, expc,0.05,0.2f);
			}
			
			found = false;
			for(j=0;j<=nbc;j++) found |= cover[j].width < 0;
			
			for(j=0;j<=nbc;j++) found |= (3 >  cover[j].width);
			if (found) {
				for(j=0;j<cover.size();j++){
					if  (cover[j].width < 3){
						cover[j] = cover[cover.size()-1];
						pixdist[j] = pixdist[cover.size()-1];
						cover.pop_back();
						j--;
						nbc--;
						
					}
				}
			}		
		}
		break;
		if (nbc == maxcell) break;
		if (found) break;
		cover.push_back(Madstructs::CellPose());
	}
	// Clump Cutted!
	
	
	if ((nbc <= maxcell)&&(nbc>=0)){
		if (nbc == maxcell) label.channels = maxcell; 
		else label.channels = nbc+1;
		label.allocateBuffer();
		cellCompleteLabel(source,&label,pixdist); if (movie) addframe(show,&label);
		coor[0] = label.sizex;
		coor[1] = label.sizey;

		
		LFHPrimitive::DataGrid< double , 2> distmap; 
		LFHPrimitive::DataGrid< double , 2> transit; 
		
		
		switch(nbc+1){
			case 0:{//:
			}break;//:
			case 1:{//:
				LFHPrimitive::Tuple<double, 2> in_pix;
				LFHPrimitive::DataGrid< LFHPrimitive::Tuple<double, 2>,2> poste; poste.setSizes(coor);
				LFHPrimitive::DataGrid< LFHPrimitive::Tuple<double, 2>,2>::KeyIterator ite = LFHPrimitive::DataGrid< LFHPrimitive::Tuple<double, 2> ,2>::KeyIterator(poste);
				double* area = new double[nbc +1];
				coor[0] = nbc +1; coor[1] = nbc +1; transit.setSizes(coor);
				
				
				coor[0] = 0;
				area[0] = label.sizex * label.sizey;
				for(coor[1]=1;coor[1]<=nbc;coor[1]++){
					area[coor[1]] = cover[coor[1]-1].width * cover[coor[1]-1].width * M_PI * 0.25f;
					area[0] -= area[coor[1]];
					printf("%f\t", area[coor[1]]);
				}
				printf("%f\n", area[0]);
				
				pix[0] = 1.0f;
				for(coor[1]=1;coor[1]<=nbc;coor[1]++){
					pix[1] = cover[coor[1]-1].width *  M_PI*0.25f ;
					pix[1] /= area[0];
					transit(coor) = pix[1];
					pix[0] -= pix[1];
				}
				coor[1] = 0;
				transit(coor) = pix[0];
				
				for(coor[1]=1;coor[1]<=nbc;coor[1]++){
					coor[0] = 0;
					pix[0] = 1.0f / (1.0f + cover[coor[1]-1].width);
					transit(coor) = pix[0];
					for(coor[0]=1;coor[0]<=nbc;coor[0]++){
						if (coor[0] != coor[1]) transit(coor) = 0.0f;
						else transit(coor) = 1.0f - pix[0];
					}
				}
				
				
				if (ite.first()) do{
					source->getPixel(ite()[0],ite()[1],pix);
					label.getPixel(ite()[0],ite()[1],pox);
					in_pix[0] = 1.0f - pix[0];
					for(j=0;j<cover.size();j++) in_pix[j+1] = pix[0] * pox[j];
					poste(ite()) = in_pix;
				}while (ite.next());
				distmap.ExpectedDistanceToOther(poste,transit);
				
				
				
				
				
				delete[](area);
			}break;//:
			case 2:{//:
			}break;//:
			case 3:{//:
			}break;//:
			case 4:{//:
			}break;//:
			case 5:{//:
				LFHPrimitive::Tuple<double, 6> in_pix;
				LFHPrimitive::DataGrid< LFHPrimitive::Tuple<double, 6>,2> poste; poste.setSizes(coor);
				LFHPrimitive::DataGrid< LFHPrimitive::Tuple<double, 6>,2>::KeyIterator ite = LFHPrimitive::DataGrid< LFHPrimitive::Tuple<double, 6> ,2>::KeyIterator(poste);
				double* area = new double[nbc +1];
				coor[0] = nbc +1; coor[1] = nbc +1; transit.setSizes(coor);
				
				
				coor[0] = 0;
				area[0] = label.sizex * label.sizey;
				for(coor[1]=1;coor[1]<=nbc;coor[1]++){
					area[coor[1]] = cover[coor[1]-1].width * cover[coor[1]-1].width * M_PI * 0.25f;
					area[0] -= area[coor[1]];
				printf("%f\t%f\t", area[coor[1]], cover[coor[1]-1].width);
				}
				printf("%f\n", area[0]);
				
				pix[0] = 1.0f;
				coor[1] = 0;
				for(coor[0]=1;coor[0]<=nbc;coor[0]++){
					pix[1] = cover[coor[0]-1].width *  M_PI*  0.25f;
					pix[1] /= area[0];
					transit(coor) = pix[1];
					pix[0] -= pix[1];
				}
				coor[0] = 0;
				transit(coor) = pix[0];
				
				for(coor[1]=1;coor[1]<=nbc;coor[1]++){
					coor[0] = 0;
					pix[0] = 1.0f / (1.0f + cover[coor[1]-1].width);
					transit(coor) = pix[0];
					for(coor[0]=1;coor[0]<=nbc;coor[0]++){
						if (coor[0] != coor[1]) transit(coor) = 0.0f;
						else transit(coor) = 1.0f - pix[0];
					}
				}
				
				transit.show(stdout);
				
				if (ite.first()) do{
					source->getPixel(ite()[0],ite()[1],pix);
					label.getPixel(ite()[0],ite()[1],pox);
					in_pix[0] = 1.0f - pix[0];
					for(j=0;j<cover.size();j++) in_pix[j+1] = pix[0] * pox[j];
					poste(ite()) = in_pix;
				}while (ite.next());
				distmap.ExpectedDistanceToOther(poste,transit); 
				
				
				
				
				
				delete[](area);
			}break;//:
			case 6:{//:
			}break;//:
			case 7:{//:
			}break;//:
			case 8:{//:
			}break;//:
			case 9:{//:
			}break;//:
		}
		
		LFHPrimitive::DataGrid<double,2>::KeyIterator ite = LFHPrimitive::DataGrid< double ,2>::KeyIterator(distmap);
		if (ite.first()) do{
			source->getPixel(ite()[0],ite()[1],pix);
			pix[3] = distmap(ite());
			source->setPixel(ite()[0],ite()[1],pix);
		}while (ite.next());
		
		addframe_distancemap(show,source); 
		
		
		
	}

printf("%i cells found\n",nbc+1);fflush(stdout);
	if (movie) {Madstructs::Image<unsigned char>::SaveTiffImage(show,"../../../../assign.tif"); exit(2);}

}

// does not assume the cover is empty
void Madstructs::CellCover::findCellCover_hiddenmap(Madstructs::Image<double>* source, const LFHPrimitive::GaussianDistribution<1>& prbg, const LFHPrimitive::GaussianDistribution<1>& prcell,bool movie, vector<Madstructs::Image<float>* > *hidden_map, bool noem){
	bool found;
	int nbc;
	int i,j;
	int maxcell =31;
	Madstructs::Image<double> label = Madstructs::Image<double>();
	label.sizex = source->sizex;
	label.sizey = source->sizey;
	double expc=0.0f;
	int x,y;
	LFHPrimitive::Tuple<unsigned int,2> coor;
	double pix[8];
	double pox[32];
	vector<Madstructs::Image<unsigned char>*> show;
	bool firststep =true;
	LFHPrimitive::GaussianDistribution<1> pixdist[32];
	for(y=0;y<source->sizey;y++){
		for(x=0;x<source->sizex;x++){
			source->getPixel(x,y,pix);
			if (pix[2] >= 0.990f)	expc +=1.0f;
		}
	}
	expc = expc / 1300.0f +0.5f; 
	if (cover.size() == 0) {cover.push_back(Madstructs::CellPose()); nbc=0;pixdist[0] = prcell;}
	else {
		nbc = cover.size()-1;
		label.channels = nbc+1;
		label.allocateBuffer();
		for(j=0;j<=nbc;j++) {
			pixdist[j] = prcell;
			cover[j].eccentric[0] = 0.0f; 
			cover[j].eccentric[1] = 0.0f; 
			
			
			
			
		}
		for(i=0;i<10+3*nbc;i++){
			cellCompleteLabel(source,&label,pixdist); if (movie) addframe(show,&label); 
			cellIntUpdate(source,&label, pixdist);
		}
	}
	if (!noem){
	
	for(;nbc<maxcell;nbc++){
	//	printf("addcell!\n");
		
		if (nbc> 0){
			
			
			
			pixdist[nbc] = prcell;
			cellCompleteLabel(source,&label,pixdist);
			if (firststep == false)	found = findUnclassifCellpt_2(source,&label,cover[nbc].center,&(cover[nbc].width));
			else{ found = true;firststep = false;}
		} else found = findUnclassifCellpt_2(source,NULL,cover[0].center,&(cover[nbc].width));
		if (found == false) {
			cover.pop_back();nbc--;
			if (nbc < 0) return;
			break;
		}  //assumes at least 1 cell exists
		if (cover[nbc].width > 30.0f) cover[nbc].width =30.0f;
		if (cover[nbc].width < 10.0f) cover[nbc].width =10.0f;
		//	cover[nbc].center[0] += source->sizex;
		//	cover[nbc].center[1] += source->sizey;
		
		for(j=0;j<=nbc;j++) {
			cover[j].width *= 0.25f;
			cover[j].eccentric[0] = 0.0f;
			cover[j].eccentric[1] = 0.0f;
		}
		//		cover[nbc].eccentric[0] = cover[nbc].width / 25.0f; // eccentricity vector
		//		cover[nbc].eccentric[1] = cover[nbc].width / 25.0f;
		cover[nbc].eccentric[0] = 0.0f; // eccentricity vector
		cover[nbc].eccentric[1] = 0.0f;
		label.channels = nbc+1;
		label.allocateBuffer();
		
		
		for(i=0;i<20+3*nbc;i++){
			//			if ((i % 5) != 14) {	for(j=0;j<=nbc;j++) printf(" [%f,%f] %f\t",cover[j].eccentric[0],cover[j].eccentric[1],cover[j].width);	printf("\n");}
			cellCompleteLabel(source,&label,pixdist); 
			cellUpdateEllipse_EM_steps(source,&label,false);
			cellCompleteLabel(source,&label,pixdist); 
			cellIntUpdate(source,&label, pixdist);
			if (movie) addframe(show,&label);
			
			//	cellUpdate2(source,&label, expc,0.05,0.1f);
		}
		
		
		found = false;
		for(j=0;j<=nbc;j++) found |= cover[j].width < 0;
		for(j=0;j<=nbc;j++) found |= (3 >  sqrt(cover[j].width * cover[j].width - 4*cover[j].eccentric[0]*cover[j].eccentric[0] - 4*cover[j].eccentric[1]*cover[j].eccentric[1]));
		if (found){
			for(i=0;i<30+5*nbc;i++){
				if ((i % 10) != 9) {
	//				for(j=0;j<=nbc;j++) printf("(%f,%f) [%f,%f] %f\t",cover[j].center[0],cover[j].center[1],cover[j].eccentric[0],cover[j].eccentric[1],cover[j].width);
				printf("\n");}
				cellCompleteLabel(source,&label,pixdist); 
				
				
				cellUpdateEllipse_EM_steps(source,&label,false);
				cellCompleteLabel(source,&label,pixdist); 
				cellIntUpdate(source,&label, pixdist);
				if (movie) addframe(show,&label);
				
				//			cellUpdate2(source,&label, expc,0.05,0.2f);
			}
			
			found = false;
			for(j=0;j<=nbc;j++) found |= cover[j].width < 0;
			
			for(j=0;j<=nbc;j++) found |= (3 >  cover[j].width);
			if (found) {
				for(j=0;j<cover.size();j++){
					if  (cover[j].width < 3){
						cover[j] = cover[cover.size()-1];
						pixdist[j] = pixdist[cover.size()-1];
						cover.pop_back();
						j--;
						nbc--;
						
					}
				}
			}		
		}
		break;
		if (nbc == maxcell) break;
		if (found) break;
		cover.push_back(Madstructs::CellPose());
	}
	// Clump Cutted!
	}
	
	if ((nbc <= maxcell)&&(nbc>=0)){

		
		
		if (nbc == maxcell) label.channels = maxcell; 
		else label.channels = nbc+1;
		label.allocateBuffer();
		cellCompleteLabel(source,&label,pixdist); 

		cellEllipseFit(source,&label);
		
		if (!(*this).isValid()){
			(*this).cover.clear();
			(*this).findCellCoverHeuristic(source,0.25f,NULL);
			
			if (nbc == maxcell) label.channels = maxcell; 
			else label.channels = nbc+1;
			label.allocateBuffer();
			cellCompleteLabel(source,&label,pixdist);
			if (cover.size() == 0) return;
		}
		
		if (hidden_map){
		
		Madstructs::Image<float>* new_map = new Madstructs::Image<float>();
		new_map->sizex = source->sizex;
		new_map->sizey = source->sizey;
		new_map->channels = label.channels + 1;
		new_map->allocateBuffer();
		
		
		for(coor[1]=0;coor[1]<source->sizey;coor[1]++) for(coor[0]=0;coor[0]<source->sizex;coor[0]++){
			label.getPixel(coor[0], coor[1], pox);
			source->getPixel(coor[0], coor[1], pix);
			for(j = label.channels; j> 0 ;j--) pox[j] = pox[j-1] * pix[0];
			pox[0] = 1.0f - pix[0];
			new_map->setPixel(coor[0], coor[1], pox);
		}
		
			(*hidden_map).push_back(new_map);
			
		}
		if (movie) addframe_distancemap(show,source); 
		
		
		
	}
	
	printf("%i cells found\n",nbc+1);fflush(stdout);
	if (movie) {
		Madstructs::Image<unsigned char>::SaveTiffImage(show,"../../../../assign.tif");
	}
	
}

// does not assume the cover is empty
void Madstructs::CellCover::findCellCover_hiddenmap2(Madstructs::Image<double>* source,bool movie, vector<Madstructs::Image<float>* > *hidden_map, bool noem){
	bool found;
	int nbc;
	int i,j;
	int maxcell =31;
	Madstructs::Image<double> label = Madstructs::Image<double>();
	label.sizex = source->sizex;
	label.sizey = source->sizey;
	double expc=0.0f;
	int x,y;
	LFHPrimitive::Tuple<unsigned int,2> coor;
	double pix[8];
	double pox[32];
	vector<Madstructs::Image<unsigned char>*> show;
	bool firststep =true;
	LFHPrimitive::GaussianDistribution<1> pixdist[32];
	
	LFHPrimitive::GaussianDistribution<1> prcell;
	
	LFHPrimitive::Tuple<double, 1> dapix;
	
	
	

	// initial distribution
	
	
	
	prcell.EMinit();
	for(y=0;y<source->sizey;y++){
		for(x=0;x<source->sizex;x++){
			source->getPixel(x,y,pix);
			dapix[0] = pix[1];
			prcell.EMregist(dapix, pix[0]);
			if (pix[2] >= 0.990f)	expc +=1.0f;
		}
	}
	prcell.EMfinit(); 
	expc = expc / 1300.0f +0.5f; 
	if (cover.size() == 0) {cover.push_back(Madstructs::CellPose()); nbc=0;pixdist[0] = prcell;}
	else {
		nbc = cover.size()-1;
		label.channels = nbc+1;
		label.allocateBuffer();
		for(j=0;j<=nbc;j++) {
			pixdist[j] = prcell;
			cover[j].eccentric[0] = 0.0f; 
			cover[j].eccentric[1] = 0.0f; 
			
			
			
			
		}
		printf("ahah\n");
		for(i=0;i<10+3*nbc;i++){
			cellCompleteLabel(source,&label,pixdist); if (movie) addframe(show,&label); 
			cellIntUpdate(source,&label, pixdist);
		}
	}
	if (!noem){
		
		for(;nbc<maxcell;nbc++){
			//	printf("addcell!\n");
			
			if (nbc> 0){
				
				
				
				pixdist[nbc] = prcell;
				cellCompleteLabel(source,&label,pixdist);
				if (firststep == false)	found = findUnclassifCellpt_2(source,&label,cover[nbc].center,&(cover[nbc].width));
				else{ found = true;firststep = false;}
			} else found = findUnclassifCellpt_2(source,NULL,cover[0].center,&(cover[nbc].width));
			if (found == false) {
				cover.pop_back();nbc--;
				if (nbc < 0) return;
				break;
			}  //assumes at least 1 cell exists
			if (cover[nbc].width > 30.0f) cover[nbc].width =30.0f;
			if (cover[nbc].width < 10.0f) cover[nbc].width =10.0f;
			//	cover[nbc].center[0] += source->sizex;
			//	cover[nbc].center[1] += source->sizey;
			
			for(j=0;j<=nbc;j++) {
				cover[j].width *= 0.25f;
				cover[j].eccentric[0] = 0.0f;
				cover[j].eccentric[1] = 0.0f;
			}
			//		cover[nbc].eccentric[0] = cover[nbc].width / 25.0f; // eccentricity vector
			//		cover[nbc].eccentric[1] = cover[nbc].width / 25.0f;
			cover[nbc].eccentric[0] = 0.0f; // eccentricity vector
			cover[nbc].eccentric[1] = 0.0f;
			label.channels = nbc+1;
			label.allocateBuffer();
			
			
			for(i=0;i<20+3*nbc;i++){
				//			if ((i % 5) != 14) {	for(j=0;j<=nbc;j++) printf(" [%f,%f] %f\t",cover[j].eccentric[0],cover[j].eccentric[1],cover[j].width);	printf("\n");}
				cellCompleteLabel(source,&label,pixdist); 
				cellUpdateEllipse_EM_steps(source,&label,false);
				cellCompleteLabel(source,&label,pixdist); 
				cellIntUpdate(source,&label, pixdist);
				if (movie) addframe(show,&label);
				
				//	cellUpdate2(source,&label, expc,0.05,0.1f);
			}
			
			
			found = false;
			for(j=0;j<=nbc;j++) found |= cover[j].width < 0;
			for(j=0;j<=nbc;j++) found |= (3 >  sqrt(cover[j].width * cover[j].width - 4*cover[j].eccentric[0]*cover[j].eccentric[0] - 4*cover[j].eccentric[1]*cover[j].eccentric[1]));
			if (found){
				for(i=0;i<30+5*nbc;i++){
					if ((i % 10) != 9) {
						//				for(j=0;j<=nbc;j++) printf("(%f,%f) [%f,%f] %f\t",cover[j].center[0],cover[j].center[1],cover[j].eccentric[0],cover[j].eccentric[1],cover[j].width);
					printf("\n");}
					cellCompleteLabel(source,&label,pixdist); 
					
					
					cellUpdateEllipse_EM_steps(source,&label,false);
					cellCompleteLabel(source,&label,pixdist); 
					cellIntUpdate(source,&label, pixdist);
					if (movie) addframe(show,&label);
					
					//			cellUpdate2(source,&label, expc,0.05,0.2f);
				}
				
				found = false;
				for(j=0;j<=nbc;j++) found |= cover[j].width < 0;
				
				for(j=0;j<=nbc;j++) found |= (3 >  cover[j].width);
				if (found) {
					for(j=0;j<cover.size();j++){
						if  (cover[j].width < 3){
							cover[j] = cover[cover.size()-1];
							pixdist[j] = pixdist[cover.size()-1];
							cover.pop_back();
							j--;
							nbc--;
							
						}
					}
				}		
			}
			break;
			if (nbc == maxcell) break;
			if (found) break;
			cover.push_back(Madstructs::CellPose());
		}
		// Clump Cutted!
	}
	
	printf("hoho\n");
	if ((nbc <= maxcell)&&(nbc>=0)){
		
		
		
		if (nbc == maxcell) label.channels = maxcell; 
		else label.channels = nbc+1;
		label.allocateBuffer();
		cellCompleteLabel(source,&label,pixdist); 
		
		cellEllipseFit(source,&label); 
		
		if (!(*this).isValid()){
			(*this).cover.clear();
			(*this).findCellCoverHeuristic(source,0.25f,NULL);
			
			if (nbc == maxcell) label.channels = maxcell; 
			else label.channels = nbc+1;
			label.allocateBuffer();
			cellCompleteLabel(source,&label,pixdist);
			if (cover.size() == 0) return;
		}
		printf("hohotat\n");
		if (hidden_map){
			Madstructs::Image<float>* new_map = new Madstructs::Image<float>();
			new_map->sizex = source->sizex;
			new_map->sizey = source->sizey;
			new_map->channels = label.channels + 1;
			new_map->allocateBuffer();
			
			
			for(coor[1]=0;coor[1]<source->sizey;coor[1]++) for(coor[0]=0;coor[0]<source->sizex;coor[0]++){
				label.getPixel(coor[0], coor[1], pox);
				source->getPixel(coor[0], coor[1], pix);
				for(j = label.channels; j> 0 ;j--) pox[j] = pox[j-1] * pix[0];
				pox[0] = 1.0f - pix[0];
				new_map->setPixel(coor[0], coor[1], pox);
			}
			
			(*hidden_map).push_back(new_map);
			
		}
		if (movie) addframe_distancemap(show,source); 
		
		
		
	}
	
	printf("%i cells found\n",nbc+1);fflush(stdout);
	if (movie) {
		Madstructs::Image<unsigned char>::SaveTiffImage(show,"../../../../assign.tif");
	}
	
}


void Madstructs::CellCover::findCellCoverAlgerabric(Madstructs::Image<double>* source, double contour_min,  double contour_max){
	int daclock = clock();
	LFHPrimitive::Vector< LFHPrimitive::Tuple<double, 3> > pixlist;
	unsigned int coor[2];
	double pix[32];
	
	double excent_limit = 10.0f; 
	// 6.0f -> 0.5 aspect_ratio  (0.5 - 1/6) / (0.5 + 1/6) 
	// 10.0f -> 0.666 aspect_ratio  (0.4) / (0.6) 
	
	
	LFHPrimitive::Vector<LFHPrimitive::KeyElem<double, LFHPrimitive::Tuple<double,5> > > foundlist;
	
	coor[0] = source->sizex;
	coor[1] = source->sizey;
	
	/*	DEBUG VARS
	LFHPrimitive::DataGrid<unsigned char, 2 > report(coor);
	LFHPrimitive::TiffFile tf_out("../../../../changes.tif");
	*/
	
	LFHPrimitive::Tuple<double, 3> ex;
	for(coor[0]=0;coor[0]< source->sizex;coor[0]++)
		for(coor[1]=0;coor[1]< source->sizey;coor[1]++){
			source->getPixel(coor[0],coor[1],pix);
			
			if ((pix[0] > 0.1f)&&((contour_max == 0.0f)||(((pix[2] >= contour_min))&&((pix[2] <= contour_max))))) {
				ex[0] = coor[0];
				ex[1] = coor[1];
				ex[2] = pix[0];
				pixlist.push_back(ex);
			
			}
		}
	
	LFHPrimitive::CurvatureSearchScope scp;
	

	
	
	// F(x) = A + BX+ CY + (D+E)^2X^2 + (D-E)^2Y^2 + 2XY (1-2*D^2-2*E^2)^0.5; Where A<0 (Hyperbolic otherwise)
	
	// F(x) = A + BX+ CY + (D+E)^2X^2 + (D-E)^2Y^2 + 2XY (1-2*D^2-2*(E+D)^2)^0.5; Where A<0 (Hyperbolic otherwise)

	// F(x) = A + BX+ CY + Cos(E)*(Cos(D)*X^2+ sin(D)*Y^2) + 2XY SIN(E) ; Where AD<0 AE<0 (Hyperbolic otherwise)
	
	
	double guess[5];

	LFHPrimitive::KeyElem<double, LFHPrimitive::Tuple<double,5> > best_guess;
	
	double derivative[6];
	double eval;
	double err;
	unsigned int nbsampl;
	unsigned int i;
	double influence;
	
	double sig2 = 625.0f;
	
	double bufangle[4];
	unsigned int ind[3];
	double tmp[2];
	unsigned int trials;
	while(pixlist.size() > 10){
		

	//	printf("%i pt remains\n", pixlist.size());fflush(stdout);
		// iteratively remove pts
//		printf("start fit %i pts remaining\n", pixlist.size() );
		
		
		/*	DEBUG CODE
		LFHPrimitive::ExOp::toZero(report);
		for(i=0;i<pixlist.size();i++){
			ex = pixlist[i];
				coor[0] = ex[0];
				coor[1] = ex[1];
				report(coor) = 255;
			}
		
		tf_out.put(report,(unsigned char)0, (unsigned char) 255);
		 */


		nbsampl = 2u + (unsigned int )(pixlist.size() / (4.0f * (contour_max - contour_min)));
		
		for(trials=0;trials<nbsampl;trials++){
		
		unsigned short fail_cnt, loop_cnt;
			
		// choose 3 random pts;
		for(loop_cnt=0;loop_cnt<1000;loop_cnt++){
		ind[0] = rand() % pixlist.size();
		ind[1] = rand() % (pixlist.size() - 1);
		if (ind[1] >= ind[0]) ind[1]++;
		ind[2] = rand() % (pixlist.size() - 2);
		if (ind[2] >= ind[0]) ind[2]++;
		if (ind[2] >= ind[1]) ind[2]++;
		if (ind[2] == ind[0]) ind[2]++;
		
		bufangle[1] = pixlist[ind[0]][0] *  pixlist[ind[0]][0] + pixlist[ind[0]][1] *  pixlist[ind[0]][1];
		bufangle[2] = pixlist[ind[1]][0] *  pixlist[ind[1]][0] + pixlist[ind[1]][1] *  pixlist[ind[1]][1];
		bufangle[3] = pixlist[ind[2]][0] *  pixlist[ind[2]][0] + pixlist[ind[2]][1] *  pixlist[ind[2]][1];
		
		err = bufangle[1] * ( pixlist[ind[1]][0] * pixlist[ind[2]][1] - pixlist[ind[2]][0] * pixlist[ind[1]][1]) + bufangle[2] * ( pixlist[ind[2]][0] * pixlist[ind[0]][1] - pixlist[ind[0]][0] * pixlist[ind[2]][1]) + bufangle[3] * ( pixlist[ind[0]][0] * pixlist[ind[1]][1] - pixlist[ind[1]][0] * pixlist[ind[0]][1]); 
		
		bufangle[0] = pixlist[ind[0]][1] * (bufangle[2] -bufangle[3]) + pixlist[ind[1]][1] * (bufangle[3] -bufangle[1]) + pixlist[ind[2]][1] * (bufangle[1] -bufangle[2]) ; // denum;
		bufangle[1] = pixlist[ind[0]][0] * (bufangle[2] -bufangle[3]) + pixlist[ind[1]][0] * (bufangle[3] -bufangle[1]) + pixlist[ind[2]][0] * (bufangle[1] -bufangle[2]) ; // denum;
		
		bufangle[3] = pixlist[ind[0]][0] * (pixlist[ind[1]][1] - pixlist[ind[2]][1]) + pixlist[ind[1]][0] * (pixlist[ind[2]][1] - pixlist[ind[0]][1]) + pixlist[ind[2]][0] * (pixlist[ind[0]][1] - pixlist[ind[1]][1]); // denum;
		
		bufangle[0] = -bufangle[0] /  (2.0f * bufangle[3]);
		bufangle[1] = bufangle[1] / (2.0f * bufangle[3]);
		bufangle[2] = sqrt(bufangle[0]*bufangle[0] + bufangle[1] * bufangle[1] + (err / bufangle[3]));
		
				// is circle is not fully in rectangle, start over
				if (bufangle[0]+1 < bufangle[2]) continue;
				if (bufangle[1]+1 < bufangle[2]) continue;
				if (bufangle[0] + bufangle[2] > source->sizex) continue;
				if (bufangle[1] + bufangle[2] > source->sizey) continue;
				
				// if distance to the edge at center is smaller than guess 90% radius, start over
				coor[0] = 	(int)(bufangle[0] + 0.5f);			
				coor[1] = 	(int)(bufangle[1] + 0.5f);			
				source->getPixel(coor[0],coor[1],pix);
				if (pix[0] < 0.1f) continue;
				if (pix[2] < 0.9f * bufangle[2]) continue; 
				
				
				break;
			}
			if (loop_cnt>= 1000) {
				
				if ((contour_max == 0.0f)||(cover.size() >0)) {printf("unlucky with circles!!! no good initial guess found!\n");fflush(stdout); return;}
				printf("ignore more background!!\n");
				return findCellCoverAlgerabric(source,contour_min + 1.0f,  contour_max + 1.0f);
			}
	//	printf("center : %e,%e  radius =  %e\n", bufangle[0], bufangle[1], bufangle[2]);
		
	//	printf(" dists %e,%e,%e\n ", hypot(pixlist[ind[0]][0] - bufangle[0], pixlist[ind[0]][1] - bufangle[1]),hypot(pixlist[ind[1]][0] - bufangle[0], pixlist[ind[1]][1] - bufangle[1]),hypot(pixlist[ind[2]][0] - bufangle[0], pixlist[ind[2]][1] - bufangle[1])) ; // dists

		// translating in searchspace * * * * * * * * * * * * * * * * * * 
			
		guess[3] = 0.0f; // X-formed excentricity
		guess[4] = (2.0f * M_PI) * (((double) rand()) / RAND_MAX); // orientation angle
		// radius:
		guess[0] = -0.5f * bufangle[2] * bufangle[2];
		// center
		guess[1] = bufangle[0]; // x-coordinate
		guess[2] = bufangle[1]; // y-coordinate
		// translating in searchspace * * * * * * * * * * * * * * * * * * 
			
		bufangle[2] = excent_limit * (1.0f + exp(guess[3]));
		bufangle[3] = sin(guess[4]) / bufangle[2];
		bufangle[2] = cos(guess[4]) / bufangle[2];
		bufangle[0] = 0.5f + bufangle[2];
		bufangle[1] = 0.5f - bufangle[2];
		
//			printf("%e\t%e\t%e", bufangle[2],bufangle[3],bufangle[0]);
		


		
		// 0 = guess[1] + 2.0 * x * bufangle[0] + 2.0 * y * bufangle[3] 
		// 0 = guess[2] + 2.0 * x * bufangle[3] + 2.0 * y * bufangle[1] 
		//
		// center_x = guess[1] * cos(guess[4]) - guess[2] * sin(guess[4])] / (0.25 + (1 / (6*(1 + exp(guess[3])))) 
		// center_y = guess[1] * cos(guess[4]) - guess[2] * sin(guess[4])] / (0.25 + (1 / (6*(1 + exp(guess[3])))) 
		
		
		
		
	
		scp.init(0.000001f,5);
		
		
		
		for(fail_cnt=0,loop_cnt=0;loop_cnt<1000;loop_cnt++){
			
		bufangle[2] = excent_limit * (1.0f + exp(guess[3]));
		bufangle[3] = sin(guess[4]) / bufangle[2];
		bufangle[2] = cos(guess[4]) / bufangle[2];
		
		bufangle[0] = 0.5f + bufangle[2];
		bufangle[1] = 0.5f - bufangle[2];
		/* TEST_CODE	
			if (loop_cnt == 0){
				tmp[0] = pixlist[ind[0]][0] - guess[1];
				tmp[1] = pixlist[ind[0]][1] - guess[2];
				printf("%e\n", hypot(tmp[0],tmp[1]));
				err = guess[0] + tmp[0]*tmp[0] * bufangle[0] + tmp[1]*tmp[1]*bufangle[1] + 2.0f * tmp[0]*tmp[1]*bufangle[3];
				printf("pt1 err:%e\n", err);
				tmp[0] = pixlist[ind[1]][0] - guess[1];
				tmp[1] = pixlist[ind[1]][1] - guess[2];
				printf("%e\n", hypot(tmp[0],tmp[1]));
				err = guess[0] + tmp[0]*tmp[0] * bufangle[0] + tmp[1]*tmp[1]*bufangle[1] + 2.0f * tmp[0]*tmp[1]*bufangle[3];
				printf("pt2 err:%e\n", err);
				tmp[0] = pixlist[ind[2]][0] - guess[1];
				tmp[1] = pixlist[ind[2]][1] - guess[2];
				printf("%e\n", hypot(tmp[0],tmp[1]));
				err = guess[0] + tmp[0]*tmp[0] * bufangle[0] + tmp[1]*tmp[1]*bufangle[1] + 2.0f * tmp[0]*tmp[1]*bufangle[3];
				printf("pt3 err:%e\n", err);
				
				tmp[0] = 0.0f;
				tmp[1] = 0.0f;
				printf("%e\n", hypot(tmp[0],tmp[1]));
				err = guess[0] + tmp[0]*tmp[0] * bufangle[0] + tmp[1]*tmp[1]*bufangle[1] + 2.0f * tmp[0]*tmp[1]*bufangle[3];
				printf("cen err:%e\n", err);
			}
		*/
			
		eval =0;
	
		memset(derivative,'\0',sizeof(double)*6);
			//	printf("matrix is ,%e,%e,%e,\n", bufangle[0],bufangle[1],bufangle[3]);
			//	printf("alpha %e\n", scp());
		double test[6];
		memset(test,'\0',sizeof(double)*5);

			
		
		for(i=0;i<pixlist.size();i++){
			ex = pixlist[i];
			tmp[0] = ex[0] - guess[1];
			tmp[1] = ex[1] - guess[2];
			//err = guess[0] +  guess[1] * ex[0] + guess[2] * ex[1] + ex[0]*ex[0] * bufangle[0] + ex[1]*ex[1]*bufangle[1] + 2.0f * ex[0]*ex[1]*bufangle[3];
			err = guess[0] + tmp[0]*tmp[0] * bufangle[0] + tmp[1]*tmp[1]*bufangle[1] + 2.0f * tmp[0]*tmp[1]*bufangle[3];
			//err = -1.0f +  (tmp[0]*tmp[0] * bufangle[0] + tmp[1]*tmp[1]*bufangle[1] + 2.0f * tmp[0]*tmp[1]*bufangle[3]) * exp(guess[0]) ;
			
			influence = (err*err + sig2); // not final influence
			// weight =  2.0f * sig2 / (influence*influence);
			coor[0] = (unsigned int) ex[0];
			coor[1] = (unsigned int) ex[1];
		//	report(coor) = (unsigned char)(127 + 128.0f * sig2 * sig2 / (influence*influence)); // normalized weight

			
			
			influence = 2.0f * err * sig2 / (influence*influence); // final influence
			
			eval += 1.0f / (1.0f + sig2/(err*err));
		//	derivative[0] += influence * (err + 1.0f);
			derivative[0] += influence;
		//	influence *= exp(guess[0]);
			derivative[1] += influence * tmp[0];
			derivative[2] += influence * tmp[1];
			
			derivative[3] += influence * tmp[0]* tmp[1];
			derivative[4] += influence * tmp[0]* tmp[0];
			derivative[5] += influence * tmp[1]* tmp[1];
			/*	DEBUG CODE
			tmp[0] = ex[0] - guess[1];
			tmp[1] = ex[1] - guess[2];
			err = -1.0f +  (tmp[0]*tmp[0] * bufangle[0] + tmp[1]*tmp[1]*bufangle[1] + 2.0f * tmp[0]*tmp[1]*bufangle[3]) * exp(guess[0] + 0.000001f) ;
			test[0] += 1.0f / (1.0f + sig2/(err*err));
			tmp[0] = ex[0] - guess[1] - 0.000001f;
			tmp[1] = ex[1] - guess[2];
			err = -1.0f +  (tmp[0]*tmp[0] * bufangle[0] + tmp[1]*tmp[1]*bufangle[1] + 2.0f * tmp[0]*tmp[1]*bufangle[3]) * exp(guess[0]) ;
			test[1] += 1.0f / (1.0f + sig2/(err*err));
			tmp[0] = ex[0] - guess[1];
			tmp[1] = ex[1] - guess[2] - 0.000001f;
			err = -1.0f +  (tmp[0]*tmp[0] * bufangle[0] + tmp[1]*tmp[1]*bufangle[1] + 2.0f * tmp[0]*tmp[1]*bufangle[3]) * exp(guess[0]) ;
			test[2] += 1.0f / (1.0f + sig2/(err*err));
			/*
			bufangle[2] = excent_limit * (1.0f + exp(guess[3] + 0.000001f));
			bufangle[3] = sin(guess[4]) / bufangle[2];
			bufangle[2] = cos(guess[4]) / bufangle[2];
			
			bufangle[0] = 0.5f + bufangle[2];
			bufangle[1] = 0.5f - bufangle[2];
			
			err = guess[0] + guess[1] * ex[0] + guess[2] * ex[1] + ex[0]*ex[0] * bufangle[0] + ex[1]*ex[1]*bufangle[1] + 2.0f * ex[0]*ex[1]*bufangle[3];
			test[3] += 1.0f / (1.0f + sig2/(err*err));
			
			bufangle[2] = excent_limitf * (1.0f + exp(guess[3]));
			
			bufangle[3] = sin(guess[4]+0.000001f) / bufangle[2];
			bufangle[2] = cos(guess[4]+0.000001f) / bufangle[2];
			
			bufangle[0] = 0.5f + bufangle[2];
			bufangle[1] = 0.5f - bufangle[2];
			
			err = guess[0] + guess[1] * ex[0] + guess[2] * ex[1] + ex[0]*ex[0] * bufangle[0] + ex[1]*ex[1]*bufangle[1] + 2.0f * ex[0]*ex[1]*bufangle[3];
			test[4] += 1.0f / (1.0f + sig2/(err*err)); */
			
		}
			
			/*	DEBUG CODE
			for(coor[0]=0;coor[0]< source->sizex;coor[0]++)
				for(coor[1]=0;coor[1]< source->sizey;coor[1]++){
					source->getPixel(coor[0],coor[1],pix);
					tmp[0] = coor[0] - guess[1];
					tmp[1] = coor[1] - guess[2];
//					err = guess[0] +  guess[1] * tmp[0] + guess[2] * ex[1] + ex[0]*ex[0] * bufangle[0] + ex[1]*ex[1]*bufangle[1] + 2.0f * ex[0]*ex[1]*bufangle[3];
					//	err = -1.0f +  (tmp[0]*tmp[0] * bufangle[0] + tmp[1]*tmp[1]*bufangle[1] + 2.0f * tmp[0]*tmp[1]*bufangle[3]) * exp(guess[0]) ;
						err = guess[0] +  tmp[0]*tmp[0] * bufangle[0] + tmp[1]*tmp[1]*bufangle[1] + 2.0f * tmp[0]*tmp[1]*bufangle[3];
					influence = (err*err + sig2);
					report(coor) = (unsigned char)(127 + 128.0f * sig2 * sig2 / (influence*influence)); // normalized weight
				}
			
			tf_out.put(report,(unsigned char)0, (unsigned char) 255);
			*/
		err = derivative[3];
		derivative[3] = ((derivative[4] - derivative[5]) * bufangle[2] + 2* err * bufangle[3]) / (-1.0f - exp(-guess[3]));
		
		derivative[4] = (derivative[4] - derivative[5]) * -bufangle[3] + 2* err * bufangle[2] ;

		err = derivative[1];
		
		derivative[1] = -2.0f * err * bufangle[0] - 2.0f * derivative[2] * bufangle[3]; 
		derivative[2] = -2.0f * err * bufangle[3] - 2.0f * derivative[2] * bufangle[1]; 
			
			
			
	//	printf("F [  %e\t%e\t%e\t%e\t%e ] = %e\n", guess[0], guess[1], guess[2], guess[3], guess[4], eval);

	//	printf("deriv     = %e\t%e\t%e\t%e\t%e\n", derivative[0],derivative[1], derivative[2],derivative[3], derivative[4]);
	//	printf("emp deriv = %e\t%e\t%e\t%e\t%e\n", (test[0] -  eval)*1000000.0f , (test[1] -  eval)*1000000.0f , (test[2] -  eval)*1000000.0f ,(test[3] -  eval)*1000000.0f, (test[4] -  eval)*1000000.0f);
	
	//	printf("aspect ratio= %e\n", (0.5 - (1.0f / excent_limit * (1.0f + exp(guess[3])))) / (0.5 + (1.0f / excent_limitf * (1.0f + exp(guess[3])))) );
			if (loop_cnt < 10) scp.updateDescent(eval,guess,derivative);
			else if (scp.updateDescent(eval,guess,derivative) < 0.0000000000001f) break;
	
			if ((loop_cnt == 0)||(best_guess.k > eval)){
				fail_cnt = 0;
				best_guess.k = eval;
				best_guess.d[0] = guess[0];
				best_guess.d[1] = guess[1];
				best_guess.d[2] = guess[2];
				best_guess.d[3] = guess[3];
				best_guess.d[4] = guess[4];
			}else fail_cnt++;
			
		//	for(i=0;i<5;i++) guess[i] -= derivative[i] * 0.1f;
			if (fail_cnt >= 10) break;
		}
		
		// found local minima!
		
			if (LFHPrimitive::ExCo<double>::isValid(best_guess.k)) foundlist.push_back(best_guess);
			else trials--;
			
			if (clock() -  daclock > 600 * CLOCKS_PER_SEC) {
				printf("TOO LONG! ignore group!\n");
				if ((contour_max == 0.0f)||(cover.size() >0)) {fflush(stdout); return;}
				return findCellCoverAlgerabric(source,contour_min + 1.0f,  contour_max + 1.0f);
			}
		}
	
		if (foundlist.size() == 0) break;
		
		foundlist.sort();
		
		for(ind[2] = 0; ind[2] < foundlist.size();ind[2]++){
		coor[0] = (unsigned int)(0.5f + foundlist[ind[2]].d[1]);
		coor[1] = (unsigned int)(0.5f + foundlist[ind[2]].d[2]);
			
			bufangle[2] = 1.0f / (excent_limit * (1.0f + exp(foundlist[ind[2]].d[3])));
			
			source->getPixel(coor[0],coor[1],pix);
			if ((pix[0] < 0.1f)||(pix[2] < 0.90f * sqrt(-foundlist[ind[2]].d[0] / (0.5f - bufangle[2]) ) )) continue;
			break;
		}
		if (ind[2] >= foundlist.size()) ind[2] =0; // all failed...
		
		
/*	DEBUG CODE		
		for(i=0;i<1;i++){
			
			bufangle[2] = excent_limit * (1.0f + exp(foundlist[i].d[3]));
			bufangle[3] = sin(foundlist[i].d[4]) / bufangle[2];
			bufangle[2] = cos(foundlist[i].d[4]) / bufangle[2];
			
			bufangle[0] = 0.5f + bufangle[2];
			bufangle[1] = 0.5f - bufangle[2];
			
			for(coor[0]=0;coor[0]< source->sizex;coor[0]++)
				for(coor[1]=0;coor[1]< source->sizey;coor[1]++){
					source->getPixel(coor[0],coor[1],pix);
					tmp[0] = coor[0] - foundlist[i].d[1];
					tmp[1] = coor[1] - foundlist[i].d[2];
					//					err = guess[0] +  guess[1] * tmp[0] + guess[2] * ex[1] + ex[0]*ex[0] * bufangle[0] + ex[1]*ex[1]*bufangle[1] + 2.0f * ex[0]*ex[1]*bufangle[3];
					//	err = -1.0f +  (tmp[0]*tmp[0] * bufangle[0] + tmp[1]*tmp[1]*bufangle[1] + 2.0f * tmp[0]*tmp[1]*bufangle[3]) * exp(guess[0]) ;
					err = best_guess.d[0] +  tmp[0]*tmp[0] * bufangle[0] + tmp[1]*tmp[1]*bufangle[1] + 2.0f * tmp[0]*tmp[1]*bufangle[3];
					influence = (err*err + sig2);
					report(coor) = (unsigned char)(127 + 128.0f * sig2 * sig2 / (influence*influence)); // normalized weight
				}
			tf_out.put(report,(unsigned char)0, (unsigned char) 255);
		}
		*/
		
		bufangle[2] = excent_limit * (1.0f + exp(foundlist[ind[2]].d[3]));
		bufangle[3] = sin(foundlist[ind[2]].d[4]) / bufangle[2];
		bufangle[2] = cos(foundlist[ind[2]].d[4]) / bufangle[2];
		
		bufangle[0] = 0.5f + bufangle[2];
		bufangle[1] = 0.5f - bufangle[2];
		
		
		cover.push_back(Madstructs::CellPose());
		int loop_cnt = cover.size()-1;
		cover[loop_cnt].center[0] = foundlist[ind[2]].d[1];
		cover[loop_cnt].center[1] = foundlist[ind[2]].d[2];
		
		
		bufangle[2] = 1.0f / (excent_limit * (1.0f + exp(foundlist[ind[2]].d[3])));
		
		cover[loop_cnt].width = 2.0f * sqrt(-foundlist[ind[2]].d[0] / (0.5f - bufangle[2]) );
		
	//	bufangle[2] = (0.5f + bufangle[2]) / (0.5f - bufangle[2]) ; // 1 / aspect ratio^2
		
	//	printf("   %f\t   %f\n", cover[loop_cnt].width , bufangle[2]);
		
		bufangle[2] = sqrt(foundlist[ind[2]].d[0] * ( 1.0f / (0.5f + bufangle[2])  -  1.0f / (0.5f - bufangle[2]))) ;

		
		cover[loop_cnt].eccentric[0] = -sin(0.5f * foundlist[ind[2]].d[4]) * bufangle[2] ;
		cover[loop_cnt].eccentric[1] = cos(0.5f * foundlist[ind[2]].d[4]) *bufangle[2] ;
	//	printf("(%f\t%f)+-(%f\t%f)\t%f\n", cover[loop_cnt].center[0], cover[loop_cnt].center[1], cover[loop_cnt].eccentric[0], cover[loop_cnt].eccentric[1], cover[loop_cnt].width);
		

		// remove pts
		
	//	printf("removing pts remains\n");fflush(stdout);
		
		for(i=0;i<pixlist.size();i++){
			ex = pixlist[i];
			tmp[0] = ex[0] - foundlist[ind[2]].d[1];
			tmp[1] = ex[1] - foundlist[ind[2]].d[2];
			err = foundlist[ind[2]].d[0] +  tmp[0]*tmp[0] * bufangle[0] + tmp[1]*tmp[1]*bufangle[1] + 2.0f * tmp[0]*tmp[1]*bufangle[3];
			if (err*err < sig2*2.0f){
				//remove pt;
				//	printf("pt err = %f\n", cover[loop_cnt].width - hypot(ex[0]-  cover[loop_cnt].center[0] - cover[loop_cnt].eccentric[0], ex[1]-  cover[loop_cnt].center[1] - cover[loop_cnt].eccentric[1]) - hypot(ex[0]-  cover[loop_cnt].center[0] + cover[loop_cnt].eccentric[0], ex[1]-  cover[loop_cnt].center[1] + cover[loop_cnt].eccentric[1]) );
				pixlist.pop_swap(i);
				i--;
			}
		}
		
//		printf("removing pts remains done\n");fflush(stdout);

		foundlist.clear();
		
		// check if found ellipse overlaps witch previous
		ind[0] = cover.size()-1;
		for(ind[1]=0;ind[1]<cover.size()-1;ind[1]++){
			if  (hypot(cover[ind[0]].center[0] - cover[ind[1]].center[0] - cover[ind[1]].eccentric[0], cover[ind[0]].center[1] - cover[ind[1]].center[1] - cover[ind[1]].eccentric[1])
				+hypot(cover[ind[0]].center[0] - cover[ind[1]].center[0] + cover[ind[1]].eccentric[0], cover[ind[0]].center[1] - cover[ind[1]].center[1] + cover[ind[1]].eccentric[1]) 
				<cover[ind[1]].width) break;
			if  (hypot(cover[ind[1]].center[0] - cover[ind[0]].center[0] - cover[ind[0]].eccentric[0], cover[ind[1]].center[1] - cover[ind[0]].center[1] - cover[ind[0]].eccentric[1])
				+hypot(cover[ind[1]].center[0] - cover[ind[0]].center[0] + cover[ind[0]].eccentric[0], cover[ind[1]].center[1] - cover[ind[0]].center[1] + cover[ind[0]].eccentric[1]) 
				<cover[ind[0]].width) break;
		}
		if (ind[1] != ind[0]) cover.pop_back();

	//	printf("done check!!!\n");fflush(stdout);
		
		
	/*	DEBUG CODE
		for(coor[0]=0;coor[0]< source->sizex;coor[0]++)
			for(coor[1]=0;coor[1]< source->sizey;coor[1]++){
				report(coor) = 2550.0f / (10.0f + fabs(cover[loop_cnt].width - hypot(coor[0]-  cover[loop_cnt].center[0] - cover[loop_cnt].eccentric[0], coor[1]-  cover[loop_cnt].center[1] - cover[loop_cnt].eccentric[1]) - hypot(coor[0]-  cover[loop_cnt].center[0] + cover[loop_cnt].eccentric[0], coor[1]-  cover[loop_cnt].center[1] + cover[loop_cnt].eccentric[1])));
			}
		tf_out.put(report,(unsigned char)0, (unsigned char) 255);
	*/
	 
	 // recover circle
		// the matrix A has eigen values with e1^2 + e2^2 = 1
		// aspect ratio K is such that K^2 + K^{-2} = 1/(A11A12 - A12A21) = 1/(cos^2 - sin^2) = 1 / cos(2*guess[3])  //argment of sin or cos is paramet guess[3]
		//
		// distance between focal D is s.t.  D2 = A2-B2 = c / e2 -  c / e1 = ( c val after transformation) 
		
		// center is min of fnc
		// derr/dx = guess[1] + 2.0f * (bufangle[0] * ex[0]*bufangle[2] + ex[1]*bufangle[1]);
		// derr/dy = guess[2] + 2.0f * ( ex[0]*bufangle[1] + bufangle[0] * ex[1]*bufangle[3]);
		// the minimum is :st
		// -guess[1] * 0.5f = (bufangle[0] * ex[0] * bufangle[2] + ex[1] * bufangle[1]);
		// -guess[2] * 0.5f = (ex[0] * bufangle[1] + bufangle[0] * ex[1] * bufangle[3] );
		
	//	printf("%f\t%f\t%f\t%f\t%f\n", guess[0], guess[1], guess[2], guess[3], guess[4]);

	//	derivative[5] = (bufangle[0] *bufangle[0] * bufangle[3] * bufangle[2] - bufangle[1]*bufangle[1]); // determinent denom
		

		
		
//		printf("center %f\t%f\n",guess[1] ,guess[2]);

	//	guess[0] -= bufangle[0] * (cover[i].center[0] * cover[i].center[0] * bufangle[2] + cover[i].center[1] * cover[i].center[1] * bufangle[3]) + 2.0f * bufangle[1] *cover[i].center[0] * cover[i].center[1];
		
	//	guess[1] -= bufangle[0] * (cover[i].center[0] * bufangle[2]) + bufangle[1] *cover[i].center[1]; // should make it 0
	//	guess[2] -= bufangle[0] * (cover[i].center[1] * bufangle[3]) + bufangle[1] *cover[i].center[0]; // should make it 0
		
	//	printf("%f\t%f\t%f\t%f\t%f\n", guess[0], guess[1], guess[2], guess[3], guess[4]);
		
	//	printf("char poly X2 + (%e)X + (%e)\n", bufangle[0] *(bufangle[2] + bufangle[3]), bufangle[0] *bufangle[0] *bufangle[2] *bufangle[3]- bufangle[1] *bufangle[1]);
		
	//	printf("damat: determinant %e\n", bufangle[0] *bufangle[0] *bufangle[2] *bufangle[3]- bufangle[1] *bufangle[1]);
	//	printf("%e\t%e\n", bufangle[0] * bufangle[3] , bufangle[1]);
	//	printf("%e\t%e\n", bufangle[1],  bufangle[0] * bufangle[2]);

		
	}
	
}

void Madstructs::CellCover::findCellCoverAlgerabricHeuristic(Madstructs::Image<double>* source, double contour_min,  double contour_max,double epsilon, unsigned int sub_problems_radii, unsigned int hint_max_width){
	
//	printf("start!\n");fflush(stdout);
	LFHPrimitive::Vector< LFHPrimitive::KeyElem< double, LFHPrimitive::Tuple<int,2> > > areas;
	LFHPrimitive::DataGrid< LFHPrimitive::WeightElem<double, 2> ,2> areamap; // area, distsum, dist2sum
	LFHPrimitive::DataGrid< LFHPrimitive::WeightElem<double, 1> ,2> intenstitymap; // area, distsum, dist2sum
	LFHPrimitive::DataGrid< int ,2> incmessage; 
	LFHPrimitive::Tuple<unsigned int, 2> coor;
	unsigned int dim[2];
		unsigned int i;
	dim[0] = source->sizex;
	dim[1] = source->sizey;
	incmessage.setSizes(dim); incmessage *= 0;

	areamap.setSizes(dim);
	LFHPrimitive::WeightElem<double, 2> tmppix = LFHPrimitive::WeightElem<double, 2>(0.0f,1.0f);
	LFHPrimitive::Tuple<double,1> que;
	LFHPrimitive::Tuple<double,2> ans;
	double pix[32];
	double pox[32];
	LFHPrimitive::Tuple<unsigned int, 2> neigh[8];
	double dist[8][2];
	for(coor[1]=0;coor[1]<source->sizey;coor[1]++) for(coor[0]=0;coor[0]<source->sizex;coor[0]++){
		source->getPixel(coor[0],coor[1],pix);
		if (!LFHPrimitive::ExCo<double>::isValid(pix[0])) {pix[0] = 0.0f; source->setPixel(coor[0],coor[1],pix);} 
		areamap(coor) =(pix[0] > 0.1f) ? tmppix : LFHPrimitive::WeightElem<double, 2>(pix[2],pix[0]);
		
		
		//	printf("%f\t%f\n", pix[2], pix[0]);
		//	printf("%f\t%f\n", areamap(coor).getMean(), areamap(coor).getVar());
		if (pix[0] > 0.1f){
			
			
			if (coor[1] < source->sizey-1){
				source->getPixel(coor[0],coor[1]+1,pox);
				
				if (pox[0] > 0.1f){
					if (pix[2] > pox[2]) incmessage(coor) += 1;
					else if (pix[2] < pox[2]) {	coor[1] ++; incmessage(coor) += 1; 	coor[1] --;}	
				}
				coor[1]++;
				if (coor[0] < source->sizex-1){
					source->getPixel(coor[0]+1,coor[1],pox);
					if (pox[0] > 0.1f){
						if (pix[2] > pox[2]) {	coor[1] --; incmessage(coor) += 1; 	coor[1] ++;}
						else if (pix[2] < pox[2]) {	coor[0] ++; incmessage(coor) += 1; 	coor[0] --;}	
					}
					
				}
				
				if (coor[0] > 0){
					source->getPixel(coor[0]-1,coor[1],pox);
					if (pox[0] > 0.1f){
						if (pix[2] > pox[2]) {	coor[1] --; incmessage(coor) += 1; 	coor[1] ++;}
						else if (pix[2] < pox[2]) {	coor[0] --; incmessage(coor) += 1; 	coor[0]++;}	
					}
					
				}
				coor[1]--;
			}
			
			if (coor[0] < source->sizex-1){
				source->getPixel(coor[0]+1,coor[1],pox);
				if (pox[0] > 0.1f){
					if (pix[2] > pox[2]) incmessage(coor) += 1;
					else if (pix[2] < pox[2]) {	coor[0] ++; incmessage(coor) += 1; 	coor[0] --;}	
				}
			}
			
		}
		
	}
	
	stack<LFHPrimitive::Tuple<int,2> > pts;
	
	for(coor[1]=0;coor[1]<source->sizey;coor[1]++) for(coor[0]=0;coor[0]<source->sizex;coor[0]++){
		source->getPixel(coor[0],coor[1],pix);
		if ((incmessage(coor) == 0)&&(pix[0] > 0.1f)) {pts.push(coor);}
	}
	
	double sum;
	LFHPrimitive::WeightElem<double,2> pub;
	LFHPrimitive::WeightElem<double,1> pub_2;
	int j=0;
	while(!pts.empty()) {
		j++;
		coor = pts.top();pts.pop();
		int nbn=0;
		tmppix = areamap(coor);
		sum =0;
		
		source->getPixel(coor[0],coor[1],pix);
		
		if (coor[0] > 0){
			coor[0]--;
			if (coor[1] > 0){
				coor[1]--;
				source->getPixel(coor[0],coor[1],pox);
				if (pix[2] < pox[2]){
					neigh[nbn][0] = coor[0];neigh[nbn][1] = coor[1];dist[nbn][0]=(pox[2] - pix[0])/sqrt(2); dist[nbn][1]=pix[0];dist[nbn][0] *= dist[nbn][0];sum += dist[nbn][0]* dist[nbn][1]; nbn++; 
				}
				coor[1]++;
			}
			
			
			source->getPixel(coor[0],coor[1],pox);
			if (pix[2] < pox[2]){
				neigh[nbn][0] = coor[0];neigh[nbn][1] = coor[1];dist[nbn][0]=(pox[2] - pix[0]); dist[nbn][1]=pix[0];dist[nbn][0] *= dist[nbn][0];sum += dist[nbn][0]* dist[nbn][1]; nbn++;
			}
			
			if (coor[1] < source->sizey-1){
				coor[1]++;
				source->getPixel(coor[0],coor[1],pox);
				if (pix[2] < pox[2]){
					neigh[nbn][0] = coor[0];neigh[nbn][1] = coor[1];dist[nbn][0]=(pox[2] - pix[0])/sqrt(2); dist[nbn][1]=pix[0];dist[nbn][0] *= dist[nbn][0];sum += dist[nbn][0]* dist[nbn][1]; nbn++;
				}
				coor[1]--;
			}
			coor[0]++;
		}
		
		
		if (coor[0] < source->sizex-1){
			coor[0]++;
			if (coor[1] > 0){
				coor[1]--;
				source->getPixel(coor[0],coor[1],pox);
				if (pix[2] < pox[2]){neigh[nbn][0] = coor[0];neigh[nbn][1] = coor[1];dist[nbn][0]=(pox[2] - pix[0])/sqrt(2); dist[nbn][1]=pix[0];dist[nbn][0] *= dist[nbn][0];sum += dist[nbn][0]* dist[nbn][1]; nbn++;}
				coor[1]++;
			}
			source->getPixel(coor[0],coor[1],pox);
			if (pix[2] < pox[2]){neigh[nbn][0] = coor[0];neigh[nbn][1] = coor[1];dist[nbn][0]=(pox[2] - pix[0]); dist[nbn][1]=pix[0];dist[nbn][0] *= dist[nbn][0];sum += dist[nbn][0]* dist[nbn][1]; nbn++;}
			if (coor[1] < source->sizey-1){
				coor[1]++;
				source->getPixel(coor[0],coor[1],pox);
				if (pix[2] < pox[2]){neigh[nbn][0] = coor[0];neigh[nbn][1] = coor[1];dist[nbn][0]=(pox[2] - pix[0])/sqrt(2); dist[nbn][1]=pix[0];dist[nbn][0] *= dist[nbn][0];sum += dist[nbn][0]* dist[nbn][1]; nbn++;}
				coor[1]--;
			}
			coor[0]--;
		}
		if (coor[1] > 0){
			coor[1]--;
			source->getPixel(coor[0],coor[1],pox);
			if (pix[2] < pox[2]){neigh[nbn][0] = coor[0];neigh[nbn][1] = coor[1];dist[nbn][0]=(pox[2] - pix[0]); dist[nbn][1]=pix[0];dist[nbn][0] *= dist[nbn][0];sum += dist[nbn][0]* dist[nbn][1]; nbn++;}
			coor[1]++;
		}
		if (coor[1] < source->sizey-1){
			coor[1]++;
			source->getPixel(coor[0],coor[1],pox);
			if (pix[2] < pox[2]){
				neigh[nbn][0] = coor[0];neigh[nbn][1] = coor[1];dist[nbn][0]=(pox[2] - pix[0]); dist[nbn][1]=pix[0];dist[nbn][0] *= dist[nbn][0]; sum += dist[nbn][0] * dist[nbn][1]; nbn++;
			}
			coor[1]--;
		}
		
		if (sum != 0){
			sum = 1.0f / sum;
			for(i=0;i<nbn;i++) {
				pub = areamap(coor);
				pub += ((coor[0] + coor[1] - neigh[i][0] - neigh[i][1]) & 1) ? 1.0f : sqrt(2.0f);
				pub *=  LFHPrimitive::Weight(dist[i][0]*dist[i][1] * sum); //printf("%f\n", dist[i][0]*dist[i][1] * sum);
				areamap(neigh[i]) += pub;
				incmessage(neigh[i]) -= 1;
				if (incmessage(neigh[i]) == 0) pts.push(neigh[i]);
			}
			pox[10]  = areamap(coor).getMean();
			//	printf("ecart %f != %f,\n", pox[10], pix[2] * (1.0f + epsilon));
			pox[10] -= pix[2] * (1.0f + epsilon);
			pox[11] =  areamap(coor).getVar();
			
			if ((pox[11] == 0)||(isnan(pox[11]))){ // variance is zero!
				pox[10] = (pox[10] < 0.0f) ? areamap(coor).w[0] : 0.0f;
			}else{
				pox[10] /= sqrt(2.0f * pox[11]);
				pox[10] = (1.0f - erf(pox[10])) * 0.5f * areamap(coor).w[0];
			}
			//	printf("%f\t%f\n",pox[10], pox[11]);
			
			if ((!isnan(pix[10]))&&(pox[10] >= 8.0f)) areas.push_back(LFHPrimitive::KeyElem< double , LFHPrimitive::Tuple<int,2> >( pox[10], coor));
		}
	}
	
	areas.sort();

	
//	printf("heuristic done!\n");fflush(stdout);
	
	int daclock = clock();
	LFHPrimitive::Vector< LFHPrimitive::Tuple<double, 3> > all_pixlist;
	LFHPrimitive::Vector< LFHPrimitive::Tuple<double, 3> > pixlist;
	unsigned int area_ite = areas.size()-1;
		
	double excent_limit = 10.0f; 
	// 6.0f -> 0.5 aspect_ratio  (0.5 - 1/6) / (0.5 + 1/6) 
	// 10.0f -> 0.666 aspect_ratio  (0.4) / (0.6) 
	
	LFHPrimitive::Vector<LFHPrimitive::KeyElem<double, LFHPrimitive::Tuple<double,5> > > foundlist;
	
	coor[0] = source->sizex;
	coor[1] = source->sizey;
	
	LFHPrimitive::Tuple<double, 3> ex;
	for(coor[0]=0;coor[0]< source->sizex;coor[0]++)
		for(coor[1]=0;coor[1]< source->sizey;coor[1]++){
			source->getPixel(coor[0],coor[1],pix);
			if ((pix[0] > 0.1f)&&((contour_max == 0.0f)||(((pix[2] >= contour_min))&&((pix[2] <= contour_max))))) {
				ex[0] = coor[0];
				ex[1] = coor[1];
				ex[2] = pix[0];
				all_pixlist.push_back(ex);
			}
		}
	
	LFHPrimitive::CurvatureSearchScope scp;
//	printf("contour done!\n");fflush(stdout);
	// F(x) = A + BX+ CY + (D+E)^2X^2 + (D-E)^2Y^2 + 2XY (1-2*D^2-2*E^2)^0.5; Where A<0 (Hyperbolic otherwise)
	// F(x) = A + BX+ CY + (D+E)^2X^2 + (D-E)^2Y^2 + 2XY (1-2*D^2-2*(E+D)^2)^0.5; Where A<0 (Hyperbolic otherwise)
	// F(x) = A + BX+ CY + Cos(E)*(Cos(D)*X^2+ sin(D)*Y^2) + 2XY SIN(E) ; Where AD<0 AE<0 (Hyperbolic otherwise)
	
	double guess[5];
	
	LFHPrimitive::KeyElem<double, LFHPrimitive::Tuple<double,5> > best_guess;
	
	double derivative[6];
	double eval;
	double err;
	unsigned int nbsampl;
	double influence;
	double sig2 = 25 * (contour_max - contour_min) * (contour_max - contour_min);
	double bufangle[4];
	unsigned int ind[3];
	double tmp[2];
	unsigned int trials;
	while(all_pixlist.size() > 10){
	//	printf("loopy!!\n");fflush(stdout);
		//	printf("%i pt remains\n", pixlist.size());fflush(stdout);
		// iteratively remove pts
		//		printf("start fit %i pts remaining\n", pixlist.size() );
		/*	DEBUG CODE
		 LFHPrimitive::ExOp::toZero(report);
		 for(i=0;i<pixlist.size();i++){
		 ex = pixlist[i];
		 coor[0] = ex[0];
		 coor[1] = ex[1];
		 report(coor) = 255;
		 }
		 
		 tf_out.put(report,(unsigned char)0, (unsigned char) 255);
		 */
		
		// find sub-problem
		while(true){
		for(;area_ite<areas.size();area_ite--){
			source->getPixel(areas[area_ite].d[0],areas[area_ite].d[1],pix);
			if ((hint_max_width)&&(pix[2] * 2.0f > hint_max_width)) continue;
			for(j=0;j<cover.size();j++){
				dist[0][0] = cover[j].center[0] - areas[area_ite].d[0];
				dist[0][1] = cover[j].center[1] - areas[area_ite].d[1];
				dist[1][0] = hypot(dist[0][0] + cover[j].eccentric[0], dist[0][1] + cover[j].eccentric[1]) + hypot(dist[0][0] - cover[j].eccentric[0], dist[0][1] - cover[j].eccentric[1]);
				if (((dist[1][0] - pix[2])/ cover[j].width)  < 1.0f) break;
			}
			if (j == cover.size()) break;
		}
		
		if (area_ite<areas.size()){ // use part of contour pixel
			for(j=0;j< all_pixlist.size();j++){
				if (hypot(all_pixlist[j][0] - areas[area_ite].d[0],all_pixlist[j][1] - areas[area_ite].d[1]) < sub_problems_radii) pixlist.push_back(all_pixlist[j]);
			}
			if (pixlist.size() >= 10) break;
			area_ite--;
		}else{ // use all of contour pixels
			pixlist = all_pixlist;
			break;
		}
			
		}	
		
		nbsampl = 2u + (unsigned int )(pixlist.size() / (4.0f * (contour_max - contour_min)));
	//	printf("loopy prepro!!\n");fflush(stdout);
		for(trials=0;trials<nbsampl;trials++){
			
			unsigned short fail_cnt, loop_cnt;
			
			// get local scan chunk
			
			// choose 3 random pts;
			for(loop_cnt=0;loop_cnt<1000;loop_cnt++){
				if ((area_ite<areas.size()) &&(loop_cnt == 0)){
					// use heuristic guess;
					bufangle[0] = areas[area_ite].d[0];
					bufangle[1] = areas[area_ite].d[1];
					source->getPixel(areas[area_ite].d[0],areas[area_ite].d[1],pix);
					bufangle[2] = pix[2];
				}else{
					// random 3 point init;
				ind[0] = rand() % pixlist.size();
				ind[1] = rand() % (pixlist.size() - 1);
				if (ind[1] >= ind[0]) ind[1]++;
				ind[2] = rand() % (pixlist.size() - 2);
				if (ind[2] >= ind[0]) ind[2]++;
				if (ind[2] >= ind[1]) ind[2]++;
				if (ind[2] == ind[0]) ind[2]++;
				
				bufangle[1] = pixlist[ind[0]][0] *  pixlist[ind[0]][0] + pixlist[ind[0]][1] *  pixlist[ind[0]][1];
				bufangle[2] = pixlist[ind[1]][0] *  pixlist[ind[1]][0] + pixlist[ind[1]][1] *  pixlist[ind[1]][1];
				bufangle[3] = pixlist[ind[2]][0] *  pixlist[ind[2]][0] + pixlist[ind[2]][1] *  pixlist[ind[2]][1];
				
				err = bufangle[1] * ( pixlist[ind[1]][0] * pixlist[ind[2]][1] - pixlist[ind[2]][0] * pixlist[ind[1]][1]) + bufangle[2] * ( pixlist[ind[2]][0] * pixlist[ind[0]][1] - pixlist[ind[0]][0] * pixlist[ind[2]][1]) + bufangle[3] * ( pixlist[ind[0]][0] * pixlist[ind[1]][1] - pixlist[ind[1]][0] * pixlist[ind[0]][1]); 
				
				bufangle[0] = pixlist[ind[0]][1] * (bufangle[2] -bufangle[3]) + pixlist[ind[1]][1] * (bufangle[3] -bufangle[1]) + pixlist[ind[2]][1] * (bufangle[1] -bufangle[2]) ; // denum;
				bufangle[1] = pixlist[ind[0]][0] * (bufangle[2] -bufangle[3]) + pixlist[ind[1]][0] * (bufangle[3] -bufangle[1]) + pixlist[ind[2]][0] * (bufangle[1] -bufangle[2]) ; // denum;
				
				bufangle[3] = pixlist[ind[0]][0] * (pixlist[ind[1]][1] - pixlist[ind[2]][1]) + pixlist[ind[1]][0] * (pixlist[ind[2]][1] - pixlist[ind[0]][1]) + pixlist[ind[2]][0] * (pixlist[ind[0]][1] - pixlist[ind[1]][1]); // denum;
				
				bufangle[0] = -bufangle[0] /  (2.0f * bufangle[3]);
				bufangle[1] = bufangle[1] / (2.0f * bufangle[3]);
				bufangle[2] = sqrt(bufangle[0]*bufangle[0] + bufangle[1] * bufangle[1] + (err / bufangle[3]));
				}
				
				// is circle is not fully in rectangle, start over
				if (bufangle[0]+1 < bufangle[2]) continue;
				if (bufangle[1]+1 < bufangle[2]) continue;
				if (bufangle[0] + bufangle[2] > source->sizex) continue;
				if (bufangle[1] + bufangle[2] > source->sizey) continue;
				
				// if distance to the edge at center is smaller than guess 90% radius, start over
				coor[0] = (int)(bufangle[0] + 0.5f);			
				coor[1] = (int)(bufangle[1] + 0.5f);			
				source->getPixel(coor[0],coor[1],pix);
				if (pix[0] < 0.1f) continue;
				if (pix[2] < 0.9f * bufangle[2]) continue; 
				
				
				break;
			}
			if (loop_cnt>= 1000) {
				
				if ((contour_max == 0.0f)||(cover.size() >0)) {/*printf("unlucky with circles!!! no good initial guess found!\n");fflush(stdout);*/ return;}
			//	printf("ignore more background!!\n");
				return findCellCoverAlgerabricHeuristic(source,contour_min + 1.0f,  contour_max + 1.0f,epsilon, sub_problems_radii);
			}
			//	printf("center : %e,%e  radius =  %e\n", bufangle[0], bufangle[1], bufangle[2]);
			
			//	printf(" dists %e,%e,%e\n ", hypot(pixlist[ind[0]][0] - bufangle[0], pixlist[ind[0]][1] - bufangle[1]),hypot(pixlist[ind[1]][0] - bufangle[0], pixlist[ind[1]][1] - bufangle[1]),hypot(pixlist[ind[2]][0] - bufangle[0], pixlist[ind[2]][1] - bufangle[1])) ; // dists
			
			// translating in searchspace * * * * * * * * * * * * * * * * * * 
			
			guess[3] = 0.0f; // X-formed excentricity
			guess[4] = (2.0f * M_PI) * (((double) rand()) / RAND_MAX); // orientation angle
			// radius:
			guess[0] = -0.5f * bufangle[2] * bufangle[2];
			// center
			guess[1] = bufangle[0]; // x-coordinate
			guess[2] = bufangle[1]; // y-coordinate
			// translating in searchspace * * * * * * * * * * * * * * * * * * 
			
			bufangle[2] = excent_limit * (1.0f + exp(guess[3]));
			bufangle[3] = sin(guess[4]) / bufangle[2];
			bufangle[2] = cos(guess[4]) / bufangle[2];
			bufangle[0] = 0.5f + bufangle[2];
			bufangle[1] = 0.5f - bufangle[2];
			
			//			printf("%e\t%e\t%e", bufangle[2],bufangle[3],bufangle[0]);
			
			
			
			
			// 0 = guess[1] + 2.0 * x * bufangle[0] + 2.0 * y * bufangle[3] 
			// 0 = guess[2] + 2.0 * x * bufangle[3] + 2.0 * y * bufangle[1] 
			//
			// center_x = guess[1] * cos(guess[4]) - guess[2] * sin(guess[4])] / (0.25 + (1 / (6*(1 + exp(guess[3])))) 
			// center_y = guess[1] * cos(guess[4]) - guess[2] * sin(guess[4])] / (0.25 + (1 / (6*(1 + exp(guess[3])))) 
			
			
			
			
			
			scp.init(0.000001f,5);
			
			
			
			for(fail_cnt=0,loop_cnt=0;loop_cnt<1000;loop_cnt++){
				
				bufangle[2] = excent_limit * (1.0f + exp(guess[3]));
				bufangle[3] = sin(guess[4]) / bufangle[2];
				bufangle[2] = cos(guess[4]) / bufangle[2];
				
				bufangle[0] = 0.5f + bufangle[2];
				bufangle[1] = 0.5f - bufangle[2];
				/* TEST_CODE	
				 if (loop_cnt == 0){
				 tmp[0] = pixlist[ind[0]][0] - guess[1];
				 tmp[1] = pixlist[ind[0]][1] - guess[2];
				 printf("%e\n", hypot(tmp[0],tmp[1]));
				 err = guess[0] + tmp[0]*tmp[0] * bufangle[0] + tmp[1]*tmp[1]*bufangle[1] + 2.0f * tmp[0]*tmp[1]*bufangle[3];
				 printf("pt1 err:%e\n", err);
				 tmp[0] = pixlist[ind[1]][0] - guess[1];
				 tmp[1] = pixlist[ind[1]][1] - guess[2];
				 printf("%e\n", hypot(tmp[0],tmp[1]));
				 err = guess[0] + tmp[0]*tmp[0] * bufangle[0] + tmp[1]*tmp[1]*bufangle[1] + 2.0f * tmp[0]*tmp[1]*bufangle[3];
				 printf("pt2 err:%e\n", err);
				 tmp[0] = pixlist[ind[2]][0] - guess[1];
				 tmp[1] = pixlist[ind[2]][1] - guess[2];
				 printf("%e\n", hypot(tmp[0],tmp[1]));
				 err = guess[0] + tmp[0]*tmp[0] * bufangle[0] + tmp[1]*tmp[1]*bufangle[1] + 2.0f * tmp[0]*tmp[1]*bufangle[3];
				 printf("pt3 err:%e\n", err);
				 
				 tmp[0] = 0.0f;
				 tmp[1] = 0.0f;
				 printf("%e\n", hypot(tmp[0],tmp[1]));
				 err = guess[0] + tmp[0]*tmp[0] * bufangle[0] + tmp[1]*tmp[1]*bufangle[1] + 2.0f * tmp[0]*tmp[1]*bufangle[3];
				 printf("cen err:%e\n", err);
				 }
				 */
				
				eval =0;
				
				memset(derivative,'\0',sizeof(double)*6);
				//	printf("matrix is ,%e,%e,%e,\n", bufangle[0],bufangle[1],bufangle[3]);
				//	printf("alpha %e\n", scp());
				double test[6];
				memset(test,'\0',sizeof(double)*5);
				
				
				
				for(i=0;i<pixlist.size();i++){
					ex = pixlist[i];
					tmp[0] = ex[0] - guess[1];
					tmp[1] = ex[1] - guess[2];
					//err = guess[0] +  guess[1] * ex[0] + guess[2] * ex[1] + ex[0]*ex[0] * bufangle[0] + ex[1]*ex[1]*bufangle[1] + 2.0f * ex[0]*ex[1]*bufangle[3];
					err = guess[0] + tmp[0]*tmp[0] * bufangle[0] + tmp[1]*tmp[1]*bufangle[1] + 2.0f * tmp[0]*tmp[1]*bufangle[3];
					//err = -1.0f +  (tmp[0]*tmp[0] * bufangle[0] + tmp[1]*tmp[1]*bufangle[1] + 2.0f * tmp[0]*tmp[1]*bufangle[3]) * exp(guess[0]) ;
					
					influence = (err*err + sig2); // not final influence
					// weight =  2.0f * sig2 / (influence*influence);
					coor[0] = (unsigned int) ex[0];
					coor[1] = (unsigned int) ex[1];
					//	report(coor) = (unsigned char)(127 + 128.0f * sig2 * sig2 / (influence*influence)); // normalized weight
					
					
					
					influence = 2.0f * err * sig2 / (influence*influence); // final influence
					
					eval += 1.0f / (1.0f + sig2/(err*err));
					//	derivative[0] += influence * (err + 1.0f);
					derivative[0] += influence;
					//	influence *= exp(guess[0]);
					derivative[1] += influence * tmp[0];
					derivative[2] += influence * tmp[1];
					
					derivative[3] += influence * tmp[0]* tmp[1];
					derivative[4] += influence * tmp[0]* tmp[0];
					derivative[5] += influence * tmp[1]* tmp[1];
					/*	DEBUG CODE
					 tmp[0] = ex[0] - guess[1];
					 tmp[1] = ex[1] - guess[2];
					 err = -1.0f +  (tmp[0]*tmp[0] * bufangle[0] + tmp[1]*tmp[1]*bufangle[1] + 2.0f * tmp[0]*tmp[1]*bufangle[3]) * exp(guess[0] + 0.000001f) ;
					 test[0] += 1.0f / (1.0f + sig2/(err*err));
					 tmp[0] = ex[0] - guess[1] - 0.000001f;
					 tmp[1] = ex[1] - guess[2];
					 err = -1.0f +  (tmp[0]*tmp[0] * bufangle[0] + tmp[1]*tmp[1]*bufangle[1] + 2.0f * tmp[0]*tmp[1]*bufangle[3]) * exp(guess[0]) ;
					 test[1] += 1.0f / (1.0f + sig2/(err*err));
					 tmp[0] = ex[0] - guess[1];
					 tmp[1] = ex[1] - guess[2] - 0.000001f;
					 err = -1.0f +  (tmp[0]*tmp[0] * bufangle[0] + tmp[1]*tmp[1]*bufangle[1] + 2.0f * tmp[0]*tmp[1]*bufangle[3]) * exp(guess[0]) ;
					 test[2] += 1.0f / (1.0f + sig2/(err*err));
					 /*
					 bufangle[2] = excent_limit * (1.0f + exp(guess[3] + 0.000001f));
					 bufangle[3] = sin(guess[4]) / bufangle[2];
					 bufangle[2] = cos(guess[4]) / bufangle[2];
					 
					 bufangle[0] = 0.5f + bufangle[2];
					 bufangle[1] = 0.5f - bufangle[2];
					 
					 err = guess[0] + guess[1] * ex[0] + guess[2] * ex[1] + ex[0]*ex[0] * bufangle[0] + ex[1]*ex[1]*bufangle[1] + 2.0f * ex[0]*ex[1]*bufangle[3];
					 test[3] += 1.0f / (1.0f + sig2/(err*err));
					 
					 bufangle[2] = excent_limitf * (1.0f + exp(guess[3]));
					 
					 bufangle[3] = sin(guess[4]+0.000001f) / bufangle[2];
					 bufangle[2] = cos(guess[4]+0.000001f) / bufangle[2];
					 
					 bufangle[0] = 0.5f + bufangle[2];
					 bufangle[1] = 0.5f - bufangle[2];
					 
					 err = guess[0] + guess[1] * ex[0] + guess[2] * ex[1] + ex[0]*ex[0] * bufangle[0] + ex[1]*ex[1]*bufangle[1] + 2.0f * ex[0]*ex[1]*bufangle[3];
					 test[4] += 1.0f / (1.0f + sig2/(err*err)); */
					
				}
				
				/*	DEBUG CODE
				 for(coor[0]=0;coor[0]< source->sizex;coor[0]++)
				 for(coor[1]=0;coor[1]< source->sizey;coor[1]++){
				 source->getPixel(coor[0],coor[1],pix);
				 tmp[0] = coor[0] - guess[1];
				 tmp[1] = coor[1] - guess[2];
				 //					err = guess[0] +  guess[1] * tmp[0] + guess[2] * ex[1] + ex[0]*ex[0] * bufangle[0] + ex[1]*ex[1]*bufangle[1] + 2.0f * ex[0]*ex[1]*bufangle[3];
				 //	err = -1.0f +  (tmp[0]*tmp[0] * bufangle[0] + tmp[1]*tmp[1]*bufangle[1] + 2.0f * tmp[0]*tmp[1]*bufangle[3]) * exp(guess[0]) ;
				 err = guess[0] +  tmp[0]*tmp[0] * bufangle[0] + tmp[1]*tmp[1]*bufangle[1] + 2.0f * tmp[0]*tmp[1]*bufangle[3];
				 influence = (err*err + sig2);
				 report(coor) = (unsigned char)(127 + 128.0f * sig2 * sig2 / (influence*influence)); // normalized weight
				 }
				 
				 tf_out.put(report,(unsigned char)0, (unsigned char) 255);
				 */
				err = derivative[3];
				derivative[3] = ((derivative[4] - derivative[5]) * bufangle[2] + 2* err * bufangle[3]) / (-1.0f - exp(-guess[3]));
				
				derivative[4] = (derivative[4] - derivative[5]) * -bufangle[3] + 2* err * bufangle[2] ;
				
				err = derivative[1];
				
				derivative[1] = -2.0f * err * bufangle[0] - 2.0f * derivative[2] * bufangle[3]; 
				derivative[2] = -2.0f * err * bufangle[3] - 2.0f * derivative[2] * bufangle[1]; 
				
				
				
				//	printf("F [  %e\t%e\t%e\t%e\t%e ] = %e\n", guess[0], guess[1], guess[2], guess[3], guess[4], eval);
				
				//	printf("deriv     = %e\t%e\t%e\t%e\t%e\n", derivative[0],derivative[1], derivative[2],derivative[3], derivative[4]);
				//	printf("emp deriv = %e\t%e\t%e\t%e\t%e\n", (test[0] -  eval)*1000000.0f , (test[1] -  eval)*1000000.0f , (test[2] -  eval)*1000000.0f ,(test[3] -  eval)*1000000.0f, (test[4] -  eval)*1000000.0f);
				
				//	printf("aspect ratio= %e\n", (0.5 - (1.0f / excent_limit * (1.0f + exp(guess[3])))) / (0.5 + (1.0f / excent_limitf * (1.0f + exp(guess[3])))) );
				if (loop_cnt < 10) scp.updateDescent(eval,guess,derivative);
				else if (scp.updateDescent(eval,guess,derivative) < 0.0000000000001f) break;
				
				if ((loop_cnt == 0)||(best_guess.k > eval)){
					fail_cnt = 0;
					best_guess.k = eval;
					best_guess.d[0] = guess[0];
					best_guess.d[1] = guess[1];
					best_guess.d[2] = guess[2];
					best_guess.d[3] = guess[3];
					best_guess.d[4] = guess[4];
				}else fail_cnt++;
				
				//	for(i=0;i<5;i++) guess[i] -= derivative[i] * 0.1f;
				if (fail_cnt >= 10) break;
			}
			
			// found local minima!
			
			if (LFHPrimitive::ExCo<double>::isValid(best_guess.k)) foundlist.push_back(best_guess);
			else trials--;
			
			if (clock() -  daclock > 300 * CLOCKS_PER_SEC) {
				printf("TOO LONG! ignore group!\n");
				if ((contour_max == 0.0f)||(cover.size() >0)) {fflush(stdout); return;}
				return findCellCoverAlgerabricHeuristic(source,contour_min + 1.0f,  contour_max + 1.0f, sub_problems_radii, hint_max_width);
			}
		}
	//	printf("loopy preend!!\n");fflush(stdout);
		if (foundlist.size() == 0) break;
		
		foundlist.sort();
		
		for(ind[2] = 0; ind[2] < foundlist.size();ind[2]++){
			coor[0] = (unsigned int)(0.5f + foundlist[ind[2]].d[1]);
			coor[1] = (unsigned int)(0.5f + foundlist[ind[2]].d[2]);
			if (coor[0] >= source->sizex) continue;
			if (coor[1] >= source->sizey) continue;
			bufangle[2] = 1.0f / (excent_limit * (1.0f + exp(foundlist[ind[2]].d[3])));
			
			source->getPixel(coor[0],coor[1],pix);
			if ((pix[0] < 0.1f)||(pix[2] < 0.90f * sqrt(-foundlist[ind[2]].d[0] / (0.5f - bufangle[2]) ) )) continue;
			break;
		}
		if (ind[2] >= foundlist.size()) ind[2] =0; // all failed...
		
		
	//	printf("loopy preend2 %i !!\n",ind[2]);fflush(stdout);
		
		/*	DEBUG CODE		
		 for(i=0;i<1;i++){
		 
		 bufangle[2] = excent_limit * (1.0f + exp(foundlist[i].d[3]));
		 bufangle[3] = sin(foundlist[i].d[4]) / bufangle[2];
		 bufangle[2] = cos(foundlist[i].d[4]) / bufangle[2];
		 
		 bufangle[0] = 0.5f + bufangle[2];
		 bufangle[1] = 0.5f - bufangle[2];
		 
		 for(coor[0]=0;coor[0]< source->sizex;coor[0]++)
		 for(coor[1]=0;coor[1]< source->sizey;coor[1]++){
		 source->getPixel(coor[0],coor[1],pix);
		 tmp[0] = coor[0] - foundlist[i].d[1];
		 tmp[1] = coor[1] - foundlist[i].d[2];
		 //					err = guess[0] +  guess[1] * tmp[0] + guess[2] * ex[1] + ex[0]*ex[0] * bufangle[0] + ex[1]*ex[1]*bufangle[1] + 2.0f * ex[0]*ex[1]*bufangle[3];
		 //	err = -1.0f +  (tmp[0]*tmp[0] * bufangle[0] + tmp[1]*tmp[1]*bufangle[1] + 2.0f * tmp[0]*tmp[1]*bufangle[3]) * exp(guess[0]) ;
		 err = best_guess.d[0] +  tmp[0]*tmp[0] * bufangle[0] + tmp[1]*tmp[1]*bufangle[1] + 2.0f * tmp[0]*tmp[1]*bufangle[3];
		 influence = (err*err + sig2);
		 report(coor) = (unsigned char)(127 + 128.0f * sig2 * sig2 / (influence*influence)); // normalized weight
		 }
		 tf_out.put(report,(unsigned char)0, (unsigned char) 255);
		 }
		 */
		
		bufangle[2] = excent_limit * (1.0f + exp(foundlist[ind[2]].d[3]));
		bufangle[3] = sin(foundlist[ind[2]].d[4]) / bufangle[2];
		bufangle[2] = cos(foundlist[ind[2]].d[4]) / bufangle[2];
		
		bufangle[0] = 0.5f + bufangle[2];
		bufangle[1] = 0.5f - bufangle[2];
		
		
		cover.push_back(Madstructs::CellPose());
		int loop_cnt = cover.size()-1;
		cover[loop_cnt].center[0] = foundlist[ind[2]].d[1];
		cover[loop_cnt].center[1] = foundlist[ind[2]].d[2];
		
		
		bufangle[2] = 1.0f / (excent_limit * (1.0f + exp(foundlist[ind[2]].d[3])));
		
		cover[loop_cnt].width = 2.0f * sqrt(-foundlist[ind[2]].d[0] / (0.5f - bufangle[2]) );
		
		//	bufangle[2] = (0.5f + bufangle[2]) / (0.5f - bufangle[2]) ; // 1 / aspect ratio^2
		
		//	printf("   %f\t   %f\n", cover[loop_cnt].width , bufangle[2]);
		
		bufangle[2] = sqrt(foundlist[ind[2]].d[0] * ( 1.0f / (0.5f + bufangle[2])  -  1.0f / (0.5f - bufangle[2]))) ;
		
		
		cover[loop_cnt].eccentric[0] = -sin(0.5f * foundlist[ind[2]].d[4]) * bufangle[2] ;
		cover[loop_cnt].eccentric[1] = cos(0.5f * foundlist[ind[2]].d[4]) *bufangle[2] ;
		//	printf("(%f\t%f)+-(%f\t%f)\t%f\n", cover[loop_cnt].center[0], cover[loop_cnt].center[1], cover[loop_cnt].eccentric[0], cover[loop_cnt].eccentric[1], cover[loop_cnt].width);
		
		
		// remove pts
		
		//	printf("removing pts remains\n");fflush(stdout);
	//	printf("rempt %i !!\n",all_pixlist.size());fflush(stdout);
		for(i=0;i<all_pixlist.size();i++){
			ex = all_pixlist[i];
			tmp[0] = ex[0] - foundlist[ind[2]].d[1];
			tmp[1] = ex[1] - foundlist[ind[2]].d[2];
			err = foundlist[ind[2]].d[0] +  tmp[0]*tmp[0] * bufangle[0] + tmp[1]*tmp[1]*bufangle[1] + 2.0f * tmp[0]*tmp[1]*bufangle[3];
			if (err*err < sig2*2.0f){
				//remove pt;
				//	printf("pt err = %f\n", cover[loop_cnt].width - hypot(ex[0]-  cover[loop_cnt].center[0] - cover[loop_cnt].eccentric[0], ex[1]-  cover[loop_cnt].center[1] - cover[loop_cnt].eccentric[1]) - hypot(ex[0]-  cover[loop_cnt].center[0] + cover[loop_cnt].eccentric[0], ex[1]-  cover[loop_cnt].center[1] + cover[loop_cnt].eccentric[1]) );
				all_pixlist.pop_swap(i);
				i--;
			}
		}
		pixlist.clear();
	//	printf("rempt done %i !!\n",pixlist.size());fflush(stdout);
		//		printf("removing pts remains done\n");fflush(stdout);
		
		foundlist.clear();
		
		// check if found ellipse overlaps witch previous
		ind[0] = cover.size()-1;
		for(ind[1]=0;ind[1]<cover.size()-1;ind[1]++){
			if  (hypot(cover[ind[0]].center[0] - cover[ind[1]].center[0] - cover[ind[1]].eccentric[0], cover[ind[0]].center[1] - cover[ind[1]].center[1] - cover[ind[1]].eccentric[1])
				 +hypot(cover[ind[0]].center[0] - cover[ind[1]].center[0] + cover[ind[1]].eccentric[0], cover[ind[0]].center[1] - cover[ind[1]].center[1] + cover[ind[1]].eccentric[1]) 
				 <cover[ind[1]].width) break;
			if  (hypot(cover[ind[1]].center[0] - cover[ind[0]].center[0] - cover[ind[0]].eccentric[0], cover[ind[1]].center[1] - cover[ind[0]].center[1] - cover[ind[0]].eccentric[1])
				 +hypot(cover[ind[1]].center[0] - cover[ind[0]].center[0] + cover[ind[0]].eccentric[0], cover[ind[1]].center[1] - cover[ind[0]].center[1] + cover[ind[0]].eccentric[1]) 
				 <cover[ind[0]].width) break;
		}
		if (ind[1] != ind[0]) cover.pop_back();
		
		//	printf("done check!!!\n");fflush(stdout);
		
		
		/*	DEBUG CODE
		 for(coor[0]=0;coor[0]< source->sizex;coor[0]++)
		 for(coor[1]=0;coor[1]< source->sizey;coor[1]++){
		 report(coor) = 2550.0f / (10.0f + fabs(cover[loop_cnt].width - hypot(coor[0]-  cover[loop_cnt].center[0] - cover[loop_cnt].eccentric[0], coor[1]-  cover[loop_cnt].center[1] - cover[loop_cnt].eccentric[1]) - hypot(coor[0]-  cover[loop_cnt].center[0] + cover[loop_cnt].eccentric[0], coor[1]-  cover[loop_cnt].center[1] + cover[loop_cnt].eccentric[1])));
		 }
		 tf_out.put(report,(unsigned char)0, (unsigned char) 255);
		 */
		
		// recover circle
		// the matrix A has eigen values with e1^2 + e2^2 = 1
		// aspect ratio K is such that K^2 + K^{-2} = 1/(A11A12 - A12A21) = 1/(cos^2 - sin^2) = 1 / cos(2*guess[3])  //argment of sin or cos is paramet guess[3]
		//
		// distance between focal D is s.t.  D2 = A2-B2 = c / e2 -  c / e1 = ( c val after transformation) 
		
		// center is min of fnc
		// derr/dx = guess[1] + 2.0f * (bufangle[0] * ex[0]*bufangle[2] + ex[1]*bufangle[1]);
		// derr/dy = guess[2] + 2.0f * ( ex[0]*bufangle[1] + bufangle[0] * ex[1]*bufangle[3]);
		// the minimum is :st
		// -guess[1] * 0.5f = (bufangle[0] * ex[0] * bufangle[2] + ex[1] * bufangle[1]);
		// -guess[2] * 0.5f = (ex[0] * bufangle[1] + bufangle[0] * ex[1] * bufangle[3] );
		
		//	printf("%f\t%f\t%f\t%f\t%f\n", guess[0], guess[1], guess[2], guess[3], guess[4]);
		
		//	derivative[5] = (bufangle[0] *bufangle[0] * bufangle[3] * bufangle[2] - bufangle[1]*bufangle[1]); // determinent denom
		
		
		
		
		//		printf("center %f\t%f\n",guess[1] ,guess[2]);
		
		//	guess[0] -= bufangle[0] * (cover[i].center[0] * cover[i].center[0] * bufangle[2] + cover[i].center[1] * cover[i].center[1] * bufangle[3]) + 2.0f * bufangle[1] *cover[i].center[0] * cover[i].center[1];
		
		//	guess[1] -= bufangle[0] * (cover[i].center[0] * bufangle[2]) + bufangle[1] *cover[i].center[1]; // should make it 0
		//	guess[2] -= bufangle[0] * (cover[i].center[1] * bufangle[3]) + bufangle[1] *cover[i].center[0]; // should make it 0
		
		//	printf("%f\t%f\t%f\t%f\t%f\n", guess[0], guess[1], guess[2], guess[3], guess[4]);
		
		//	printf("char poly X2 + (%e)X + (%e)\n", bufangle[0] *(bufangle[2] + bufangle[3]), bufangle[0] *bufangle[0] *bufangle[2] *bufangle[3]- bufangle[1] *bufangle[1]);
		
		//	printf("damat: determinant %e\n", bufangle[0] *bufangle[0] *bufangle[2] *bufangle[3]- bufangle[1] *bufangle[1]);
		//	printf("%e\t%e\n", bufangle[0] * bufangle[3] , bufangle[1]);
		//	printf("%e\t%e\n", bufangle[1],  bufangle[0] * bufangle[2]);
		
		
	}
	
}

// does not assume the cover is empty (not working)
void Madstructs::CellCover::findCellCover_hiddenmap_upgr(Madstructs::Image<double>* source,bool movie, vector<Madstructs::Image<float>* > *hidden_map, bool noem){
/*
	int i,j;
	
	LFHPrimitive::GaussianDistribution<1> prcell;
	

	LFHPrimitive::Tuple<double, 1> dapix;
	
	
	LFHPrimitive::DataGrid<double, 3> label;
	LFHPrimitive::DataGrid< pair< LFHPrimitive::Tuple<double,1> , pair< LFHPrimitive::Tuple<double, 2> , double> >, 2> crudedata;
	
	LFHPrimitive::ClassifierV< pair< LFHPrimitive::Tuple<double,1> , pair< LFHPrimitive::Tuple<double, 2> , double> > > models;
	
	
	
	pair< LFHPrimitive::Tuple<double,1> , pair< LFHPrimitive::Tuple<double, 2> , double> > tmpcrude;
	
	unsigned int dims[3];
	dims[0] = cover.size();
	
	
	dims[1] = source->sizex;
	dims[2] = source->sizey;
	label.setSizes(dims);
	crudedata.setSizes(dims+1);
	
	LFHPrimitive::GaussianDistribution<1> pixdist;
	LFHPrimitive::DistanceError< LFHPrimitive::Tuple<double,2> > errd;
	
	LFHPrimitive::ExOp::toZero(errd.center);
	errd.radius = 0;
	
	prcell.EMinit();

	unsigned int coor[3];coor[0] =0;
	double pix[4];
	for(coor[2]=0;coor[2]<source->sizey;coor[2]++){
		for(coor[1]=0;coor[1]<source->sizex;coor[1]++){
			source->getPixel(coor[1],coor[2],pix);

			dapix[0] = pix[1];
			prcell.EMregist(dapix, pix[0]);
			tmpcrude.first[0] = pix[1];
			tmpcrude.second.second = pix[2];
			tmpcrude.second.first[0] = coor[1];
			tmpcrude.second.first[1] = coor[2];
			crudedata(coor+1) = tmpcrude;
		}
	}
	prcell.EMfinit(); // initial distribution
	
	
	for(i=0;i<cover.size();i++) {
		
		errd.center[0]  =cover[j].center[0];
		errd.center[1]  =cover[j].center[1];
		coor[2] = (int)(errd.center[1] +0.5f);
		coor[1] = (int)(errd.center[0] +0.5f);
		if (coor[1] <0) coor[1]=0;
		if (coor[2] <0) coor[2]=0;
		if (coor[1] >= source->sizex) coor[1]= source->sizex-1;
		if (coor[2] >= source->sizey) coor[2]= source->sizey-1;
		source->getPixel( coor[1] , coor[2] ,pix);
		errd.radius  = pix[2];
	//	errd.variance  = errd.radius*errd.radius*0.1f;
					models.push_back(new LFHPrimitive::DistribPair< 
												   LFHPrimitive::GaussianDistribution<1>, 
											       LFHPrimitive::DistanceError< LFHPrimitive::Tuple<double,2> > 
											       >(pixdist, errd)
												  );
	}
		
	//preHMM expect hidden state
	for(coor[2]=0;coor[2]<source->sizey;coor[2]++){
		for(coor[1]=0;coor[1]<source->sizex;coor[1]++){
			models( &(label(coor)), crudedata(coor+1)); 
		}
	}
	
	// post HMM expect
	
	
	// distance expect
	
	
	// maximimation
	
	models.EMinit();
	models.EMregist(crudedata, label);
	
	models.EMfinit();
	
	
	
	
	/*
	
	
	double expc=0.0f;

	LFHPrimitive::Tuple<unsigned int,2> coor;

	double pox[32];
	vector<Madstructs::Image<unsigned char>*> show;
	bool firststep =true;

	expc = expc / 1300.0f +0.5f; 
	if (cover.size() == 0) {cover.push_back(Madstructs::CellPose()); nbc=0;pixdist[0] = prcell;}
	else {
		nbc = cover.size()-1;
//		label.channels = nbc+1;
//		label.allocateBuffer();
		for(j=0;j<=nbc;j++) {
			pixdist[j] = prcell;
			cover[j].eccentric[0] = 0.0f; 
			cover[j].eccentric[1] = 0.0f; 
			
			
			
			
		}
		for(i=0;i<10+3*nbc;i++){
//			cellCompleteLabel(source,&label,pixdist); if (movie) addframe(show,&label); 
//			cellIntUpdate(source,&label, pixdist);
		}
	}
	if (!noem){
		
		for(;nbc<maxcell;nbc++){
			//	printf("addcell!\n");
			
			if (nbc> 0){
				
				
				
				pixdist[nbc] = prcell;
//				cellCompleteLabel(source,&label,pixdist);
//				if (firststep == false)	found = findUnclassifCellpt_2(source,&label,cover[nbc].center,&(cover[nbc].width));
	//			else{ found = true;firststep = false;}
			} else found = findUnclassifCellpt_2(source,NULL,cover[0].center,&(cover[nbc].width));
			if (found == false) {
				cover.pop_back();nbc--;
				if (nbc < 0) return;
				break;
			}  //assumes at least 1 cell exists
			if (cover[nbc].width > 30.0f) cover[nbc].width =30.0f;
			if (cover[nbc].width < 10.0f) cover[nbc].width =10.0f;
			//	cover[nbc].center[0] += source->sizex;
			//	cover[nbc].center[1] += source->sizey;
			
			for(j=0;j<=nbc;j++) {
				cover[j].width *= 0.25f;
				cover[j].eccentric[0] = 0.0f;
				cover[j].eccentric[1] = 0.0f;
			}
			//		cover[nbc].eccentric[0] = cover[nbc].width / 25.0f; // eccentricity vector
			//		cover[nbc].eccentric[1] = cover[nbc].width / 25.0f;
			cover[nbc].eccentric[0] = 0.0f; // eccentricity vector
			cover[nbc].eccentric[1] = 0.0f;
	//		label.channels = nbc+1;
	//		label.allocateBuffer();
			
			
			for(i=0;i<20+3*nbc;i++){
				//			if ((i % 5) != 14) {	for(j=0;j<=nbc;j++) printf(" [%f,%f] %f\t",cover[j].eccentric[0],cover[j].eccentric[1],cover[j].width);	printf("\n");}
	//			cellCompleteLabel(source,&label,pixdist); 
	//			cellUpdateEllipse_EM_steps(source,&label,false);
	//			cellCompleteLabel(source,&label,pixdist); 
	//			cellIntUpdate(source,&label, pixdist);
	//			if (movie) addframe(show,&label);
				
				//	cellUpdate2(source,&label, expc,0.05,0.1f);
			}
			
			
			found = false;
			for(j=0;j<=nbc;j++) found |= cover[j].width < 0;
			for(j=0;j<=nbc;j++) found |= (3 >  sqrt(cover[j].width * cover[j].width - 4*cover[j].eccentric[0]*cover[j].eccentric[0] - 4*cover[j].eccentric[1]*cover[j].eccentric[1]));
			if (found){
				for(i=0;i<30+5*nbc;i++){
					if ((i % 10) != 9) {
						//				for(j=0;j<=nbc;j++) printf("(%f,%f) [%f,%f] %f\t",cover[j].center[0],cover[j].center[1],cover[j].eccentric[0],cover[j].eccentric[1],cover[j].width);
					printf("\n");}
	//				cellCompleteLabel(source,&label,pixdist); 
					
					
	//				cellUpdateEllipse_EM_steps(source,&label,false);
	//				cellCompleteLabel(source,&label,pixdist); 
	//				cellIntUpdate(source,&label, pixdist);
	//				if (movie) addframe(show,&label);
					
					//			cellUpdate2(source,&label, expc,0.05,0.2f);
				}
				
				found = false;
				for(j=0;j<=nbc;j++) found |= cover[j].width < 0;
				
				for(j=0;j<=nbc;j++) found |= (3 >  cover[j].width);
				if (found) {
					for(j=0;j<cover.size();j++){
						if  (cover[j].width < 3){
							cover[j] = cover[cover.size()-1];
							pixdist[j] = pixdist[cover.size()-1];
							cover.pop_back();
							j--;
							nbc--;
							
						}
					}
				}		
			}
			break;
			if (nbc == maxcell) break;
			if (found) break;
			cover.push_back(Madstructs::CellPose());
		}
		// Clump Cutted!
	}
	
	if ((nbc <= maxcell)&&(nbc>=0)){
		
		
		
		if (nbc == maxcell) label.channels = maxcell; 
		else label.channels = nbc+1;
		label.allocateBuffer();
		cellCompleteLabel(source,&label,pixdist); 
		
		cellEllipseFit(source,&label);
		
		if (!(*this).isValid()){
			(*this).cover.clear();
			(*this).findCellCoverHeuristic(source,0.25f,NULL);
			
			if (nbc == maxcell) label.channels = maxcell; 
			else label.channels = nbc+1;
			label.allocateBuffer();
			cellCompleteLabel(source,&label,pixdist);
			if (cover.size() == 0) return;
		}
		
		if (hidden_map){
			
			Madstructs::Image<float>* new_map = new Madstructs::Image<float>();
			new_map->sizex = source->sizex;
			new_map->sizey = source->sizey;
			new_map->channels = label.channels + 1;
			new_map->allocateBuffer();
			
			
			for(coor[1]=0;coor[1]<source->sizey;coor[1]++) for(coor[0]=0;coor[0]<source->sizex;coor[0]++){
				label.getPixel(coor[0], coor[1], pox);
				source->getPixel(coor[0], coor[1], pix);
				for(j = label.channels; j> 0 ;j--) pox[j] = pox[j-1] * pix[0];
				pox[0] = 1.0f - pix[0];
				new_map->setPixel(coor[0], coor[1], pox);
			}
			
			(*hidden_map).push_back(new_map);
			
		}
		if (movie) addframe_distancemap(show,source); 
		
		
		
	}
	
	printf("%i cells found\n",nbc+1);fflush(stdout);
	if (movie) {
		Madstructs::Image<unsigned char>::SaveTiffImage(show,"../../../../assign.tif");
	}
	*/
}

// does not assume the cover is empty (not working)
void Madstructs::CellCover::findCellCover_HMM(Madstructs::Image<double>* source){
	/*
	int nbc = cover.size();
	int i,j;
	int maxcell =31;
	
	LFHPrimitive::GaussianDistribution<1> prcell;
	
	
	LFHPrimitive::Tuple<double, 1> dapix;
	
	
	LFHPrimitive::DataGrid<double, 3> label;
	LFHPrimitive::DataGrid<double, 3> bypasslabel;
	
	LFHPrimitive::DataGrid< pair< LFHPrimitive::Tuple<double,1> , pair< LFHPrimitive::Tuple<double, 2> , double> >, 2> crudedata;
	
	LFHPrimitive::ClassifierV< pair< LFHPrimitive::Tuple<double,1> , pair< LFHPrimitive::Tuple<double, 2> , double> > > models;
	
	
	
	pair< LFHPrimitive::Tuple<double,1> , pair< LFHPrimitive::Tuple<double, 2> , double> > tmpcrude;
	
	unsigned int dims[3];
	dims[0] = cover.size();
	
	
	dims[1] = source->sizex;
	dims[2] = source->sizey;
	label.setSizes(dims);
	crudedata.setSizes(dims+1);
	
	LFHPrimitive::GaussianDistribution<1> pixdist;
	LFHPrimitive::DistanceError< LFHPrimitive::Tuple<double,2> > errd;
	
	LFHPrimitive::ExOp::toZero(errd.center);
	errd.radius = 0;
	
	prcell.EMinit();
	
	unsigned int coor[3];coor[0] =0;
	double pix[4];
	for(coor[2]=0;coor[2]<source->sizey;coor[2]++){
		for(coor[1]=0;coor[1]<source->sizex;coor[1]++){
			source->getPixel(coor[1],coor[2],pix);
			
			dapix[0] = pix[1];
			prcell.EMregist(dapix, pix[0]);
			tmpcrude.first[0] = pix[1];
			tmpcrude.second.second = pix[2];
			tmpcrude.second.first[0] = coor[1];
			tmpcrude.second.first[1] = coor[2];
			crudedata(coor+1) = tmpcrude;
		}
	}
	prcell.EMfinit(); // initial distribution
	
	
	for(i=0;i<cover.size();i++) {
		
		errd.center[0]  =cover[j].center[0];
		errd.center[1]  =cover[j].center[1];
		coor[2] = (int)(errd.center[1] +0.5f);
		coor[1] = (int)(errd.center[0] +0.5f);
		if (coor[1] <0) coor[1]=0;
		if (coor[2] <0) coor[2]=0;
		if (coor[1] >= source->sizex) coor[1]= source->sizex-1;
		if (coor[2] >= source->sizey) coor[2]= source->sizey-1;
		source->getPixel( coor[1] , coor[2] ,pix);
		errd.radius  = pix[2];
	//	errd.variance  = errd.radius*errd.radius*0.1f;
		models.push_back(new LFHPrimitive::DistribPair< 
						 LFHPrimitive::GaussianDistribution<1>, 
						 LFHPrimitive::DistanceError< LFHPrimitive::Tuple<double,2> > 
						 >(pixdist, errd)
						 );
	}
	
	models.ExpectHidden( label, crudedata, &bypasslabel, true); 
	/Users/moseslab/Documents/PureMadness/SharedLibraries/primitive_stats.h:1274: warning: unused variable 'nbstates'

	
	// distance expect
	
	
	// maximimation
	
	models.EMinit();
	models.EMregist(crudedata, label);
	
	models.EMfinit();
	
	
	
	*/
}



void Madstructs::CellCover::findCellCover_contour(Madstructs::Image<double>* source, double perim_dist){
	
	
	LFHPrimitive::Vector< pair< LFHPrimitive::Tuple<double,2> , double> > pixlist;
	int i;
	
	unsigned coor[3];
	double pix[32];
	
	pair< LFHPrimitive::Tuple<double,2> , double>  pixinst;
	
	for(coor[2]=0;coor[2]<source->sizey;coor[2]++){
		for(coor[1]=0;coor[1]<source->sizex;coor[1]++){
			source->getPixel(coor[1],coor[2],pix);
			
			if ((pix[0] > 0.5f)&&(pix[2] < perim_dist)){
				pixinst.first[0] = coor[1];
				pixinst.first[1] = coor[2];

				pixinst.second = pix[2];
			//	pixinst.second = pix[0];
				
				pixlist.push_back(pixinst);
			}
		}
	}
	

	LFHPrimitive::ClassifierV< pair< LFHPrimitive::Tuple<double,2> , double> > classif;
	LFHPrimitive::Tuple<double,2> cencen;cencen[0] = source->sizex /2.0f;cencen[1] = source->sizey /2.0f;
	
	classif.setUnknownProbability(0.1f);

	/*
	
	classif.push_back(new LFHPrimitive::EuclidianEllipse<2>(cencen));
	
	
	
	
	double best = classif.performEM(pixlist, 100, true);
	

	cover.push_back(Madstructs::CellPose());
	
	cover[0].width = ((LFHPrimitive::EuclidianEllipse<2>*)classif[0])->radius;
	cover[0].eccentric[0] = ((LFHPrimitive::EuclidianEllipse<2>*)classif[0])->eccent[0]; // eccentricity vector
	cover[0].eccentric[1] = ((LFHPrimitive::EuclidianEllipse<2>*)classif[0])->eccent[1];
	cover[0].center[0] = ((LFHPrimitive::EuclidianEllipse<2>*)classif[0])->center[0]; // eccentricity vector
	cover[0].center[1] =  ((LFHPrimitive::EuclidianEllipse<2>*)classif[0])->center[1];
	cover[0].error[1] = 0.5f / ((LFHPrimitive::EuclidianEllipse<2>*)classif[0])->nihvar;

	
	classif.push_back(new LFHPrimitive::EuclidianEllipse<2>(cencen));((LFHPrimitive::EuclidianEllipse<2>*)classif[1])->fix_std(2.5f);
	double tmplike = classif.performEM(pixlist, 100, true);
	if (tmplike > best){
		cover.push_back(Madstructs::CellPose());
		for(i=0;i<2;i++){
			cover[i].width = ((LFHPrimitive::EuclidianEllipse<2>*)classif[i])->radius;
			cover[i].eccentric[0] = ((LFHPrimitive::EuclidianEllipse<2>*)classif[i])->eccent[0]; // eccentricity vector
			cover[i].eccentric[1] = ((LFHPrimitive::EuclidianEllipse<2>*)classif[i])->eccent[1];
			cover[i].center[0] = ((LFHPrimitive::EuclidianEllipse<2>*)classif[i])->center[0]; // eccentricity vector
			cover[i].center[1] =  ((LFHPrimitive::EuclidianEllipse<2>*)classif[i])->center[1];
			cover[i].error[1] = 0.5f / ((LFHPrimitive::EuclidianEllipse<2>*)classif[i])->nihvar;
		}
	}
	printf("comp likeli %f\t%f\n", tmplike , best);*/
	
	for(i=0;i<cover.size();i++){
		classif.push_back(new LFHPrimitive::EuclidianEllipse<2>());
		((LFHPrimitive::EuclidianEllipse<2>*)classif[i])->set_stddev(5.0f);
		((LFHPrimitive::EuclidianEllipse<2>*)classif[i])->fix_stddev();
		((LFHPrimitive::EuclidianEllipse<2>*)classif[i])->center[0] = cover[i].center[0];
		((LFHPrimitive::EuclidianEllipse<2>*)classif[i])->center[1] = cover[i].center[1];
		((LFHPrimitive::EuclidianEllipse<2>*)classif[i])->eccent[0] = cover[i].width * 0.01f;
		((LFHPrimitive::EuclidianEllipse<2>*)classif[i])->eccent[1] = cover[i].width * 0.01f;
	}
	
	classif.performEM(pixlist, 100, false);
	
	for(i=0;i<cover.size();i++){
		cover[i].width = ((LFHPrimitive::EuclidianEllipse<2>*)classif[i])->width;
		cover[i].eccentric[0] = ((LFHPrimitive::EuclidianEllipse<2>*)classif[i])->eccent[0]; // eccentricity vector
		cover[i].eccentric[1] = ((LFHPrimitive::EuclidianEllipse<2>*)classif[i])->eccent[1];
		cover[i].center[0] = ((LFHPrimitive::EuclidianEllipse<2>*)classif[i])->center[0]; // eccentricity vector
		cover[i].center[1] =  ((LFHPrimitive::EuclidianEllipse<2>*)classif[i])->center[1];
		cover[i].error[1] = 0.5f / ((LFHPrimitive::EuclidianEllipse<2>*)classif[i])->nihvar;
	}
	
}

void Madstructs::CellCover::update_from_contour(Madstructs::Image<double>* source, double perim_dist){
	
	
	LFHPrimitive::Vector<  pair< LFHPrimitive::Tuple<double,2> , double> > * pixlist;
	
	pixlist = new LFHPrimitive::Vector< pair< LFHPrimitive::Tuple<double,2> , double >  >[cover.size()];
	
	int i,j;
	
	unsigned coor[3];
	double pix[32];
	
	pair<  LFHPrimitive::Tuple<double,2>  , double >  pixinst;
	
	for(coor[2]=0;coor[2]<source->sizey;coor[2]++){
		for(coor[1]=0;coor[1]<source->sizex;coor[1]++){
			source->getPixel(coor[1],coor[2],pix);
			
			if ((pix[0] > 0.5f)&&(pix[2] < perim_dist)){
				pixinst.first[0] = coor[1];
				pixinst.first[1] = coor[2];
				
				pixinst.second = pix[2];
				//	pixinst.second = pix[0];
				
				
				for(j=0;j<cover.size();j++){
					if (hypot(cover[j].center[0] - coor[1], cover[j].center[1] - coor[2]) < 0.75f * cover[j].width) {pixlist[j].push_back(pixinst);}
				}
			}
			
		}
	}
	

	LFHPrimitive::ClassifierV< pair< LFHPrimitive::Tuple<double,2> , double> > classif;
	
	LFHPrimitive::EuclidianEllipse<2> ellip;
	classif.push_back(&ellip);
	
	ellip.set_stddev(5.0f);
	ellip.fix_stddev();
	
	classif.setUnknownDensity( ellip.densityOfZscore(5) );
	
	for(i=0;i<cover.size();i++){
	
	classif.performEM(pixlist[i], 100, true);
	
		cover[i].width =  ellip.width;
		cover[i].eccentric[0] = ellip.eccent[0]; // eccentricity vector
		cover[i].eccentric[1] = ellip.eccent[1];
		cover[i].center[0] = ellip.center[0]; // eccentricity vector
		cover[i].center[1] =  ellip.center[1];
		cover[i].error[1] = 0.5f / ellip.nihvar;
	}
	
	for(i=0;i<cover.size();i++) pixlist[i].clear();
	delete[](pixlist);
}


void Madstructs::CellCover::cellError(Madstructs::Image<double>* source, Madstructs::Image<double>* error){
	/*
	int k,x,y;
	double pix[32];
	for(y=0;y<source->sizex;y++) for(x=0;x<source->sizex;x++){
		source->getPixel(x,y,pix);
		if (pix[0] > 0.0001){
			for(k=0;k<cover.size();k++){
				if (cover[k].isInside(x,y)){
				
				}
			
			}
				

		
		}
	}*/
	
}


// finds the ellipse it belongs to
/*
double Madstructs::CellCover::EllipseClusterLabel(LFHPrimitive::DataGrid<LFHPrimitive::Tuple<double,3>,2 >& source, LFHPrimitive::DataGrid<LFHPrimitive::Tuple<int,2>,2 >& label , LFHPrimitive::Tuple<int , 2> &worstpt){
	double worthdist =0.0f;
	unsigned int coor[2];
	double tmp, tmp2, dista,distb;
	LFHPrimitive::Tuple<int,2> cid;
	int ccount;
	int k;
	double pix[32];
	
	
	LFHPrimitive::PolyThing<double> polyt;
	polyt.setOrder(4);
	polyt.coef[4] =1.0f;
	polyt.coef[3] =0.0f;
	vector<double> focaldist;
	for(k=0;k<cover.size();k++) focaldist.push_back(sqrt(cover[k].eccentric[0]*cover[k].eccentric[0] + cover[k].eccentric[1]*cover[k].eccentric[1])* 0.5f);
	
	for(coor[1] =0;coor[1]<source.dims[1];coor[1]++) for(coor[0] =0;coor[0]<source.dims[0];coor[0]++){
		ccount =0;
		for(k=0;k<cover.size();k++){
			tmp = coor[0] - cover[k].center[0];
			tmp2 = tmp + cover[k].eccentric[0];dista = tmp2*tmp2;
			tmp2 = tmp - cover[k].eccentric[0];distb = tmp2*tmp2;
			tmp = coor[1] - cover[k].center[1];
			tmp2 = tmp + cover[k].eccentric[1];dista = sqrt(dista+tmp2*tmp2);
			tmp2 = tmp - cover[k].eccentric[1];distb = sqrt(distb+tmp2*tmp2);				
			
			if (dista+distb <  cover[k].width) {
				cid[ccount] =k;
				ccount++;
				dista = sqrt(dista);
				distb = sqrt(distb);
				pix[0 + 2*ccount] = dista + distb;
				pix[1 + 2*ccount] = dista - distb;
				
				// solving for inellipse dist difference!, putting the closest point in pix[], and the distance 
				
				
				
				
				tmp = sqrt(tmp) / (2.0f * focaldist[k]);

			}
			
			if (ccount == 2) break;
		}
		
		if (ccount == 0) {
			cid[0] =-1;cid[1] =-1;
			
			if (worthdist< source(coor)[0]){
				worthdist = source(coor)[0];
				worstpt[0] = coor[0];
				worstpt[1] = coor[1];
			}
		}else{
			if (ccount == 1) {
			cid[1] =-1;
				

				
				
			}else{
			
				
				
			}
		}
		label(coor) = cid;		
		
	}
	
	return(worthdist);

}


void Madstructs::CellCover::findCellCover(LFHPrimitive::DataGrid<LFHPrimitive::Tuple<double,3>,2 >& source, double minradii){
	bool found;
	int nbc;
	int i,j;
	int maxcell =4;

	double expc;
	LFHPrimitive::DataGrid<LFHPrimitive::Tuple<int,2>,2 > labels;
	labels.setSizes(source.dims);
	LFHPrimitive::Tuple<int,2> worstpt;
	
	for(nbc=0;nbc<maxcell;nbc++){
		cover.push_back(Madstructs::CellPose());

		expc = EllipseClusterLabel(source,labels,worstpt);
		if (expc  < minradii) {cover.pop_back();nbc--;break;}  //assumes at least 1 cell exists
		cover[nbc].width = expc * 2;
		cover[nbc].eccentric[0] = cover[nbc].width/25.0f; // eccentricity vector
		cover[nbc].eccentric[1] = 0.0f;
		cover[nbc].center[0] = (double)worstpt[0]; // eccentricity vector
		cover[nbc].center[1] = (double)worstpt[1];
		
		
		for(i=0;i<20+3*nbc;i++){

			EllipseClusterLabel(source,labels,worstpt);
	//		cellUpdate3(source,&label, 0.35);
			//	cellUpdate2(source,&label, expc,0.05,0.1f);
		}
		found = false;
		for(j=0;j<=nbc;j++) found |= cover[j].width < 0;
		for(j=0;j<=nbc;j++) found |= (14 >  sqrt(cover[j].width * cover[j].width - 4*cover[j].eccentric[0]*cover[j].eccentric[0] - 4*cover[j].eccentric[1]*cover[j].eccentric[1]));
		if (found){
			for(i=0;i<30+5*nbc;i++){
				EllipseClusterLabel(source,labels,worstpt);
		//		cellUpdate3(source,&label, 0.35);
				//			cellUpdate2(source,&label, expc,0.05,0.2f);
			}
			found = false;
			for(j=0;j<=nbc;j++) found |= cover[j].width < 0;
			
			for(j=0;j<=nbc;j++) found |= (6 >  sqrt(cover[j].width * cover[j].width - 4 *cover[j].eccentric[0]*cover[j].eccentric[0] - 4 *cover[j].eccentric[1]*cover[j].eccentric[1]));
			if (found) {
				for(j=0;j<cover.size();j++){
					if  ((cover[j].width < 0)||(10 >  sqrt(cover[j].width*cover[j].width - 4*cover[j].eccentric[0]*cover[j].eccentric[0] - 4*cover[j].eccentric[1]*cover[j].eccentric[1]))){
						cover[j] = cover[cover.size()-1];
						cover.pop_back();
						j--;
						nbc--;
					}
				}
			}		
		}
		if (nbc == maxcell) break;
		if (found) break;
	}
	if ((nbc <= maxcell)&&(nbc>=0)){



		for(i=0;i<30+5*nbc;i++){

			EllipseClusterLabel(source,labels,worstpt);

			//		cellUpdate2(source,&label, expc,0.05,0.5f);
		}
	}

	//	printf("%i cells found\n",nbc+1);
}*/


bool Madstructs::CellCover::isValid(){
	int i;
	
	for(i=0;i<cover.size();i++){
		if (!LFHPrimitive::ExCo<double>::isValid(cover[i].width)) break;
		if (!LFHPrimitive::ExCo<double>::isValid(cover[i].center[0])) break;
		if (!LFHPrimitive::ExCo<double>::isValid(cover[i].center[1])) break;
		if (!LFHPrimitive::ExCo<double>::isValid(cover[i].error[0])) break;
		if (!LFHPrimitive::ExCo<double>::isValid(cover[i].error[1])) break;
		if (!LFHPrimitive::ExCo<double>::isValid(cover[i].eccentric[0])) break;
		if (!LFHPrimitive::ExCo<double>::isValid(cover[i].eccentric[1])) break;
	}
	return(i ==  cover.size());

}



Madstructs::Image<double>* Madstructs::CellCover::makeVectField(){
	Madstructs::Image<double>* vecf = new Madstructs::Image<double>();
	vecf->sizex = rect[2]- rect[0] +1;
	vecf->sizey = rect[3]- rect[1] +1;
	vecf->channels = 3;
	vecf->allocateBuffer();
	return(vecf); 
}

Madstructs::Image<double>* Madstructs::CellCover::makeVectField(double otherval){
	Madstructs::Image<double>* vecf = new Madstructs::Image<double>();
	vecf->sizex = rect[2]- rect[0] +1;
	vecf->sizey = rect[3]- rect[1] +1;
	vecf->channels = 4;
	vecf->allocateBuffer();
	int x,y;
	for(y=0;y<vecf->sizey;y++) for(x=0;x<vecf->sizex;x++) vecf->data[3 + 4*(x + y*vecf->sizex)] = otherval;
	return(vecf); 
}

void Madstructs::CellCover::fillVectField(Madstructs::Image<double> *vecf){
	// assumes there is 1 or 2 cells;
	double matrix[6];
	
	if (cover.size() == 2){
	if (cover[0].width < cover[1].width){
		Madstructs::CellPose tmppose = cover[0];
		cover[0] =cover[1];
		cover[1] = tmppose;
	}
	double jpos[2];
	jpos[0] = (cover[0].width * cover[1].center[0] + cover[1].width * cover[0].center[0]) / (cover[1].width + cover[0].width);
	jpos[1] = (cover[0].width * cover[1].center[1] + cover[1].width * cover[0].center[1]) / (cover[1].width + cover[0].width);
	// find the jonction pt;

	matrix[0] = cover[1].center[0] - cover[0].center[0];
	matrix[1] = cover[1].center[1] - cover[0].center[1];
		
	/*matrix[0] = cover[1].center[0] - cover[0].center[0];
	matrix[1] = cover[1].center[1] - cover[0].center[1];

	matrix[4] = 1.1f * (cover[1].width + cover[0].width) * sqrt(matrix[0]*matrix[0] + matrix[1]*matrix[1]);*/
	matrix[4] = 2.2f *cover[0].width * sqrt(matrix[0]*matrix[0] + matrix[1]*matrix[1]);
	matrix[0] /= -matrix[4];
	matrix[1] /= -matrix[4];
	matrix[2] = matrix[1];
	matrix[3] = -matrix[0];
	
		//matrix[4] = cover[1].width / (cover[1].width + cover[0].width) - jpos[0] * matrix[0] - jpos[1] * matrix[2];
	matrix[4] = 0.5f - jpos[0] * matrix[0] - jpos[1] * matrix[2];
	matrix[5] = 0.5f - jpos[0] * matrix[1] - jpos[1] * matrix[3];	
	}else{
		matrix[0] = 1.0f / (2.2f * cover[0].width);
		matrix[1] = 0.0f;
		matrix[2] = 0.0f;
		matrix[3] = 1.0f / (2.2f * cover[0].width);
		matrix[4] = 0.75f - cover[0].center[0] * matrix[0] - cover[0].center[1] * matrix[2];
		matrix[5] = 0.5f - cover[0].center[0] * matrix[1] - cover[0].center[1] * matrix[3];	
	}
	double pix[16];
	int x,y;
	for(y=0;y<vecf->sizey;y++){
		for(x=0;x<vecf->sizex;x++){
			pix[0] = 0;
			pix[1] = x * matrix[0] + y * matrix[2] + matrix[4];
			pix[2] = x * matrix[1] + y * matrix[3] + matrix[5];
			vecf->setPixel(x,y,pix);
		}
	}
}

Madstructs::Transformed* Madstructs::CellCover::genTransposer(){
	Madstructs::Transformed* out = new Madstructs::Transformed(2,4);
	
	out->input_matrix[4] = rect[0];
	out->input_matrix[5] = rect[1];
	out->intrivial = false;
	
	return(out);
}

Madstructs::Transformed* Madstructs::CellCover::genTransformation(int modelsize){
	Madstructs::Transformed* out = new Madstructs::Transformed(3,7);
	double depth;
	out->intrivial = false;
	out->input_matrix[2] =0.0f;
	out->input_matrix[5] =0.0f;

	out->input_matrix[6] =0.0f;
	out->input_matrix[7] =0.0f;

	out->input_matrix[8] =1.0f;
	
	
	
	

	
	if (cover.size() == 2){
		if (cover[0].width < cover[1].width){
			Madstructs::CellPose tmppose = cover[0];
			cover[0] =cover[1];
			cover[1] = tmppose;
		}
		double jpos[2];
		jpos[0] = (cover[0].width * cover[1].center[0] + cover[1].width * cover[0].center[0]) / (cover[1].width + cover[0].width);
		jpos[1] = (cover[0].width * cover[1].center[1] + cover[1].width * cover[0].center[1]) / (cover[1].width + cover[0].width);
		// find the jonction pt;
		
		out->input_matrix[0] = cover[1].center[0] - cover[0].center[0];
		out->input_matrix[1] = cover[1].center[1] - cover[0].center[1];
		

		out->input_matrix[9] = 2.2f *cover[0].width * sqrt(out->input_matrix[0]*out->input_matrix[0] + out->input_matrix[1]*out->input_matrix[1]);
		out->input_matrix[0] /= -out->input_matrix[9];
		out->input_matrix[1] /= -out->input_matrix[9];
		out->input_matrix[0] *= (modelsize-1);
		out->input_matrix[1] *= (modelsize-1);
		out->input_matrix[3] = out->input_matrix[1];
		out->input_matrix[4] = -out->input_matrix[0];
		
		//matrix[4] = cover[1].width / (cover[1].width + cover[0].width) - jpos[0] * matrix[0] - jpos[1] * matrix[2];
		out->input_matrix[9] = ((modelsize-1)*0.5f) - jpos[0] * out->input_matrix[0] - jpos[1] * out->input_matrix[3];
		out->input_matrix[10] = ((modelsize-1)*0.5f) - jpos[0] * out->input_matrix[1] - jpos[1] * out->input_matrix[4];	
	}else{
		out->input_matrix[0] =(modelsize-1) / (2.2f * cover[0].width);
		out->input_matrix[1] = 0.0f;
		out->input_matrix[3] = 0.0f;
		out->input_matrix[4] = (modelsize-1) / (2.2f * cover[0].width);
		out->input_matrix[9] = ((modelsize-1)*0.75f) - cover[0].center[0] * out->input_matrix[0] - cover[0].center[1] * out->input_matrix[3];
		out->input_matrix[10] = ((modelsize-1)*0.5f) - cover[0].center[0] * out->input_matrix[1] - cover[0].center[1] * out->input_matrix[4];	
	}
	
	
	if (cover.size() == 1) {depth = (cover[0].width - 23)*(cover[0].width - 23) / (124.0f*16.0f);
		if (cover[0].width > 80) depth =-1.0f;
		if (cover[0].width < 23) depth =-1.0f;
		if (depth < 0.0f) depth = -1.0f;
	}
	else {
		depth = cover[0].width / cover[1].width;
		if ((cover[0].width < 25)&&(cover[1].width < 25)) depth =-1.0f;
		else if ((cover[0].width > 80)||(cover[1].width > 80)) depth =-1.0f;
		else if (depth > 1.0f) depth = 0.25f + 1.75 * 0.75f / (depth * depth* depth);
		else depth = 0.25f + 1.5 * 0.75f * depth * depth* depth;
		if (depth > 1.0f) depth = -1.0f;
	}
	
	if (depth == -1) out->input_matrix[11] = -1.0f;
	else out->input_matrix[11] = (modelsize-1)  *depth;
	
	return(out);
}

Madstructs::Transformed* Madstructs::CellCover::genTransformation(int modelsize, int which){
	Madstructs::Transformed* out = new Madstructs::Transformed(3,7);
	double depth;
	out->intrivial = false;
	out->input_matrix[2] =0.0f;
	out->input_matrix[5] =0.0f;
	
	out->input_matrix[6] =0.0f;
	out->input_matrix[7] =0.0f;
	
	out->input_matrix[8] =1.0f;
	
	
	
	
	
	
	if (cover.size() == 2){
		if (cover[0].width < cover[1].width){
			Madstructs::CellPose tmppose = cover[0];
			cover[0] =cover[1];
			cover[1] = tmppose;
		}
	//	double jpos[2];
		//jpos[0] = (cover[0].width * cover[1].center[0] + cover[1].width * cover[0].center[0]) / (cover[1].width + cover[0].width);
		//jpos[1] = (cover[0].width * cover[1].center[1] + cover[1].width * cover[0].center[1]) / (cover[1].width + cover[0].width);
		// find the jonction pt;
		
		out->input_matrix[0] = cover[1].center[0] - cover[0].center[0];
		out->input_matrix[1] = cover[1].center[1] - cover[0].center[1];
		
		
		out->input_matrix[9] = sqrt(out->input_matrix[0]*out->input_matrix[0] +out->input_matrix[1]*out->input_matrix[1]);
		out->input_matrix[0] /= -out->input_matrix[9];
		out->input_matrix[1] /= -out->input_matrix[9];
		out->input_matrix[0] *= (modelsize-1)/ 62.5f;
		out->input_matrix[1] *= (modelsize-1)/ 62.5f;
		out->input_matrix[3] = out->input_matrix[1];
		out->input_matrix[4] = -out->input_matrix[0];
		
		//matrix[4] = cover[1].width / (cover[1].width + cover[0].width) - jpos[0] * matrix[0] - jpos[1] * matrix[2];
		out->input_matrix[9] = ((modelsize-1)*(0.9f - 0.008f * cover[which].width)) - cover[which].center[0] * out->input_matrix[0] - cover[which].center[1] * out->input_matrix[3];
		out->input_matrix[10] = ((modelsize-1)*0.5f) - cover[which].center[0] * out->input_matrix[1] - cover[which].center[1] * out->input_matrix[4];	
	}else{
		out->input_matrix[0] =(modelsize-1) / 62.5f;
		out->input_matrix[1] = 0.0f;
		out->input_matrix[3] = 0.0f;
		out->input_matrix[4] = (modelsize-1) / 62.5f;
		out->input_matrix[9] = ((modelsize-1)*(0.9f - 0.008f * cover[which].width)) - cover[0].center[0] * out->input_matrix[0] - cover[0].center[1] * out->input_matrix[3];
		out->input_matrix[10] = ((modelsize-1)*0.5f) - cover[0].center[0] * out->input_matrix[1] - cover[0].center[1] * out->input_matrix[4];	
	}
	
	
	
	if (cover.size() == 1) {
		depth = cover[0].width / (55.0f);
		depth = depth*depth*depth - 0.003077385424493f;
		if (depth < 0.0f) depth = 0.0f;
		if (depth > 2.000f) depth = -1.0f;
		if (depth > 0.6f) depth = 0.6f;
	}
	else {
		depth = cover[1].width / (55.0f);
		depth = depth*depth*depth - 0.003077385424493f;
		if (depth < 0.0f) depth = 0.0f;
		//if (depth > 0.5f) depth = -1.0f;
		if (depth > 0.4f) depth = 0.4f;
		if (which == 0) depth += 0.6f;
	}
	
	
	if (depth == -1) out->input_matrix[11] = -1.0f;
	else out->input_matrix[11] = (modelsize-1)  *depth;
	
	return(out);
}

void Madstructs::CellCover::getStage(double* _out, int* otherid){

	
	
	// cell stage definition
	// 0-0.5 does not have an adjeacent cell which is smaller
	// 0.5-1.0 has an adjeacent cell which is smaller
	//
	// 0-0.5 size of that cell
	int s = cover.size();
	int* relation= new int[2*s];
	int i,j;
	double depth;
	double tmp,dist;
	for(i=0;i<s;i++){
		depth = cover[i].width / (55.0f);
		depth = depth*depth*depth - 0.003077385424493f;
		depth *= 5.0f/6.0f;
		if (depth < 0.0f) _out[i] = 0.0f;
		else if (depth > 0.5f) _out[i] = 0.5f;
		else _out[i] = depth;
	}
	for(i=0;i<s;i++){
		relation[i*2] = i;
		relation[i*2+1] = i;
		otherid[i] =-1;
		for(j=0;j<s;j++){
			if (i != j){
			tmp = cover[i].center[0] - cover[j].center[0]; dist = tmp*tmp;
			tmp = cover[i].center[1] - cover[j].center[1]; dist = sqrt(dist + tmp*tmp);
			if (cover[j].width < cover[i].width){
				if (-10.764f + (dist*2- cover[i].width- cover[j].width) * 0.989393793133530f  -0.071342869604567f*cover[j].width + 0.126531091299458f * cover[i].width< 0) {
					if (cover[j].width < cover[relation[i*2]].width) relation[i*2] = j;
				}
			}else{
			
				if (-10.764f + (dist*2- cover[i].width- cover[j].width) * 0.989393793133530f  -0.071342869604567f*cover[i].width + 0.126531091299458f * cover[j].width < 0) {
					if (cover[j].width > cover[relation[i*2+1]].width) relation[i*2+1] = j;
				}
			}
			}
			
		}

	}

	
	for(i=0;i<s;i++){
		if ((relation[i*2] != i)&&( i == relation[relation[i*2]*2+1])&&( relation[i*2] == relation[relation[i*2]*2])){
			_out[i] = _out[relation[i*2]] +0.5f;
			otherid[i] = relation[i*2];
			otherid[relation[i*2]] = i;
		}
	}
	
	
	delete[](relation);
}

void Madstructs::CellCover::getStageType(char* _out){
	
	
	
	// cell stage definition
	// 0-0.5 does not have an adjeacent cell which is smaller
	// 0.5-1.0 has an adjeacent cell which is smaller
	//
	// 0-0.5 size of that cell
	int s = cover.size();
	int* relation= new int[2*s];
	int i,j;

	double tmp,dist;

	for(i=0;i<s;i++){
		relation[i*2] = i;
		relation[i*2+1] = i;
		for(j=0;j<s;j++){
			if (i != j){
				tmp = cover[i].center[0] - cover[j].center[0]; dist = tmp*tmp;
				tmp = cover[i].center[1] - cover[j].center[1]; dist = sqrt(dist + tmp*tmp);
				if (cover[j].width < cover[i].width){
					if (-10.764f + (dist*2- cover[i].width- cover[j].width) * 0.989393793133530f  -0.071342869604567f*cover[j].width + 0.126531091299458f * cover[i].width< 0) {
						if (cover[j].width < cover[relation[i*2]].width) relation[i*2] = j;
					}
				}else{
					
					if (-10.764f + (dist*2- cover[i].width- cover[j].width) * 0.989393793133530f  -0.071342869604567f*cover[i].width + 0.126531091299458f * cover[j].width < 0) {
						if (cover[j].width > cover[relation[i*2+1]].width) relation[i*2+1] = j;
					}
				}
			}
			
		}
		
	}
	
	
	for(i=0;i<s;i++){
		if ((relation[i*2] != i)&&( i == relation[relation[i*2]*2+1])&&( relation[i*2] == relation[relation[i*2]*2])){
			_out[i] = 'm';
		}else if ((relation[i*2+1] != i)&&( i == relation[relation[i*2+1]*2])&&( relation[i*2] == i )){
			_out[i] = 'b';
		}else _out[i] = 'l';
	}
	delete[](relation);
}

void Madstructs::CellCover::showLinks(FILE* out){
	
	//0.989393793133530
	//-0.071342869604567
	//0.126531091299458

	//10.764
	

	fprintf(out,"Group size %i\n", cover.size());
	int i,j;
	int s = cover.size();
//	int ind[3];

		
	for(i=0;i<s;i++) {fprintf(out,"%f\t",cover[i].width);}
	fprintf(out,"\n\n");
	double dist, tmp;
	double projdist;
	for(i=1;i<s;i++){
		for(j=0;j<i;j++){
			tmp = cover[i].center[0] - cover[j].center[0]; dist = tmp*tmp;
			tmp = cover[i].center[1] - cover[j].center[1]; dist = sqrt(dist + tmp*tmp);
			if (cover[j].width < cover[i].width){
				projdist = -10.764f + (dist*2- cover[i].width- cover[j].width) * 0.989393793133530f  -0.071342869604567f*cover[j].width + 0.126531091299458f * cover[i].width;
			}else{
				projdist = -10.764f + (dist*2- cover[i].width- cover[j].width) * 0.989393793133530f  -0.071342869604567f*cover[i].width + 0.126531091299458f * cover[j].width;				
			}
			if (projdist < 0) printf("XXXX\t",-projdist);
			else printf("    \t",-projdist);
		//	if (cover[i].width<cover[j].width) fprintf(out,"%f\t%f\t%f\n",dist *2 - cover[i].width- cover[j].width, cover[i].width,  cover[j].width);
		//	else fprintf(out,"%f\t%f\t%f\n",dist *2 - cover[i].width- cover[j].width, cover[j].width,  cover[i].width);

		}
		fprintf(out,"\n");
	}
	fprintf(out,"\n");
	}

double arcImpact(double x){
	if (x <=0) return(0.0f);
	double tmp = -(x*2 - sin(2*x))/6
	- 4*(cos(x/2)-1)
	- (cos((3*x)/2)-1)/18
	+ (cos((5*x)/2)-1)/6
	+ log(1 + 1.0f / sin(x/2))*(3*sin(x)-sin(3*x))/12;
	return(0.85f * tmp / M_PI);
} 
void Madstructs::CellCover::showLinksErdist(FILE* out){
	
	//0.989393793133530
	//-0.071342869604567
	//0.126531091299458
	
	//10.764
	
	
//	fprintf(out,"Group size %i\n", cover.size());
	int i,j,k;
	int s = cover.size();

	
	
//	for(i=0;i<s;i++) {fprintf(out,"%f\t",cover[i].width);}
//	fprintf(out,"\n\n");
	double dist, tmp;
	double projdist;
	
	int* nei = new int[s];
	double* preerr = new double[s*10];
	memset(nei,'\0',sizeof(int)*s);
	memset(preerr,'\0',sizeof(double)*s*10);
	double overlap;
	for(i=1;i<s;i++){
		for(j=0;j<i;j++){
			tmp = cover[i].center[0] - cover[j].center[0]; dist = tmp*tmp;
			tmp = cover[i].center[1] - cover[j].center[1]; dist = sqrt(dist + tmp*tmp);
			if (cover[j].width < cover[i].width){
				projdist = -10.764f + (dist*2- cover[i].width- cover[j].width) * 0.989393793133530f  -0.071342869604567f*cover[j].width + 0.126531091299458f * cover[i].width;
			}else{
				projdist = -10.764f + (dist*2- cover[i].width- cover[j].width) * 0.989393793133530f  -0.071342869604567f*cover[i].width + 0.126531091299458f * cover[j].width;				
			}
			if (projdist < 0) {
			nei[i]++;
			nei[j]++;
				projdist = (cover[i].width+ cover[j].width) + projdist;
				tmp = cover[j].width*cover[j].width - cover[i].width*cover[i].width;
				projdist += 3.5f;
				for(k=0;k<10;k++){
				overlap= (tmp - projdist*projdist)/(-2.0f*projdist*cover[i].width);
				if (fabs(overlap) <= 1.0f) preerr[i+k*s] += arcImpact(acos(overlap));
				overlap= (-tmp - projdist*projdist)/(-2.0f*projdist*cover[j].width);
				if (fabs(overlap) <= 1.0f) preerr[j+k*s] += arcImpact(acos(overlap));
					projdist += 0.1f;
				}

			}
				//printf("XXXX\t",-projdist);
			//else printf("    \t",-projdist);
			//	if (cover[i].width<cover[j].width) fprintf(out,"%f\t%f\t%f\n",dist *2 - cover[i].width- cover[j].width, cover[i].width,  cover[j].width);
			//	else fprintf(out,"%f\t%f\t%f\n",dist *2 - cover[i].width- cover[j].width, cover[j].width,  cover[i].width);
			
		}
		//fprintf(out,"\n");
	}
//	fprintf(out,"\n");
	for(i=0;i<s;i++){
		fprintf(out,"%i\t%i\t%f\t%f\t%f", s, nei[i],cover[i].width,cover[i].error[0],cover[i].error[1]);
		for(k=0;k<10;k++) fprintf(out,"\t%f", preerr[i+k*s]);
		fprintf(out,"\n");
	}
		
	delete[](nei);
	delete[](preerr);
}


void Madstructs::CellCover::showTripplets(FILE* out){
	
	//0.989393793133530
	//-0.071342869604567
	//0.126531091299458
	
	//10.764
	
	
	double dist, tmp;
//	int i,j;
	int s = cover.size();
	int ind[3];
	if (s == 3){
		if (cover[0].width < cover[1].width){
			if (cover[0].width < cover[2].width) {ind[0] =0;
				if (cover[1].width < cover[2].width) {ind[2] = 2; ind[1] =1;}
				else {ind[1] = 2; ind[2] =1;} 
			}else {ind[0] = 2;ind[1] = 0;ind[2] = 1;}
		}else{
			if (cover[1].width < cover[2].width) {ind[0] =1;
				if (cover[0].width < cover[2].width) {ind[2] = 2; ind[1] =0;}
				else {ind[1] = 2; ind[2] =0;} 
			}else {ind[0] = 2;ind[1] = 1;ind[2] = 0;}
		}
		
		fprintf(out,"%f\t%f\t%f\t", cover[ind[0]].width, cover[ind[1]].width, cover[ind[2]].width);
		tmp = cover[ind[0]].center[0] - cover[ind[1]].center[0]; dist = tmp*tmp;
		tmp = cover[ind[0]].center[1] - cover[ind[1]].center[1]; dist =  -10.764f + (sqrt(dist + tmp*tmp) *2 - cover[ind[0]].width- cover[ind[1]].width)* 0.989393793133530f -0.071342869604567f*cover[ind[0]].width + 0.126531091299458f * cover[ind[1]].width;
		fprintf(out,"%f\t",dist);
		tmp = cover[ind[0]].center[0] - cover[ind[2]].center[0]; dist = tmp*tmp;
		tmp = cover[ind[0]].center[1] - cover[ind[2]].center[1]; dist = -10.764f + (sqrt(dist + tmp*tmp) *2 - cover[ind[0]].width- cover[ind[2]].width)* 0.989393793133530f -0.071342869604567f*cover[ind[0]].width+ 0.126531091299458f * cover[ind[2]].width;
		fprintf(out,"%f\t",dist);
		tmp = cover[ind[1]].center[0] - cover[ind[2]].center[0]; dist = tmp*tmp;
		tmp = cover[ind[1]].center[1] - cover[ind[2]].center[1]; dist =  -10.764f +( sqrt(dist + tmp*tmp) *2 - cover[ind[1]].width- cover[ind[2]].width)* 0.989393793133530f -0.071342869604567f*cover[ind[1]].width + 0.126531091299458f * cover[ind[2]].width;
		fprintf(out,"%f\n",dist);
	}

}
	
void Madstructs::CellCover::save(char* path){
	FILE* f = fopen(path,"wb+");
	int i = cover.size();
	fwrite(&i,sizeof(int),1,f);
	fwrite(rect,sizeof(int),4,f);
	int j;
	for(j=0;j<i;j++){
		fwrite(cover[j].center,sizeof(double),2,f);		
		fwrite(cover[j].eccentric,sizeof(double),2,f);		
		fwrite(&(cover[j].width),sizeof(double),1,f);		
		fwrite(cover[j].error,sizeof(double),2,f);		
		fwrite(&(cover[j].area),sizeof(double),1,f);		
	}
	fclose(f);
}
void Madstructs::CellCover::load(char* path){
	FILE* f = fopen(path,"rb+");
	if (f == NULL) return;
	int i;
	fread(&i,sizeof(int),1,f);
	fread(rect,sizeof(int),4,f);
	int j;
	for(j=0;j<i;j++){
		cover.push_back(Madstructs::CellPose());
		fread(cover[j].center,sizeof(double),2,f);		
		fread(cover[j].eccentric,sizeof(double),2,f);		
		fread(&(cover[j].width),sizeof(double),1,f);
		fread(cover[j].error,sizeof(double),2,f);
		fread(&(cover[j].area),sizeof(double),1,f);
	}	
	fclose(f);
}


void Madstructs::MultiCover::save(FILE* f){

	int k = group.size();
	fwrite(&k,sizeof(int),1,f);
	for(k=0;k<group.size();k++){
		int i = group[k].cover.size();
		int j;
		fwrite(&i,sizeof(int),1,f);
		fwrite(group[k].rect,sizeof(int),4,f);
	//	fwrite(&(group[k].plate),sizeof(int),1,f);
		for(j=0;j<i;j++){
			fwrite(&(group[k].cover[j]),sizeof(Madstructs::CellPose),1,f);
		}
	}

}

void Madstructs::MultiCover::load(FILE* f){
	flush();
	if (f == NULL){
		group.clear();
		return;
	}
	int k,l,s;
	s = fread(&l,sizeof(int),1,f);
	//printf("%i to ge\n",l);
	for(k=0;k<l;k++){
		group.push_back(Madstructs::CellCover());
		int i;
		s = fread(&i,sizeof(int),1,f);
		s += fread(group[k].rect,sizeof(int),4,f);
//		s += fread(&(group[k].plate),sizeof(int),1,f);
//		printf("%i,%i,%i,%i, (%i=5)\n",group[k].rect[0],group[k].rect[1],group[k].rect[2],group[k].rect[3],s);
		if (s != 5) return;
		int j;
		for(j=0;j<i;j++){
			group[k].cover.push_back(Madstructs::CellPose());
			fread(&(group[k].cover[j]),sizeof(Madstructs::CellPose),1,f);
			//		fread(group[k].cover[j].center,sizeof(double)*2,1,f);	
			//		fread(group[k].cover[j].eccentric,sizeof(double)*2,1,f);	
			//		fread(&(group[k].cover[j].width),sizeof(double),1,f);	
		}
	}
	
}


void Madstructs::MultiCover::save(char* path){
	FILE* f = fopen(path,"wb+");
	int k = group.size();
	fwrite(&k,sizeof(int),1,f);
	for(k=0;k<group.size();k++){
	int i = group[k].cover.size();
	int j;
	fwrite(&i,sizeof(int),1,f);
	fwrite(group[k].rect,sizeof(int),4,f);
//	fwrite(&(group[k].plate),sizeof(int),1,f);
	for(j=0;j<i;j++){
		fwrite(&(group[k].cover[j]),sizeof(Madstructs::CellPose),1,f);
	}
	}
	fclose(f);	
}

void Madstructs::MultiCover::load(char* path){
	FILE* f = fopen(path,"rb+");
	if (f == NULL){
		group.clear();
		return;
	}
	int k,l,s;
	fread(&l,sizeof(int),1,f);
	for(k=0;k<l;k++){
		group.push_back(Madstructs::CellCover());
		int i;
		s = fread(&i,sizeof(int),1,f);
		s += fread(group[k].rect,sizeof(int),4,f);
	//	s += fread(&(group[k].plate),sizeof(int),1,f);
		if (s != 5) return;
		
		int j;
		for(j=0;j<i;j++){
			group[k].cover.push_back(Madstructs::CellPose());
			fread(&(group[k].cover[j]),sizeof(Madstructs::CellPose),1,f);
	//		fread(group[k].cover[j].center,sizeof(double)*2,1,f);	
	//		fread(group[k].cover[j].eccentric,sizeof(double)*2,1,f);	
	//		fread(&(group[k].cover[j].width),sizeof(double),1,f);	
		}
	}
	fclose(f);		
}

void Madstructs::MultiCover::show(FILE *f){
	fprintf(f,"Multicover file, %i groups\n", group.size());
	int k, j;
	for(k=0;k<group.size();k++){
		fprintf(f,"%i circles (%i,%i)(%i,%i)", group[k].cover.size(),group[k].rect[0],group[k].rect[1],group[k].rect[2],group[k].rect[3]);
		for(j=0;j<group[k].cover.size();j++){
			fprintf(f,"\tw=%f(%f,%f)",group[k].cover[j].width,group[k].cover[j].center[0],group[k].cover[j].center[1]);
	
		}
		fprintf(f,"\n");
	}
}

void Madstructs::MultiCover::showtable(FILE *f){
	fprintf(f,"Multicover file, %i groups\n", group.size());
	int k, j;
	for(k=0;k<group.size();k++){
//		fprintf(f,"%i circles (%i,%i)(%i,%i)", group[k].cover.size(),group[k].rect[0],group[k].rect[1],group[k].rect[2],group[k].rect[3]);
		for(j=0;j<group[k].cover.size();j++){
			fprintf(f,"%i\t%f\t%f\t%f\t%f\t%f\n",group[k].cover.size(),group[k].cover[j].width,group[k].cover[j].center[0],group[k].cover[j].center[1],group[k].cover[j].error[0],group[k].cover[j].error[1]);			
		}
//		fprintf(f,"\n");
	}
}


void Madstructs::MultiCover::filterbyerror(double threshold){
	int i,j;
	for(i=0;i<group.size();i++){
		for(j = group[i].cover.size()-1;j>=0;j--){
			if (group[i].cover[j].error[0] < threshold){
				group[i].cover[j] = group[i].cover[group[i].cover.size()-1];
				group[i].cover.pop_back();
			}
		}
	}
}


void Madstructs::MultiCover::filterbydist(double threshold){
	float PCAconsts[] = {
	0.728823119f,	-0.51476121f,	-0.451483951f,
	0.661602686f,	0.699274877f,	0.270733324f,
	0.17634837f,	-0.4960197f,	0.850215096f,
	-0.049547611f,	0.043043305f,	0.063600338f,	0.000206313294f,	0.000300399363f,	0.000392237061f};
	/*
	float PCAconsts[] = {
		0.085105952791727f,  -0.921011262212446f,  -0.380125284185689f, // error 1
		0.993608307289664f,   0.050055504788928f,   0.101177952762917f, // error 2
		-0.074158670999296f,  -0.386306486249149f,  0.919384462669157f, // predict
		0.005336976f,	0.071091069f,	0.066947753f, // means
		0.000245654f,	0.001014417f,	0.001588543f // vars
	};*/
/*
	threshold += 0.5f* log(2* M_PI * PCAconsts[12]);
	threshold += 0.5f* log(2* M_PI * PCAconsts[13]);
	threshold += 0.5f* log(2* M_PI * PCAconsts[14]);*/
	/*
	int i,j;
	for(i=0;i<group.size();i++){
		for(j = group[i].cover.size()-1;j>=0;j--){
			if (group[i].cover[j].error[0] < threshold){
				group[i].cover[j] = group[i].cover[group[i].cover.size()-1];
				group[i].cover.pop_back();
			}
		}
	}*/
	

		
		//0.989393793133530
		//-0.071342869604567
		//0.126531091299458
		
		//10.764
		
		
		//	fprintf(out,"Group size %i\n", cover.size());
		int i,j,k;
		int s;

		
		
		//	for(i=0;i<s;i++) {fprintf(out,"%f\t",cover[i].width);}
		//	fprintf(out,"\n\n");
		double dist, tmp;
		double projdist;
		
		int* nei = new int[256];
		double* preerr = new double[256];

		double overlap;
	bool didfilt;
	
		for(k=0;k<group.size();k++){

			do{
				didfilt = false;
		s = group[k].cover.size();
		memset(nei,'\0',sizeof(int)*s);
		memset(preerr,'\0',sizeof(double)*s);			
		for(i=1;i<s;i++){
			for(j=0;j<i;j++){
				tmp = group[k].cover[i].center[0] - group[k].cover[j].center[0]; dist = tmp*tmp;
				tmp = group[k].cover[i].center[1] - group[k].cover[j].center[1]; dist = sqrt(dist + tmp*tmp);
				if (group[k].cover[j].width < group[k].cover[i].width){
					projdist = -10.764f + (dist*2- group[k].cover[i].width- group[k].cover[j].width) * 0.989393793133530f  -0.071342869604567f*group[k].cover[j].width + 0.126531091299458f * group[k].cover[i].width;
				}else{
					projdist = -10.764f + (dist*2- group[k].cover[i].width- group[k].cover[j].width) * 0.989393793133530f  -0.071342869604567f*group[k].cover[i].width + 0.126531091299458f * group[k].cover[j].width;				
				}
				if (projdist < 0) {
					nei[i]++;
					nei[j]++;
					projdist = (group[k].cover[i].width+ group[k].cover[j].width) + projdist;
					tmp = group[k].cover[j].width*group[k].cover[j].width - group[k].cover[i].width*group[k].cover[i].width;
					projdist += 4.0f;
					
					overlap= (tmp - projdist*projdist)/(-2.0f*projdist*group[k].cover[i].width);
					if (fabs(overlap) <= 1.0f) preerr[i] += arcImpact(acos(overlap));
					overlap= (-tmp - projdist*projdist)/(-2.0f*projdist*group[k].cover[j].width);
					if (fabs(overlap) <= 1.0f) preerr[j] += arcImpact(acos(overlap));
					
				}
				//printf("XXXX\t",-projdist);
				//else printf("    \t",-projdist);
				//	if (cover[i].width<cover[j].width) fprintf(out,"%f\t%f\t%f\n",dist *2 - cover[i].width- cover[j].width, cover[i].width,  cover[j].width);
				//	else fprintf(out,"%f\t%f\t%f\n",dist *2 - cover[i].width- cover[j].width, cover[j].width,  cover[i].width);
				
			}
			//fprintf(out,"\n");
		}
		//	fprintf(out,"\n");
	double proj;
	double llikeli;
		for(i=s-1;i>=0;i--){
			llikeli =0.0f;
			for(j=0;j<3;j++){
				proj = PCAconsts[j] * group[k].cover[i].error[0] + PCAconsts[3+j] * group[k].cover[i].error[1] + PCAconsts[6+j] * preerr[i];
				proj -= PCAconsts[9+j];
		//		printf("%f\t",proj /  sqrt(PCAconsts[12+j]));
				llikeli -=  proj *proj / (2 * PCAconsts[12+j]);
			}
			
		//	printf("%f\t%f\n",llikeli, threshold);
			if (llikeli < threshold){
				group[k].cover[i] = group[k].cover[group[k].cover.size()-1];
				group[k].cover.pop_back();
				didfilt = true;
			}else{group[k].cover[i].error[1] = llikeli;}
			
	//		fprintf(out,"%i\t%i\t%f\t%f\t%f", s, nei[i],cover[i].width,cover[i].error[0],cover[i].error[1]);
//			for(k=0;k<10;k++) fprintf(out,"\t%f", preerr[i]);
//			fprintf(out,"\n");
		}
			} while(didfilt);
			
			
		}
		delete[](nei);
		delete[](preerr);
	
	
	
}



void Madstructs::MultiCover::drawCircles(Madstructs::Image<unsigned char>* where, bool ignore_conf){
	int i,j,x,y;
	Madstructs::CellPose* wh;
	where->initBlack();
	double pix[32];
	double val,tmp, tmp2, goodness;
	int rad;
	int rect[4];
	for(i=0;i<group.size();i++) for(j=0;j<group[i].cover.size();j++){
		wh = &(group[i].cover[j]);
		rad = (int)((wh->width+1) * 0.5f);
		printf("%i\t%i\t%i\t%i\n", group[i].rect[0],group[i].rect[1],group[i].rect[2],group[i].rect[3]);
		tmp2 = (wh->error[0] + 0.12f) * 2;
		tmp = wh->error[1] * 10.0f;
		goodness = exp(-tmp2*tmp2 -tmp);
		rect[0] = (int)((wh->center[0]) + 1-rad< 0 ? 0 : (wh->center[0]) + 1-rad);
		rect[1] = (int)(1-rad  +(wh->center[1]) < 0  ? 0 : 1-rad  +(wh->center[1])) ;
		rect[2] = (int)(1+rad> -(wh->center[0])+ group[i].rect[2] ?  group[i].rect[2] : 1+rad + (wh->center[0]));
		rect[3] = (int)(1+rad> -(wh->center[1])+ group[i].rect[3]  ?  group[i].rect[3]: 1+rad + (wh->center[1]));
		for(x = rect[0]; x < rect[2];x++) for(y = rect[1] ; y < rect[3];y++){
			tmp = x - (wh->center[0]) - wh->eccentric[0]; tmp2 = tmp*tmp;
			tmp = y - (wh->center[1]) - wh->eccentric[1]; val = sqrt(tmp2 + tmp*tmp);
			tmp = x - (wh->center[0]) + wh->eccentric[0]; tmp2 = tmp*tmp;
			tmp = y - (wh->center[1]) + wh->eccentric[1]; val += sqrt(tmp2 + tmp*tmp);
			val = rad / ((double)rad + fabs(val/2 - rad));
			val *= val;
			if (val > 0.01f){
				where->getPixel(x + group[i].rect[0],y+ group[i].rect[1],pix);
				pix[0] += val;

				if (pix[0] > 1.0f) pix[0] = 1.0f;
				if (pix[2] > 1.0f) pix[2] = 1.0f;
				where->setPixel(x + group[i].rect[0],y + group[i].rect[1],pix);
			}
		}
	}

}


bool Madstructs::MultiCover::getNextValid(int &i){
	i++;
	double depth;
	for(i++;i < group.size();i++){
		if (group[i].cover.size() < 3){
			if (group[i].cover.size() == 1) {depth = (group[i].cover[0].width - 23)*(group[i].cover[0].width - 23) / (124.0f*16.0f);
				if (group[i].cover[0].width > 80) depth =-1.0f;
				if (group[i].cover[0].width < 23) depth =-1.0f;
				if (depth < 0.0f) depth = -1.0f;
			}
			else {
				depth = group[i].cover[0].width / group[i].cover[1].width;
				if ((group[i].cover[0].width < 25)&&(group[i].cover[1].width < 25)) depth =-1.0f;
				else if ((group[i].cover[0].width > 80)||(group[i].cover[1].width > 80)) depth =-1.0f;
				else if (depth > 1.0f) depth = 0.25f + 1.75 * 0.75f / (depth * depth* depth);
				else depth = 0.25f + 1.5 * 0.75f * depth * depth* depth;
				if (depth > 1.0f) depth = -1.0f;
			}
			if (depth != -1){
				return(true);
			}
		}
	}
	return(false);
}


void Madstructs::MultiCover::evalCircles(Madstructs::Image<unsigned char>* where){
	int i,j,x,y;
	Madstructs::CellPose* wh;
	double pix[32];
	double val,tmp, tmp2;
	int rad;
	double good,count;
	for(i=0;i<group.size();i++) for(j=0;j<group[i].cover.size();j++){
		wh = &(group[i].cover[j]);
		rad = (int)((wh->width+1)*0.5f);
		good = 0.0f;
		count = 0.0f;
		for(x = 1-rad ; x < rad;x++) for(y = 1-rad ; y < rad;y++){
			tmp = x - wh->eccentric[0]; tmp2 = tmp*tmp;
			tmp = y - wh->eccentric[1]; val = sqrt(tmp2 + tmp*tmp);
			tmp = x + wh->eccentric[0]; tmp2 = tmp*tmp;
			tmp = y + wh->eccentric[1]; val += sqrt(tmp2 + tmp*tmp);
			val = MY_LOGISTIC_P(( 1 - val / wh->width) *-100);

			if (val > 0.01f){
				where->getPixel((unsigned int)(x + wh->center[0] + group[i].rect[0]),(unsigned int)(y + wh->center[1] + group[i].rect[1]),pix);
				count += val;
				if (pix[0] > 0.5f) good += val;
			}
		}
		if (count == 0.0f) printf("N/A\tCell(%i,%i)\n",i,j);
		else printf("%f\tCell(%i,%i)\t%f\n", good/ count,i,j, 0.785398163397448f * wh->width * sqrt(wh->width*wh->width - 4*wh->eccentric[0]*wh->eccentric[0] -4*wh->eccentric[1]*wh->eccentric[1]));
	}
}

void Madstructs::MultiCover::evalfit(FILE* f, Madstructs::Image<float>* segmented){
	int i,j,x,y;
	double pix[32];
	Madstructs::CellPose* wh;
		int rad;
	double val,tmp, tmp2;
	for(i=0;i<group.size();i++) for(j=0;j<group[i].cover.size();j++){
		wh = &(group[i].cover[j]);
		rad = (int)((wh->width+1) * 0.5f);
		for(x = 1-rad ; x < rad;x++) for(y = 1-rad ; y < rad;y++){
			tmp = x - wh->eccentric[0]; tmp2 = tmp*tmp;
			tmp = y - wh->eccentric[1]; val = sqrt(tmp2 + tmp*tmp);
			tmp = x + wh->eccentric[0]; tmp2 = tmp*tmp;
			tmp = y + wh->eccentric[1]; val += sqrt(tmp2 + tmp*tmp);
			if (val < wh->width){
			segmented->getPixel((unsigned int)(x + wh->center[0] + group[i].rect[0]),(unsigned int)(y + wh->center[1] + group[i].rect[1]),pix);
			if ((pix[0] != 1.0f)&&(pix[0] != 0.0f)){
				pix[0] = ((1.0f /  (1.0f-pix[0])) -1.0f) * 10.0f;
				fprintf(f, "%i\t%f\t%f\t%f\t%f\n",group[i].cover.size(), wh->width, pix[0]*2 + val - wh->width,  pix[0]*2, val);
			}
			}
		}
	}

}

void Madstructs::MultiCover::flush(){
	int i;
	for(i=0;i<group.size();i++) group[i].cover.clear();
	group.clear();
}

Madstructs::SuperString::SuperString(char* start){
	startlength = strlen(start);
	memcpy(buffer,start,startlength);
	chunks.push_back(startlength);
}

void Madstructs::SuperString::setChar(int pos, char value){buffer[pos+startlength] = value;}
void Madstructs::SuperString::setEnd(char* what){strcpy(buffer+startlength,what);}
char* Madstructs::SuperString::getBuffer(){return(buffer);}
void Madstructs::SuperString::digitsWrite(int value, int start , int prec){
	int i;
	for(i=0;i<prec;i++){
		buffer[startlength + start +prec -1 -i] = (char)('0' + (value %10));
		value /=10;
	}

}

void Madstructs::SuperString::push(char* str){
	int tmp = strlen(str);
	memcpy(buffer+startlength,str,tmp+1);
	startlength+= tmp;
	chunks.push_back(tmp);
}

void Madstructs::SuperString::pop(){
	int tmp = *(chunks.end()--);
	startlength-= tmp;
	buffer[startlength] = '\0';
}


Madstructs::StringList::StringList(char * path){
	f = fopen(path,"r+");
}

Madstructs::StringList::~StringList(){
	fclose(f);
}
bool Madstructs::StringList::getNext(){
	return((!feof(f))&&(fscanf(f,"%[^\n]%*c",buffer) == 1));
}
void Madstructs::StringList::reset(){
	fseek(f,SEEK_SET,0);
}

Madstructs::Anything::Anything():c(NULL){}
Madstructs::Anything::Anything(char* _c):c(_c){}
Madstructs::Anything::Anything(float _c):f(_c){}
Madstructs::Anything::Anything(double _c):d(_c){}
Madstructs::Anything::Anything(int _c):i(_c){}
Madstructs::Table::Table(int _nbcols) : nbcols(_nbcols), nbrows(0), rowformat(new char[_nbcols*2]){
	int i;
	memset( rowformat,'\0',sizeof(char)*_nbcols*2);
	for(i=0;i<_nbcols;i++) t.push_back(Madstructs::Anything());
}

Madstructs::Table::Table(const char* path){ // tabular format assumed
	FILE* f = fopen(path, "r+");
	bool gzip = false;
	char buffer[65536];
	if (f == NULL) {
		exit(1);
		strcpy(buffer,path);
		memcpy(buffer + strlen(path), ".gz", sizeof(char)*4);
		

		f = fopen(buffer, "r+");
		
		// check if a gunzip file version exists
		fprintf(stderr,"Tabular cant by found!\n"); exit(1);
	
	}
	
	char* p = buffer;
	char sep= '\t';
	char* tmp;
	nbrows = nbcols=0;
	int i;
	bool isGood = true;
	while(sep != '\n'){
		p+=2;
		fscanf(f,"%c%c%*c%s%c",p-2,p-1,p,&sep);
		t.push_back(Madstructs::Anything(Madstructs::cloneString(p)));
		nbcols++;
	}
	rowformat = new char[2*nbcols];
	memcpy(rowformat,buffer,sizeof(char)*2*nbcols);
	while(!feof(f) && isGood){
		tmp = rowformat;
		for(i=0;i<nbcols-1;i++){
			if (!(getValueFromTabular(tmp,f, '\t'))) break;
			tmp+=2;
		}
		if (i == nbcols-1){
			if (getValueFromTabular(tmp,f, '\n')) nbrows++;
		}
		
	}
	fclose(f);
}

// loads file with profile
Madstructs::Table::Table(const char* filepath, const char* predicted_format){

	char buffer[65536];	int i,j;
//	memcpy(buffer, "sed \"s/[\t\x0D]*$//\" ",sizeof(char)*17);
//	i = strlen(filepath);
//	strcpy(buffer+17, filepath);
//	memcpy(buffer+17+i, " > ./au_mp_mp",sizeof(char)*13);
//	system(buffer);
	//	FILE* f = fopen("./au_mp_mp", "r+");
		FILE* f = fopen(filepath, "r+");
	if (f == NULL) {LFHPrimitive::static_warning_handdle << LFHPrimitive::LFH_ERROR_CANT_OPEN_FILE; exit(1);}
	char sep= '\t';
	char* tmp;
	nbrows = nbcols=0;
	//printf("%s\n",buffer);

	while(sep != '\n'){
		i = fscanf(f,"%[^\t\n\r]%c",buffer,&sep);
		if (i ==0){
			i = fscanf(f,"%c",&sep);
			if (i == 0) return;
			buffer[0] = '\0';
		}
		t.push_back(Madstructs::Anything(Madstructs::cloneString(buffer)));
	//	printf("%i\t%s\n",(int)sep,buffer);
		nbcols++;
	}
//	printf("found %i collumns\n", nbcols); fflush(stdout);
	rowformat = new char[2*nbcols];
	i = strlen(predicted_format);
	memcpy(rowformat,predicted_format,sizeof(char)*i);
	if (i < 2*nbcols){
		for(j=i;j<2*nbcols;j+=2) memcpy(rowformat+j,predicted_format+i-2,sizeof(char)*2);
	}
	i= nbcols;
	while(!feof(f) && (i ==nbcols)){
		tmp = rowformat;
		for(i=0;i<nbcols-1;i++){
			if (!(getValueFromTabular(tmp,f, '\t'))) break;
			tmp+=2;
		}
		if (i == nbcols-1){
			if (getValueFromTabular(tmp,f, '\n')){ nbrows++; i =nbcols;}
		}
		
		if ((i != nbcols)&&(!feof(f))) {
			fprintf(stderr, "illegal entry found at (col=%i,row=%i) in %s!\n", i+1,nbrows+1 , filepath);
			
			
			}
	//	printf("%i row\n",nbrows);
	}
//	printf("%i fail\n",i);
	fclose(f);
//	system("rm ./au_mp_mp");
//	printf("opened %i,%i",nbcols,nbrows);
}

void Madstructs::Table::clear(){ 
	if (rowformat != NULL) {
	unsigned int i,j;
	for(i=0;i<nbcols;i++) delete[](t[i].c);

	for(i=0;i<nbcols;i++) if (rowformat[2*i] == 's'){
		for(j=1;j<=nbrows;j++)
		delete[](t[i+j*nbcols].c);
	}
	
	delete[](rowformat); rowformat = NULL;
	t.clear();
	}
	nbrows = nbcols=0; 

}

void Madstructs::Table::wiseload(const char* filepath){
	clear();
	char buffer[65536];	int i,j;
	FILE* f = fopen(filepath, "r+");
   if (f == NULL) {fprintf(stderr,"Could not open %s! (critial)\n", filepath); exit(1);}
	char sep;
	char* tmp;
	
	//printf("start!\n"); fflush(stdout);
	do{
		i = fscanf(f,"%[^\t\n\r]%c",buffer,&sep);  
		if (i ==0){
			i = fscanf(f,"%c",&sep);
			if (i == 0) return;
			sprintf(buffer, "Col%i",nbcols);
		}
		t.push_back(Madstructs::Anything(Madstructs::cloneString(buffer)));
		nbcols++;
	} while (sep != '\n');
	rowformat = new char[2*nbcols];
	int firstrow = ftell(f);
	//printf("header read!\n"); fflush(stdout);
	for(i=0;i<nbcols;i++){
		if (2 != fscanf(f,"%[^\t\n\r]%c",buffer,&sep)) break;
		for(j=0;j==' ';j++);
		if ((atof(buffer) == 0.0)&&(buffer[j] != '0')){
			rowformat[i<<1] = (buffer[1] == '\0') ? 'c' : 's';rowformat[(i<<1)|1] = ' ';
			if (strcmp(buffer, "nan") == 0) rowformat[i<<1] = 'f';
		}else{
			for(;buffer[j] !='\0';j++){
				if ((buffer[j] != '-')&&(buffer[j] != ' ')&&(( buffer[j] < '0')||(buffer[j] >'9'))) break;
				}
			rowformat[i<<1] = (buffer[j] =='\0') ? 'i' : 'f';rowformat[(i<<1)|1] = ' ';
		}
		
		}
	
	
	//printf("type guessed!\n"); fflush(stdout);
	
	if ((i != nbcols)&&(!feof(f))) {
		fprintf(stderr, "illegal entry found at (col=%i,row=%i) in %s!\n", i+1,nbrows+1 , filepath);
		return;
	}
		fseek(f,firstrow, SEEK_SET );
	
	while(!feof(f) && (i ==nbcols)){
		tmp = rowformat;
		for(i=0;i<nbcols-1;i++){
			if (!(getValueFromTabular(tmp,f, '\t'))) break;
			tmp+=2;
		}
		if (i == nbcols-1){
			if (getValueFromTabular(tmp,f, '\n')){ nbrows++; i =nbcols;}
		}
		
		if ((i != nbcols)&&(!feof(f))) {
			fprintf(stderr, "illegal entry found at (col=%i,row=%i) in %s!\n", i+1,nbrows+1 , filepath);
			
			
		}
		//	printf("%i row\n",nbrows);
	}
	//	printf("%i fail\n",i);
	fclose(f);
	//	system("rm ./au_mp_mp");
	//	printf("opened %i,%i",nbcols,nbrows);
	}

void Madstructs::Table::defineCol(int colId, char dformat[2], Madstructs::Anything label){
	memcpy(rowformat+ colId *sizeof(char)*2,dformat,sizeof(char)*2);
	t[colId] = label;
}


int Madstructs::Table::findCol(const char* colname)const{
	unsigned int i; for(i=0;i<nbcols;i++) if (strcmp(colname,t[i].c)==0) break;
	if (i == nbcols) printf(" Could not find Collunm named \"%s\"!\n",colname);
	return(i);
}
char* Madstructs::Table::colname(int col)const{return t[col].c;}

void Madstructs::Table::newRow(){
	int i;
	for(i=0;i<nbcols;i++) t.push_back(Madstructs::Anything());
	nbrows++;
}

void Madstructs::Table::setValue(int x, int y, Madstructs::Anything what){
	t[x + (y+1) *nbcols] = what;
}

Madstructs::Anything& Madstructs::Table::operator()(int x, int y) {
	return(t[x + (y+1) *nbcols]);
}


Madstructs::Anything Madstructs::Table::getValue(int x, int y){return(t[x + (y+1) *nbcols]);}
void Madstructs::Table::printHTML(char* format, vector<Madstructs::Anything>::iterator &i, FILE* f){
	switch(format[0]){
		case 's': fprintf(f,"%s", i->c);
			break; // string
		case 'f': fprintf(f,"%f", i->f);
			break; // string
		case 'd': fprintf(f,"%f", i->d);
			break; // string
		case 'i': fprintf(f,"%i", i->i);
			break; // string
		case 'c': fprintf(f,"%c", i->sc);
			break; // string
		case 'u': fprintf(f,"<a href=\"%s\">%s</a>", i->c, i->c);
			break; // string
		default:
			fprintf(f,"UnKnOwN");
	}

}

void Madstructs::Table::printTabular(char* format, vector<Madstructs::Anything>::iterator &i, FILE* f){
	switch(format[0]){
		case 'u': // url does not work
		case 's': fprintf(f,"%s", i->c);
			break; // string
		case 'f': fprintf(f,"%f", i->f);
			break; // string
		case 'd': fprintf(f,"%f", i->d);
			break; // string
		case 'i': fprintf(f,"%i", i->i);
			break; // string
		case 'c': fprintf(f,"%c", i->sc);
			break; // string
		default:
			fprintf(f,"UnKnOwN");
	}
	
}

bool Madstructs::Table::getValueFromTabular(char* format, FILE* f, char sep){
	Madstructs::Anything daread;
	char buffer[65536];
	int sc;
	char sss;
	switch(format[0]){
		case 'u': // url does not work
		case 's': sc = fscanf(f,"%[^\t\n]%c", buffer,&sss); 
			if (sc == 0) {buffer[0] ='\0'; sc = fscanf(f,"%c",&sss);}
			daread.c = Madstructs::cloneString(buffer);
	//		printf("%s\n",buffer);
			break; // string
		case 'f': sc =fscanf(f,"%[^\t\n]%c", buffer,&sss); 
	//		printf("%f\t%s\t%i\n",daread.f,buffer, sc);
			if (sc == 0) {
				daread.f = NAN; sc = fscanf(f,"%c",&sss);
			} else daread.f = atof(buffer);
			//printf("%f\t%i is read!\n",daread.f,(int)sss);
			break; // string
		case 'd': sc =fscanf(f,"%[^\t\n]%c", buffer,&sss);
			if (sc == 0) {daread.f = NAN; sc = fscanf(f,"%c",&sss);}
			else daread.d = atof(buffer);
			break; // string
		case 'i': sc = fscanf(f,"%i%c", &(daread.i),&sss);
			break; // string
		case 'c': sc = fscanf(f,"%c%c", &(daread.sc),&sss);
			break; // character
		default: sc =0;
	}
//	printf("%i=%i\n",(int)sep,(int)sss);
	if (sss == sep) t.push_back(daread);
	return(sss == sep);
}
void Madstructs::Table::makeHTML(const char* path){
	FILE* f = fopen(path,"w+");
	fprintf(f,"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\"\n\"http://www.w3.org/TR/html4/strict.dtd\">\n<html>\n<head>\n<title>sorttable</title>\n<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; charset=ISO-8859-1\">\n<script type=\"text/javascript\" src=\"sorttable.js\"></script>\n\n<style type=\"text/css\">\nth, td {\npadding: 3px !important;\n}\ntable.sortable thead {\nbackground-color:#eee;\n	color:#666666;\n		font-weight: bold;\n		cursor: default;\n		}\n		</style>\n</head>\n<body>\n");
	fprintf(f,"Yet A TABLE\n");
	fprintf(f,"<table class=\"sortable\">\n");
	int i,j;
	
	char* forpt;
	vector<Madstructs::Anything>::iterator ite = t.begin();
	fprintf(f,"<tr><th>%s", ite->c);ite++;
	
	for(i=1;i<nbcols;i++){
		fprintf(f,"</th><th>%s", ite->c);ite++;
	}
	fprintf(f,"</th></tr>\n");
	for(j=0;j<nbrows;j++){
		i=0;forpt = rowformat;
		fprintf(f,"<tr><td>");
		printHTML(forpt, ite,f); ite++; forpt+=2;
	for(i++;i<nbcols;i++){
		fprintf(f,"</td><td>");
		printHTML(forpt, ite,f); ite++; forpt+=2;
	}
	fprintf(f,"</td></tr>\n");
	}
	fprintf(f,"</table></body>\n");
	fclose(f);
}

void Madstructs::Table::makeTabular(char* path){
	FILE* f = fopen(path,"w+");
	int i,j;
	

	char* forpt;
	vector<Madstructs::Anything>::iterator ite = t.begin();
	fprintf(f,"%c%c:%s",rowformat[0],rowformat[1], ite->c);ite++;
	for(i=1;i<nbcols;i++){
		fprintf(f,"\t%c%c:%s",rowformat[i<<1],rowformat[(i<<1) | 1], ite->c);ite++;
		
	}
	fprintf(f,"\n");
	for(j=0;j<nbrows;j++){
		i=0;forpt = rowformat;
		printTabular(forpt, ite,f); ite++; forpt+=2;
		for(i++;i<nbcols;i++){
			fprintf(f,"\t");
			printTabular(forpt, ite,f); ite++; forpt+=2;
		}
		fprintf(f,"\n");
	}

	fclose(f);
}


void Madstructs::Table::genHashMap(map<string, int> &_out, int col){
	int i;
	
	for(i=0;i<nbrows;i++){
		_out[string(t[col + (i+1) *nbcols].c)] = i;
	//	printf("%s\t%i    linked\n",t[col + (i+1) *nbcols].c,i);
	}
	
	
}

int Madstructs::Table::findValue(Madstructs::Anything val, int col) const{
	int i;
	switch(rowformat[2*col]){
		case 'u':
		case 's':
		for(i=0;i<nbrows;i++){
			if (strcmp(val.c,t[col + (i+1) *nbcols].c) == 0) return(i);
		}
			return(-1);
	}
	return(-1);
}

void Madstructs::CellRecord_Twomodes::show(FILE* out){
	int i;
	fprintf(out,"%s\t",name);
	fprintf(out,"%f\t",cellstage);
	fprintf(out,"%f\t",width);
	for(i=0;i<5;i++) fprintf(out,"%f\t",intensity[i]);
	for(i=0;i<5;i++) fprintf(out,"%f\t",lowmode_intensity[i]);
	for(i=0;i<5;i++) fprintf(out,"%f\t",highmode_intensity[i]);
	fprintf(out,"%i\t",didconverge);
	for(i=0;i<4;i++) fprintf(out,"%f\t",HMMmatrix[i]);
	for(i=0;i<2;i++) fprintf(out,"%f\t",error[i]);
	fprintf(out,"%f\n",factor);
}

void Madstructs::CellRecord_Header::show(FILE* out){
	fprintf(out,"%s\t",name);
	fprintf(out,"stage=%f\t",cellstage);
	fprintf(out,"w=%f\t",width);
	fprintf(out,"conv=%i\t",didconverge);
	fprintf(out,"err =%f,%f\t",error[0],error[1]);
	fprintf(out,"q%i:%i(%i/%i)[%i]\t",quad,groupId,cellsubId,groupSize,otherId);
	fprintf(out,"fact=%f\n",factor);
	
}

void Madstructs::CellRecord_Header_Adapted::show(FILE* out){
	fprintf(out,"%s\t",name);
	fprintf(out,"stage=%f\t",cellstage);
	fprintf(out,"w=%f\t",width);
	fprintf(out,"err =%f,%f\t",error[0],error[1]);
	fprintf(out,"q%i:%i(%i/%i)[%i]\t",quad,groupId,cellsubId,groupSize,otherId);
	fprintf(out,"area=%f\n",area);
	
}

void Madstructs::CellRecord_Header_Reborn::show(FILE* out){
	fprintf(out,"%i(%i/%i)\t",cellID,groupID,otherID);
	fprintf(out,"area=%f\n",area);
	
}





void HiddenmapMake(vector<Madstructs::Image<float>* > & hiddenmap, vector<Madstructs::Image<unsigned short>* > &ima, vector<Madstructs::Image<float>* > &seg,  bool EMUP){


}

void  Madstructs::CellStageKeyFrame::show(FILE* f, unsigned int level)const{
	fprintf(f,"'%c' cell (prob=%f)!\t%f\t%f\n", type, getWeight(), size_stage, MD_stage);
}

double Madstructs::CellStageKeyFrame::getNorm(const Madstructs::CellStageKeyFrame &b) const{
	double tmp, tmp2;
	tmp2 = size_stage - b.size_stage;
	tmp =exp(-0.0000005f* tmp2*tmp2);
	printf("%f\t%f\n", tmp , tmp2);
	if ((type == 'a')||(b.type == 'a')) return(0.0f);
	if (type == b.type){
		if ((type == 'l')||(type == 'd')) return( CellProb * b.CellProb * tmp);
		else {
			tmp2 = MD_stage; - b.MD_stage;
			return(CellProb * b.CellProb *
				   ( MDprob * b.MDprob * exp(-0.0000005f* tmp2*tmp2) + (1.0f - MDprob) * (1.0f - b.MDprob) * tmp ));
		}
	}else if ((type != 'l')&&(b.type != 'l')&&(type != 'd')&&(b.type != 'd')) {
		return(CellProb * b.CellProb *
			   ((1.0f - MDprob) * (1.0f - b.MDprob) * tmp ));
	}else if (((type == 'l')||(type == 'd'))&&((b.type == 'l')||(b.type == 'd'))) return(CellProb * b.CellProb * tmp);
	else if ((type == 'l')||(type == 'd')) return(CellProb * b.CellProb * ( (1.0f - b.MDprob) * tmp ));
	else return(CellProb * b.CellProb * ( (1.0f - MDprob) * tmp ));
}

Madstructs::GenericCellLoader::GenericCellLoader(): min_size(0),max_size(1200),no_daugther(false),no_clumped(false),include_area_in_data(false),no_confidence(2.0f),no_daughter_label(false), no_lone_label(false){daprogbar.lenght = 20;}

void Madstructs::GenericCellLoader::loadProteinClassLabel(const char* proteinclass_filepath){
	myHashmap<string, unsigned int> daHclasses_names_back;
	FILE *hyper = fopen(proteinclass_filepath,"r+");
	char buffer[65536];unsigned int i;
	while(fscanf(hyper,"%[^\t\n]\t%[^\t\n]\n", buffer, buffer + 1024)  == 2){
		i = daHclasses_names_back.find(string(buffer+1024));
		if (i == 0xFFFFFFFF) {i = protein_classes_names.size(); daHclasses_names_back[string(buffer+1024)] = i; protein_classes_names.push_back(string(buffer+1024));}
		else i = daHclasses_names_back.deref(i);
		protein_class_list[string(buffer)] = i;
	}
	protein_classes_names.push_back(string("Undefined Class"));	
}

void Madstructs::GenericCellLoader::loadAllCells(const char* pathlist, const char* prefix, const char* suffix){
	FILE* f = fopen(pathlist, "r+");
	myHashmap<unsigned int, pair< Tuple<double, 0u > ,double > > dual_info;
	
	Madstructs::Table tb;
	double lone_prob;
	double class_prob;
	double size_stage;
	double cell_stage;
	unsigned int i,j,k,l;
	int dataindex[12];	
	Tuple<double, 0u > data; data.setSize(collumn_names.size());
	char buffer[65536];
	char sep;
	unsigned int prefix_length = strlen(prefix);
	unsigned int suffix_length = strlen(suffix);
	
	KeyElem< Tuple<double, 4u > , Tuple<double, 0u > > mother_buds_input; mother_buds_input.d.setSize(collumn_names.size()*2 + ((include_area_in_data) ? 1 : 0));
	KeyElem< Tuple<double, 3u > , Tuple<double, 0u > > loners_input; loners_input.d.setSize(collumn_names.size() - filter_for_lone.size() + ((include_area_in_data) ? 1 : 0));
	KeyElem< Tuple<double, 3u > , Tuple<double, 0u > > daughter_input; loners_input.d.setSize(collumn_names.size() + ((include_area_in_data) ? 1 : 0));

	while(2 == fscanf(f,"%[^\n\t\r]%c",buffer+prefix_length, &sep)){
		memcpy(buffer,prefix, prefix_length);
		i = strlen(buffer);
		j = suffix_length;
		memcpy(buffer+i,suffix, j);
		buffer[i+j] = '\0';			
		double pix[4];
		//	printf("path= %s",buffer);fflush(stdout);
		tb.wiseload(buffer);
		fscanf(f,"%[^\n]\n",buffer); // printf("tag= %s\n",buffer);fflush(stdout);
		for(i=0;buffer[i] !='\t';i++);
		buffer[i] ='\0';
		prot_name.push_back(string(buffer));// printf("name= %s\n",buffer);fflush(stdout);
		buffer[i] ='\t';
		for(i++;buffer[i] !=';';i++);
		for(j=i+1;buffer[j] !=';';j++);
		buffer[j] = '\0';
		prot_orf.push_back(string(buffer+i+1));
		buffer[j] = ';';
		i=0;dataindex[i] = tb.findCol("Cell_type");
		i=1;dataindex[i] = tb.findCol("Cell_prob");
		i=2;dataindex[i] = tb.findCol("Relation_prob");
		i=3;dataindex[i] = tb.findCol("Area");
		i=4;dataindex[i] = tb.findCol("Rel_Cell_area"); 				
		i=5;dataindex[i] = tb.findCol("CellID");  if (tb.rowformat[2*dataindex[i] ] != 'i')  {printf("missing CellID!\n");exit(1);	}	
		i=6;dataindex[i] = tb.findCol("Rel_Cell_ID");  if (tb.rowformat[2*dataindex[i] ] != 'i')  {printf("missing Rel_Cell_ID!\n");exit(1);	}	
		i=7;dataindex[i] = tb.findCol("Red_MEAN"); if (tb.rowformat[2*dataindex[i] ] != 'f')  {printf("missing Red_MEAN!\n");exit(1);	}	
		unsigned int *datacolumns = new unsigned int[collumn_names.size()];
		for(i=0;i<collumn_names.size();i++) {
			datacolumns[i] = tb.findCol(collumn_names[i]);
			if (tb.rowformat[2*datacolumns[i] ] != 'f') {printf("missing collumn \"%s\", or not floating point format!\n", collumn_names[i]);exit(1);}
		}
		
		Tuple<unsigned int, 8u> offset_input;
		offset_input[0]= mother_buds.size();
		offset_input[2]= clumped.size();
		offset_input[4]= daughters.size();
		offset_input[6]= loners.size();
		
		
		
		printf("Reading Cell Attributes for %s\n", prot_name[prot_name.size()-1].c_str() ); 
		for(i =0;i < tb.nbrows;i++){
			pix[0] = tb.getValue(dataindex[1],i).f;
			pix[0] = ExOp::isValid(pix[0]) ? ((no_confidence == 2.0f) ? pix[0] : (((no_confidence == 0.0f)||(no_confidence <= pix[0])) ? 1.0f : 0.0f) ) : 0.0f ;
			if (tb.getValue(dataindex[0],i).sc == 'a') continue;
			for(j=0,k=0;j<collumn_names.size();j++) {
			if ((k<take_log.size())&&(take_log[k] == j)) {k++;  data[j] = log(tb.getValue(datacolumns[j],i).f) * factor[j] - minus[j];} else data[j] = tb.getValue(datacolumns[j],i).f * factor[j] - minus[j];}  
			pix[1] = tb.getValue(dataindex[2],i).f;//
			pix[1] = ExOp::isValid(pix[1]) ? ((no_confidence == 2.0f) ? pix[1] : (((no_confidence == 0.0f)||(no_confidence <= pix[1])) ? 1.0f : 0.0f)) : 0.0f ;
			size_stage = pow(tb.getValue(dataindex[3],i).f / 1200.0f, 1.5f)  / 1.7f;
			if (tb.getValue(dataindex[0],i).sc == 'c'){
				lone_prob = pix[0]; class_prob = 0.0f;
			}else {
				lone_prob = pix[0] * (1 - pix[1]);class_prob =  pix[0] *  pix[1];
				if ((tb.getValue(dataindex[0],i).sc == 'm')||(tb.getValue(dataindex[0],i).sc == 'd')) cell_stage = pow(tb.getValue(dataindex[4],i).f / 1200.0f, 1.5f);
				else if (tb.getValue(dataindex[0],i).sc == 'b') cell_stage = pow(tb.getValue(dataindex[3],i).f / 1200.0f, 1.5f);
				else class_prob = 0.0f;
			}
			// DISCARDING DAUGHTER LABEL!
			if ((no_daughter_label)&&(tb.getValue(dataindex[0],i).sc == 'd')) {lone_prob += class_prob;class_prob =0.0f;} 
			if (lone_prob > 0.0f){
				for(k=0,j=0; j < collumn_names.size();j++)  {if ((k<filter_for_lone.size())&&(filter_for_lone[k] == j)) k++; else loners_input.d[j-k] = data[j];}  
				if (include_area_in_data) loners_input.d[j-k] = size_stage;
				loners_input.k[0] = lone_prob;
				loners_input.k[1] = tb.getValue(dataindex[3],i).f;
				loners_input.k[2] = tb.getValue(dataindex[7],i).f ;
				if ((ExOp::isValid(lone_prob))&&(ExOp::isValid(loners_input.d))&&(ExOp::isValid(loners_input.k[1]))){
				if ((tb.getValue(dataindex[0],i).sc == 'l')&&(!no_lone_label)) loners.push_back(loners_input);
				else clumped.push_back(loners_input);
				}
			}
			if (class_prob > 0.0f){
				if (tb.getValue(dataindex[0],i).sc == 'd') {
					for(j=0; j < collumn_names.size();j++)  loners_input.d[j] = data[j]; 
					if (include_area_in_data) loners_input.d[j] = size_stage;
					daughter_input.k[0] = lone_prob;
					daughter_input.k[1] = tb.getValue(dataindex[3],i).f;
					daughter_input.k[2] = tb.getValue(dataindex[7],i).f ;
					if ((ExOp::isValid(class_prob))&&(ExOp::isValid(daughter_input.d))&&(ExOp::isValid(daughter_input.k[1]))) daughters.push_back(daughter_input);
				}else if (tb.getValue(dataindex[0],i).sc == 'm') {
					l = dual_info.find(tb.getValue(dataindex[6],i).i);
					if (l == 0xFFFFFFFF) dual_info[tb.getValue(dataindex[5],i).i] = pair<Tuple<double, 0u>, double>(data, tb.getValue(dataindex[7],i).f);
					else{
						for(j=0;j<collumn_names.size();j++) {mother_buds_input.d[1 | (j<<1)] = data[j]; mother_buds_input.d[ (j<<1)] = dual_info.deref(l).first[j];}
						if (include_area_in_data) mother_buds_input.d[((collumn_names.size())<<1)] = cell_stage;
						mother_buds_input.k[0] = class_prob;
						mother_buds_input.k[1] = tb.getValue(dataindex[4],i).f;
						mother_buds_input.k[2] = tb.getValue(dataindex[3],i).f;
						mother_buds_input.k[3] = (tb.getValue(dataindex[7],i).f * tb.getValue(dataindex[3],i).f +   dual_info.deref(l).second * tb.getValue(dataindex[4],i).f)  / ( tb.getValue(dataindex[3],i).f + tb.getValue(dataindex[4],i).f);
						if ((ExOp::isValid(class_prob))&&(ExOp::isValid(mother_buds_input.d))&&(ExOp::isValid(mother_buds_input.k[1]))) mother_buds.push_back(mother_buds_input);	
					}
				}else {
					l = dual_info.find(tb.getValue(dataindex[6],i).i);
					if (l == 0xFFFFFFFF) dual_info[tb.getValue(dataindex[5],i).i] = pair<Tuple<double, 0u>, double>(data, tb.getValue(dataindex[7],i).f);
					else{
						for(j=0;j<collumn_names.size();j++) {mother_buds_input.d[(j<<1)] = data[j]; mother_buds_input.d[1 | (j<<1)] = dual_info.deref(l).first[j];}
						if (include_area_in_data) mother_buds_input.d[((collumn_names.size())<<1)] = cell_stage;
						mother_buds_input.k[0] = class_prob;
						mother_buds_input.k[1] = tb.getValue(dataindex[3],i).f;
						mother_buds_input.k[2] = tb.getValue(dataindex[4],i).f;
						mother_buds_input.k[3] = (tb.getValue(dataindex[7],i).f * tb.getValue(dataindex[3],i).f + dual_info.deref(l).second * tb.getValue(dataindex[4],i).f)  / ( tb.getValue(dataindex[3],i).f + tb.getValue(dataindex[4],i).f);
						if ((ExOp::isValid(class_prob))&&(ExOp::isValid(mother_buds_input.d))&&(ExOp::isValid(mother_buds_input.k[1]))) mother_buds.push_back(mother_buds_input);
					}
				}
			}
		}
		offset_input[1]= mother_buds.size();
		offset_input[3]= clumped.size();
		offset_input[5]= daughters.size();
		offset_input[7]= loners.size();
		printf("%i\t%i\t%i\t%i\n", offset_input[1] - offset_input[0],offset_input[3] - offset_input[2],offset_input[5] - offset_input[4],offset_input[7] - offset_input[6]);
		offsets.push_back(offset_input);
		dual_info.clear();

		}
	fclose(f);
	
	protein_class.setSize(prot_orf.getSize());
	if (protein_class_list.getSize() == 0){
		 protein_class.toZero();
		protein_classes_names.push_back(string("Undefined Class"));	
	}else{
		for(i=0;i<prot_orf.getSize();i++){
			j = protein_class_list.find(prot_orf[i]);
			protein_class[i] = (j == 0xFFFFFFFF) ? protein_classes_names.getSize()-1 :  protein_class_list.deref(j);
		}
	}
	
}
void Madstructs::GenericCellLoader::loadAllCells_into_bins(const char* pathlist, const char* prefix, const char* suffix){
	FILE* f = fopen(pathlist, "r+");
	myHashmap<unsigned int, pair< Tuple<double, 0u > ,double > > dual_info;
	Madstructs::Table tb;
	double lone_prob;
	double class_prob;
	double size_stage;
	double cell_stage;
	unsigned int i,j,k,l;
	int dataindex[12];	
	Tuple<double, 0u > data; data.setSize(collumn_names.size());
	char buffer[65536];
	char sep;
	unsigned int prefix_length = strlen(prefix);
	unsigned int suffix_length = strlen(suffix);
	unsigned int nb_bins = 5;
	
	
//	printf("sizes! %i,%i,%i\n", collumn_names.size()*2 + ((include_area_in_data) ? 1 : 0), collumn_names.size() - filter_for_lone.size() + ((include_area_in_data) ? 1 : 0), collumn_names.size() + ((include_area_in_data) ? 1 : 0));fflush(stdout);
	KeyElem< Tuple<double, 4u > , Tuple<double, 0u > > mother_buds_input; mother_buds_input.d.setSize(collumn_names.size()*2 + ((include_area_in_data) ? 1 : 0));
	KeyElem< Tuple<double, 3u > , Tuple<double, 0u > > loners_input; loners_input.d.setSize(collumn_names.size() - filter_for_lone.size() + ((include_area_in_data) ? 1 : 0));
	KeyElem< Tuple<double, 3u > , Tuple<double, 0u > > daughter_input; daughter_input.d.setSize(collumn_names.size() + ((include_area_in_data) ? 1 : 0));

	Tuple<GaussElem<Tuple<double> ,0u> > cell_stage_bins_input; cell_stage_bins_input.setSize(nb_bins);
	
	for(i=0;i<5;i++) cell_stage_bins_input[i].setSize(mother_buds_input.d.getSize());
	

	while(2 == fscanf(f,"%[^\n\t\r]%c",buffer+prefix_length, &sep)){
		memcpy(buffer,prefix, prefix_length);
		i = strlen(buffer);
		j = suffix_length;
		memcpy(buffer+i,suffix, j);
		buffer[i+j] = '\0';			
		double pix[4];
		//	printf("path= %s",buffer);fflush(stdout);
		tb.wiseload(buffer);
		fscanf(f,"%[^\n]\n",buffer); // printf("tag= %s\n",buffer);fflush(stdout);
		for(i=0;buffer[i] !='\t';i++);
		buffer[i] ='\0';
		prot_name.push_back(string(buffer));// printf("name= %s\n",buffer);fflush(stdout);
		buffer[i] ='\t';
		for(i++;buffer[i] !=';';i++);
		for(j=i+1;buffer[j] !=';';j++);
		buffer[j] = '\0';
		prot_orf.push_back(string(buffer+i+1));
		buffer[j] = ';';
		i=0;dataindex[i] = tb.findCol("Cell_type");
		i=1;dataindex[i] = tb.findCol("Cell_prob");
		i=2;dataindex[i] = tb.findCol("Relation_prob");
		i=3;dataindex[i] = tb.findCol("Area");
		i=4;dataindex[i] = tb.findCol("Rel_Cell_area"); 				
		i=5;dataindex[i] = tb.findCol("CellID");  if (tb.rowformat[2*dataindex[i] ] != 'i')  {printf("missing CellID!\n");exit(1);	}	
		i=6;dataindex[i] = tb.findCol("Rel_Cell_ID");  if (tb.rowformat[2*dataindex[i] ] != 'i')  {printf("missing Rel_Cell_ID!\n");exit(1);	}	
		i=7;dataindex[i] = tb.findCol("Red_MEAN"); if (tb.rowformat[2*dataindex[i] ] != 'f')  {printf("missing Red_MEAN!\n");exit(1);	}	
		unsigned int *datacolumns = new unsigned int[collumn_names.size()];
		for(i=0;i<collumn_names.size();i++) {
			datacolumns[i] = tb.findCol(collumn_names[i]);
			if (tb.rowformat[2*datacolumns[i] ] != 'f') {printf("missing collumn \"%s\", or not floating point format!\n", collumn_names[i]);exit(1);}
		}
		

		
		
		for(i =0;i < tb.nbrows;i++){
			pix[0] = tb.getValue(dataindex[1],i).f;
			pix[0] = ExOp::isValid(pix[0]) ? ((no_confidence == 2.0f) ? pix[0] : (((no_confidence == 0.0f)||(no_confidence <= pix[0])) ? 1.0f : 0.0f) ) : 0.0f ;
			if (tb.getValue(dataindex[0],i).sc == 'a') continue;
			for(j=0,k=0;j<collumn_names.size();j++) {
			if ((k<take_log.size())&&(take_log[k] == j)) {k++;  data[j] = log(tb.getValue(datacolumns[j],i).f) * factor[j] - minus[j];} else data[j] = tb.getValue(datacolumns[j],i).f * factor[j] - minus[j];}  
			pix[1] = tb.getValue(dataindex[2],i).f;//
			pix[1] = ExOp::isValid(pix[1]) ? ((no_confidence == 2.0f) ? pix[1] : (((no_confidence == 0.0f)||(no_confidence <= pix[1])) ? 1.0f : 0.0f)) : 0.0f ;
			size_stage = pow(tb.getValue(dataindex[3],i).f / 1200.0f, 1.5f)  / 1.7f;
			if (tb.getValue(dataindex[0],i).sc == 'c'){
				lone_prob = pix[0]; class_prob = 0.0f;
			}else {
				lone_prob = pix[0] * (1 - pix[1]);class_prob =  pix[0] *  pix[1];
				if ((tb.getValue(dataindex[0],i).sc == 'm')||(tb.getValue(dataindex[0],i).sc == 'd')) cell_stage = pow(tb.getValue(dataindex[4],i).f / 1200.0f, 1.5f);
				else if (tb.getValue(dataindex[0],i).sc == 'b') cell_stage = pow(tb.getValue(dataindex[3],i).f / 1200.0f, 1.5f);
				else class_prob = 0.0f;
			}
			// DISCARDING DAUGHTER LABEL!
			if ((no_daughter_label)&&(tb.getValue(dataindex[0],i).sc == 'd')) {lone_prob += class_prob;class_prob =0.0f;} 
			if (lone_prob > 0.0f){
				for(k=0,j=0; j < collumn_names.size();j++)  {if ((k<filter_for_lone.size())&&(filter_for_lone[k] == j)) k++; else loners_input.d[j-k] = data[j];}  
				if (include_area_in_data) loners_input.d[j-k] = size_stage;
				loners_input.k[0] = lone_prob;
				loners_input.k[1] = tb.getValue(dataindex[3],i).f;
				loners_input.k[2] = tb.getValue(dataindex[7],i).f ;
				if ((ExOp::isValid(lone_prob))&&(ExOp::isValid(loners_input.d))&&(ExOp::isValid(loners_input.k[1]))){
					if ((tb.getValue(dataindex[0],i).sc == 'l')&&(!no_lone_label)) loners.push_back(loners_input);
					else clumped.push_back(loners_input);
				}
			}
			if (class_prob > 0.0f){
				if (tb.getValue(dataindex[0],i).sc == 'd') {
					for(j=0; j < collumn_names.size();j++)  loners_input.d[j] = data[j]; 
					if (include_area_in_data) loners_input.d[j] = size_stage;
					daughter_input.k[0] = lone_prob;
					daughter_input.k[1] = tb.getValue(dataindex[3],i).f;
					daughter_input.k[2] = tb.getValue(dataindex[7],i).f ;
					if ((ExOp::isValid(class_prob))&&(ExOp::isValid(daughter_input.d))&&(ExOp::isValid(daughter_input.k[1]))) daughters.push_back(daughter_input);
				}else if (tb.getValue(dataindex[0],i).sc == 'm') {
					l = dual_info.find(tb.getValue(dataindex[6],i).i);
					if (l == 0xFFFFFFFF) dual_info[tb.getValue(dataindex[5],i).i] = pair<Tuple<double, 0u>, double>(data, tb.getValue(dataindex[7],i).f);
					else{
						for(j=0;j<collumn_names.size();j++) {mother_buds_input.d[1 | (j<<1)] = data[j]; mother_buds_input.d[ (j<<1)] = dual_info.deref(l).first[j];}
						if (include_area_in_data) mother_buds_input.d[((collumn_names.size())<<1)] = cell_stage;
						mother_buds_input.k[0] = class_prob;
						mother_buds_input.k[1] = tb.getValue(dataindex[4],i).f;
						mother_buds_input.k[2] = tb.getValue(dataindex[3],i).f;
						mother_buds_input.k[3] = (tb.getValue(dataindex[7],i).f * tb.getValue(dataindex[3],i).f +   dual_info.deref(l).second * tb.getValue(dataindex[4],i).f)  / ( tb.getValue(dataindex[3],i).f + tb.getValue(dataindex[4],i).f);
						if ((ExOp::isValid(class_prob))&&(ExOp::isValid(mother_buds_input.d))&&(ExOp::isValid(mother_buds_input.k[1]))) mother_buds.push_back(mother_buds_input);	
					}
				}else {
					l = dual_info.find(tb.getValue(dataindex[6],i).i);
					if (l == 0xFFFFFFFF) dual_info[tb.getValue(dataindex[5],i).i] = pair<Tuple<double, 0u>, double>(data, tb.getValue(dataindex[7],i).f);
					else{
						for(j=0;j<collumn_names.size();j++) {mother_buds_input.d[(j<<1)] = data[j]; mother_buds_input.d[1 | (j<<1)] = dual_info.deref(l).first[j];}
						if (include_area_in_data) mother_buds_input.d[((collumn_names.size())<<1)] = cell_stage;
						mother_buds_input.k[0] = class_prob;
						mother_buds_input.k[1] = tb.getValue(dataindex[3],i).f;
						mother_buds_input.k[2] = tb.getValue(dataindex[4],i).f;
						mother_buds_input.k[3] = (tb.getValue(dataindex[7],i).f * tb.getValue(dataindex[3],i).f + dual_info.deref(l).second * tb.getValue(dataindex[4],i).f)  / ( tb.getValue(dataindex[3],i).f + tb.getValue(dataindex[4],i).f);
						if ((ExOp::isValid(class_prob))&&(ExOp::isValid(mother_buds_input.d))&&(ExOp::isValid(mother_buds_input.k[1]))) mother_buds.push_back(mother_buds_input);
					}
				}
			}
		}
		dual_info.clear();
		
		// assign to bins
		ExOp::toZero(cell_stage_bins_input);
		// MB pairs
		
		for(i=0;i<mother_buds.getSize();i++){
			if (mother_buds[i].k[1] <700) j= (mother_buds[i].k[1] <390) ? 0 : 1;
			else if (mother_buds[i].k[1] <1100) j= (mother_buds[i].k[1] <940) ? 2 : 3;
			else j=4; // 600, 875,1025,1200  0.35 0.63 0.8 1.0
			cell_stage_bins_input[j] += GaussElem<Tuple<double, 0u> >(mother_buds[i].d , mother_buds[i].k[0]);
		} mother_buds.clear();
		
		/*
		for(i=0;i<mother_buds.getSize();i++){
			if (mother_buds[i].k[1]<834.919030) {
			if (mother_buds[i].k[1]<465.567414) {
			if (mother_buds[i].k[1]<268.793295) j = (mother_buds[i].k[1]<159.249779) ? ((mother_buds[i].k[1]<82.163187) ? 0: 1) : ((mother_buds[i].k[1]<217.415449) ? 2: 3);
			else j = (mother_buds[i].k[1]<368.847987) ? ((mother_buds[i].k[1]<319.307479) ? 4: 5) : ((mother_buds[i].k[1]<417.874734) ? 6: 7);
			}else{
			if (mother_buds[i].k[1]<658.532983) j = (mother_buds[i].k[1]<562.277680) ? ((mother_buds[i].k[1]<513.788237) ? 8: 9) : ((mother_buds[i].k[1]<610.787449) ? 10: 11);
			else j = (mother_buds[i].k[1]<752.348576) ? ((mother_buds[i].k[1]<705.989087) ? 12: 13) : ((mother_buds[i].k[1]<796.088247) ? 14: 15);
			}
			}else{
			if (mother_buds[i].k[1]<1058.644759) {
			if (mother_buds[i].k[1]<957.175296) j = (mother_buds[i].k[1]<901.585007) ? ((mother_buds[i].k[1]<870.485298) ? 16: 17) : ((mother_buds[i].k[1]<930.523291) ? 18: 19);
			else j = (mother_buds[i].k[1]<1007.808212) ? ((mother_buds[i].k[1]<982.785865) ? 20: 21) : ((mother_buds[i].k[1]<1032.833966) ? 22: 23);
			}else{
			if (mother_buds[i].k[1]<1187.926746) j = (mother_buds[i].k[1]<1115.129659) ? ((mother_buds[i].k[1]<1085.629135) ? 24: 25) : ((mother_buds[i].k[1]<1148.889908) ? 26: 27);
			else j = (mother_buds[i].k[1]<1307.226782) ? ((mother_buds[i].k[1]<1237.267106) ? 28: 29) : ((mother_buds[i].k[1]<1437.516805) ? 30: 31);
			}
			}
			cell_stage_bins_input[j] += GaussElem<Tuple<double, 0u> >(mother_buds[i].d , mother_buds[i].k[0]);
		} mother_buds.clear();
		*/
		
		/*
		for(i=0;i<loners.getSize();i++){
			j = (loners[i].k[1] <1100) ? 6: ((loners[i].k[1] <1700) ? 7 : 8 );
			cell_stage_bins_input[j] += GaussElem<Tuple<double, 0u> >(loners[i].d , loners[i].k[0]);
		}*/
		loners.clear();
		/*
		for(i=0;i<clumped.getSize();i++){
			j = (clumped[i].k[1] <1100) ? 6: ((clumped[i].k[1] <1700) ? 7 : 8 );
			cell_stage_bins_input[j] += GaussElem<Tuple<double, 0u> >(clumped[i].d , clumped[i].k[0]);
		}*/
		clumped.clear();
		
		/*
		for(i=0;i<daughters.getSize();i++){
			j = 5;
			cell_stage_bins_input[j] += GaussElem<Tuple<double, 0u> >(daughters[i].d , daughters[i].k[0]);
		}*/
		daughters.clear();
		
		for(i=0;i<cell_stage_bins_input.getSize();i++) if (!ExOp::isValid(cell_stage_bins_input[i].getCovariance_biased().log_determinant())) break; 
		if (i == cell_stage_bins_input.getSize()) {
			printf("Reading Cell Attributes for %s\n", prot_name[prot_name.size()-1].c_str() ); 
			cell_stage_bins.push_back(cell_stage_bins_input);
		}else{
			printf("Discarded %s, not enough Cells in bins\n", prot_name[prot_name.size()-1].c_str() ); 
			prot_name.pop_back();
			prot_orf.pop_back();
		}
	}
	fclose(f);
	
	protein_class.setSize(prot_orf.getSize());
	if (protein_class_list.getSize() == 0){
		protein_class.toZero();
		protein_classes_names.push_back(string("Undefined Class"));	
	}else{
		for(i=0;i<prot_orf.getSize();i++){
			j = protein_class_list.find(prot_orf[i]);
			protein_class[i] = (j == 0xFFFFFFFF) ? protein_classes_names.getSize()-1 :  protein_class_list.deref(j);
		}
	}
	
}
void Madstructs::GenericCellLoader::loadAllCells_into_bins_tableread(const char* pathlist, const char* prefix, const char* suffix){
	FILE* f = fopen(pathlist, "r+");
	myHashmap<unsigned int, pair< Tuple<double, 0u > ,double > > dual_info;

	double lone_prob;
	double class_prob;
	double size_stage;
	double cell_stage;
	unsigned int i,j,k,l;
	int dataindex[12];	
	Tuple<double, 0u > data; data.setSize(collumn_names.size());
	char buffer[65536];
	char sep;
	unsigned int prefix_length = strlen(prefix);
	unsigned int suffix_length = strlen(suffix);
	unsigned int nb_bins = 5;
	
	
	//	printf("sizes! %i,%i,%i\n", collumn_names.size()*2 + ((include_area_in_data) ? 1 : 0), collumn_names.size() - filter_for_lone.size() + ((include_area_in_data) ? 1 : 0), collumn_names.size() + ((include_area_in_data) ? 1 : 0));fflush(stdout);
	KeyElem< Tuple<double, 4u > , Tuple<double, 0u > > mother_buds_input; mother_buds_input.d.setSize(collumn_names.size()*2 + ((include_area_in_data) ? 1 : 0));
	KeyElem< Tuple<double, 3u > , Tuple<double, 0u > > loners_input; loners_input.d.setSize(collumn_names.size() - filter_for_lone.size() + ((include_area_in_data) ? 1 : 0));
	KeyElem< Tuple<double, 3u > , Tuple<double, 0u > > daughter_input; daughter_input.d.setSize(collumn_names.size() + ((include_area_in_data) ? 1 : 0));
	
	Tuple<GaussElem<Tuple<double> ,0u> > cell_stage_bins_input; cell_stage_bins_input.setSize(nb_bins);
	
	for(i=0;i<5;i++) cell_stage_bins_input[i].setSize(mother_buds_input.d.getSize());
	
	
	Vector<const char*> table_needed_collumns;
	
	table_needed_collumns.push_back("Cell_type");
	table_needed_collumns.push_back("Cell_prob");
	table_needed_collumns.push_back("Relation_prob");
	table_needed_collumns.push_back("Area");
	table_needed_collumns.push_back("Rel_Cell_area");
	table_needed_collumns.push_back("CellID");
	table_needed_collumns.push_back("Rel_Cell_ID");
	table_needed_collumns.push_back("Red_MEAN");
	for(i=0;i<collumn_names.size();i++) table_needed_collumns.push_back(collumn_names[i]);
	
	
	
	while(2 == fscanf(f,"%[^\n\t\r]%c",buffer+prefix_length, &sep)){
		memcpy(buffer,prefix, prefix_length);
		i = strlen(buffer);
		j = suffix_length;
		memcpy(buffer+i,suffix, j);
		buffer[i+j] = '\0';			
		double pix[4];
		//	printf("path= %s",buffer);fflush(stdout);
		TableReader tr(buffer, table_needed_collumns);
		
		
		fscanf(f,"%[^\n]\n",buffer); // printf("tag= %s\n",buffer);fflush(stdout);
		for(i=0;buffer[i] !='\t';i++);
		buffer[i] ='\0';
		prot_name.push_back(string(buffer));// printf("name= %s\n",buffer);fflush(stdout);
		buffer[i] ='\t';
		for(i++;buffer[i] !=';';i++);
		for(j=i+1;buffer[j] !=';';j++);
		buffer[j] = '\0';
		prot_orf.push_back(string(buffer+i+1));
		buffer[j] = ';';
		while(tr.nextRow()){//printf("read!\n"); fflush(stdout);
			pix[0] = cleveratof(tr[1]);
			pix[0] = ExOp::isValid(pix[0]) ? ((no_confidence == 2.0f) ? pix[0] : (((no_confidence == 0.0f)||(no_confidence <= pix[0])) ? 1.0f : 0.0f) ) : 0.0f ;
			if (tr[0][0] == 'a') continue;
			for(j=0,k=0;j<collumn_names.size();j++) {
			if ((k<take_log.size())&&(take_log[k] == j)) {k++;  data[j] = log(cleveratof(tr[8+j])) * factor[j] - minus[j];} else data[j] = cleveratof(tr[8+j]) * factor[j] - minus[j];}  
			pix[1] = cleveratof(tr[2]);//
			pix[1] = ExOp::isValid(pix[1]) ? ((no_confidence == 2.0f) ? pix[1] : (((no_confidence == 0.0f)||(no_confidence <= pix[1])) ? 1.0f : 0.0f)) : 0.0f ;
			size_stage = pow(cleveratof(tr[3]) / 1200.0f, 1.5f)  / 1.7f;
			if (tr[0][0] == 'c'){
				lone_prob = pix[0]; class_prob = 0.0f;
			}else {
				lone_prob = pix[0] * (1 - pix[1]);class_prob =  pix[0] *  pix[1];
				if ((tr[0][0] == 'm')||(tr[0][0] == 'd')) cell_stage = pow(cleveratof(tr[4]) / 1200.0f, 1.5f);
				else if (tr[0][0] == 'b') cell_stage = pow(cleveratof(tr[3]) / 1200.0f, 1.5f);
				else class_prob = 0.0f;
			}
			// DISCARDING DAUGHTER LABEL!
			if ((no_daughter_label)&&(tr[0][0] == 'd')) {lone_prob += class_prob;class_prob =0.0f;} 
			if (lone_prob > 0.0f){
				for(k=0,j=0; j < collumn_names.size();j++)  {if ((k<filter_for_lone.size())&&(filter_for_lone[k] == j)) k++; else loners_input.d[j-k] = data[j];}  
				if (include_area_in_data) loners_input.d[j-k] = size_stage;
				loners_input.k[0] = lone_prob;
				loners_input.k[1] = cleveratof(tr[3]);
				loners_input.k[2] = cleveratof(tr[7]) ;
				if ((ExOp::isValid(lone_prob))&&(ExOp::isValid(loners_input.d))&&(ExOp::isValid(loners_input.k[1]))){
					if ((tr[0][0] == 'l')&&(!no_lone_label)) loners.push_back(loners_input);
					else clumped.push_back(loners_input);
				}
			}
			if (class_prob > 0.0f){
				if (tr[0][0] == 'd') {
					for(j=0; j < collumn_names.size();j++)  loners_input.d[j] = data[j]; 
					if (include_area_in_data) loners_input.d[j] = size_stage;
					daughter_input.k[0] = lone_prob;
					daughter_input.k[1] = cleveratof(tr[3]);
					daughter_input.k[2] = cleveratof(tr[7]);
					if ((ExOp::isValid(class_prob))&&(ExOp::isValid(daughter_input.d))&&(ExOp::isValid(daughter_input.k[1]))) daughters.push_back(daughter_input);
				}else if (tr[0][0] == 'm') {
					l = dual_info.find(atoi(tr[6]));
					if (l == 0xFFFFFFFF) dual_info[atoi(tr[5])] = pair<Tuple<double, 0u>, double>(data, cleveratof(tr[7]));
					else{
						for(j=0;j<collumn_names.size();j++) {mother_buds_input.d[1 | (j<<1)] = data[j]; mother_buds_input.d[ (j<<1)] = dual_info.deref(l).first[j];}
						if (include_area_in_data) mother_buds_input.d[((collumn_names.size())<<1)] = cell_stage;
						mother_buds_input.k[0] = class_prob;
						mother_buds_input.k[1] = cleveratof(tr[4]);
						mother_buds_input.k[2] = cleveratof(tr[3]);
						mother_buds_input.k[3] = (cleveratof(tr[7]) * cleveratof(tr[3]) +   dual_info.deref(l).second * cleveratof(tr[4]))  / ( cleveratof(tr[3]) + cleveratof(tr[4]));
						if ((ExOp::isValid(class_prob))&&(ExOp::isValid(mother_buds_input.d))&&(ExOp::isValid(mother_buds_input.k[1]))) mother_buds.push_back(mother_buds_input);	
					}
				}else {
					l = dual_info.find(atoi(tr[6]));
					if (l == 0xFFFFFFFF) dual_info[atoi(tr[5])] = pair<Tuple<double, 0u>, double>(data, cleveratof(tr[7]));
					else{
						for(j=0;j<collumn_names.size();j++) {mother_buds_input.d[(j<<1)] = data[j]; mother_buds_input.d[1 | (j<<1)] = dual_info.deref(l).first[j];}
						if (include_area_in_data) mother_buds_input.d[((collumn_names.size())<<1)] = cell_stage;
						mother_buds_input.k[0] = class_prob;
						mother_buds_input.k[1] = cleveratof(tr[3]);
						mother_buds_input.k[2] = cleveratof(tr[4]);
						mother_buds_input.k[3] = (cleveratof(tr[7]) * cleveratof(tr[3]) + dual_info.deref(l).second * cleveratof(tr[4]))  / ( cleveratof(tr[3]) + cleveratof(tr[4]));
						if ((ExOp::isValid(class_prob))&&(ExOp::isValid(mother_buds_input.d))&&(ExOp::isValid(mother_buds_input.k[1]))) mother_buds.push_back(mother_buds_input);
					}
				}
			}
		}
		dual_info.clear();
		
		// assign to bins
		ExOp::toZero(cell_stage_bins_input);
		// MB pairs
		
		for(i=0;i<mother_buds.getSize();i++){
			if (mother_buds[i].k[1] <700) j= (mother_buds[i].k[1] <390) ? 0 : 1;
			else if (mother_buds[i].k[1] <1100) j= (mother_buds[i].k[1] <940) ? 2 : 3;
			else j=4; // 600, 875,1025,1200  0.35 0.63 0.8 1.0
			cell_stage_bins_input[j] += GaussElem<Tuple<double, 0u> >(mother_buds[i].d , mother_buds[i].k[0]);
		} mother_buds.clear();
		
		/*
		 for(i=0;i<mother_buds.getSize();i++){
		 if (mother_buds[i].k[1]<834.919030) {
		 if (mother_buds[i].k[1]<465.567414) {
		 if (mother_buds[i].k[1]<268.793295) j = (mother_buds[i].k[1]<159.249779) ? ((mother_buds[i].k[1]<82.163187) ? 0: 1) : ((mother_buds[i].k[1]<217.415449) ? 2: 3);
		 else j = (mother_buds[i].k[1]<368.847987) ? ((mother_buds[i].k[1]<319.307479) ? 4: 5) : ((mother_buds[i].k[1]<417.874734) ? 6: 7);
		 }else{
		 if (mother_buds[i].k[1]<658.532983) j = (mother_buds[i].k[1]<562.277680) ? ((mother_buds[i].k[1]<513.788237) ? 8: 9) : ((mother_buds[i].k[1]<610.787449) ? 10: 11);
		 else j = (mother_buds[i].k[1]<752.348576) ? ((mother_buds[i].k[1]<705.989087) ? 12: 13) : ((mother_buds[i].k[1]<796.088247) ? 14: 15);
		 }
		 }else{
		 if (mother_buds[i].k[1]<1058.644759) {
		 if (mother_buds[i].k[1]<957.175296) j = (mother_buds[i].k[1]<901.585007) ? ((mother_buds[i].k[1]<870.485298) ? 16: 17) : ((mother_buds[i].k[1]<930.523291) ? 18: 19);
		 else j = (mother_buds[i].k[1]<1007.808212) ? ((mother_buds[i].k[1]<982.785865) ? 20: 21) : ((mother_buds[i].k[1]<1032.833966) ? 22: 23);
		 }else{
		 if (mother_buds[i].k[1]<1187.926746) j = (mother_buds[i].k[1]<1115.129659) ? ((mother_buds[i].k[1]<1085.629135) ? 24: 25) : ((mother_buds[i].k[1]<1148.889908) ? 26: 27);
		 else j = (mother_buds[i].k[1]<1307.226782) ? ((mother_buds[i].k[1]<1237.267106) ? 28: 29) : ((mother_buds[i].k[1]<1437.516805) ? 30: 31);
		 }
		 }
		 cell_stage_bins_input[j] += GaussElem<Tuple<double, 0u> >(mother_buds[i].d , mother_buds[i].k[0]);
		 } mother_buds.clear();
		 */
		
		/*
		 for(i=0;i<loners.getSize();i++){
		 j = (loners[i].k[1] <1100) ? 6: ((loners[i].k[1] <1700) ? 7 : 8 );
		 cell_stage_bins_input[j] += GaussElem<Tuple<double, 0u> >(loners[i].d , loners[i].k[0]);
		 }*/
		loners.clear();
		/*
		 for(i=0;i<clumped.getSize();i++){
		 j = (clumped[i].k[1] <1100) ? 6: ((clumped[i].k[1] <1700) ? 7 : 8 );
		 cell_stage_bins_input[j] += GaussElem<Tuple<double, 0u> >(clumped[i].d , clumped[i].k[0]);
		 }*/
		clumped.clear();
		
		/*
		 for(i=0;i<daughters.getSize();i++){
		 j = 5;
		 cell_stage_bins_input[j] += GaussElem<Tuple<double, 0u> >(daughters[i].d , daughters[i].k[0]);
		 }*/
		daughters.clear();
		
		for(i=0;i<cell_stage_bins_input.getSize();i++) if (!ExOp::isValid(cell_stage_bins_input[i].getCovariance_biased().log_determinant())) break; 
		if (i == cell_stage_bins_input.getSize()) {
			printf("Reading Cell Attributes for %s\n", prot_name[prot_name.size()-1].c_str() ); 
			cell_stage_bins.push_back(cell_stage_bins_input);
		}else{
			printf("Discarded %s, not enough Cells in bins\n", prot_name[prot_name.size()-1].c_str() ); 
			prot_name.pop_back();
			prot_orf.pop_back();
		} //fflush(stdout);
	}
	fclose(f);
	
	protein_class.setSize(prot_orf.getSize());
	if (protein_class_list.getSize() == 0){
		protein_class.toZero();
		protein_classes_names.push_back(string("Undefined Class"));	
	}else{
		for(i=0;i<prot_orf.getSize();i++){
			j = protein_class_list.find(prot_orf[i]);
			protein_class[i] = (j == 0xFFFFFFFF) ? protein_classes_names.getSize()-1 :  protein_class_list.deref(j);
		}
	}
	
}
void Madstructs::GenericCellLoader::reportN_in_bins() const{
	unsigned int i,j;
	for(i=0;i<cell_stage_bins.getSize();i++){
		printf("%s", prot_orf[i].c_str());
		for(j=0;j<cell_stage_bins[i].getSize();j++){
			printf("\t%f", cell_stage_bins[i][j].getN());
		}
		printf("\n");
	}
}

#ifdef GNU_SCIENTIFIC_LIBRARY
Vector< KeyElem<double, Tuple<unsigned int, 2u> > > Madstructs::GenericCellLoader::LRTestAllpairs(int which_test, int minimum_nbcell, bool MB_label,bool C_label,bool D_label,bool L_label) const{
	Vector< KeyElem<double, Tuple< unsigned int, 2> > > fout;
	
	Vector< Tuple<GaussElem< Tuple<double>, 0u >, 4> > distributions;
	KeyElem<double, Tuple< unsigned int, 2> > fout_input;
	Tuple<GaussElem< Tuple<double>, 0u >, 4> distributions_input;
	Tuple<unsigned int, 4> cur_offset;
	double confidence_thr = 0.0f;
	for(fout_input.d[0]=1;fout_input.d[0] < prot_orf.size(); fout_input.d[0]++) {
		cur_offset = offsets[fout_input.d[0]];
		if (MB_label){
			ExOp::toZero(distributions_input[0]); 
			for(;cur_offset[0] < cur_offset[1]; cur_offset[0]++){
				if (mother_buds[cur_offset[0]].k[0] < confidence_thr) continue;
				if (distributions_input[0].w == 0.0f) distributions_input[0] = GaussElem< Tuple<double>, 0u >(mother_buds[cur_offset[0]].d);
				else distributions_input[0] += GaussElem< Tuple<double>, 0u >(mother_buds[cur_offset[0]].d);
			}
		}
		if (C_label){
			ExOp::toZero(distributions_input[1]); 
			for(;cur_offset[2] < cur_offset[3]; cur_offset[2]++){
				if (clumped[cur_offset[2]].k[0] < confidence_thr) continue;
				if (distributions_input[1].w == 0.0f) distributions_input[1] = GaussElem< Tuple<double>, 0u >(clumped[cur_offset[2]].d);
				else distributions_input[1] += GaussElem< Tuple<double>, 0u >(clumped[cur_offset[2]].d);
				if (distributions_input[1].w == 0.0f) printf("OMG!\n");
			}
		}
		if (D_label){
			ExOp::toZero(distributions_input[2]); 
			for(;cur_offset[4] < cur_offset[5]; cur_offset[4]++){
				if (daughters[cur_offset[4]].k[0] < confidence_thr) continue;
				if (distributions_input[2].w == 0.0f) distributions_input[2] = GaussElem< Tuple<double>, 0u >(daughters[cur_offset[4]].d);
				else distributions_input[2] += GaussElem< Tuple<double>, 0u >(daughters[cur_offset[4]].d);
			}
		}
		if (L_label){
			ExOp::toZero(distributions_input[3]); 
			for(;cur_offset[6] < cur_offset[7]; cur_offset[6]++){
				if (loners[cur_offset[6]].k[0] < confidence_thr) continue;
				if (distributions_input[3].w == 0.0f) distributions_input[3] = GaussElem< Tuple<double>, 0u >(loners[cur_offset[6]].d);
				else distributions_input[3] += GaussElem< Tuple<double>, 0u >(loners[cur_offset[6]].d);
			}
		}
		
		/*
		if (MB_label){
			ExOp::toZero(distributions_input[0]); 
			for(;cur_offset[0] < cur_offset[1]; cur_offset[0]++){
				if (distributions_input[0].w == 0.0f) distributions_input[0] = GaussElem< Tuple<double>, 0u >(mother_buds[cur_offset[0]].d, mother_buds[cur_offset[0]].k[0]);
				else distributions_input[0] += GaussElem< Tuple<double>, 0u >(mother_buds[cur_offset[0]].d, mother_buds[cur_offset[0]].k[0]);
			}
		}
		if (C_label){
			ExOp::toZero(distributions_input[1]); 
			for(;cur_offset[2] < cur_offset[3]; cur_offset[2]++){
				if (distributions_input[1].w == 0.0f) distributions_input[1] = GaussElem< Tuple<double>, 0u >(clumped[cur_offset[2]].d,clumped[cur_offset[2]].k[0]);
				else distributions_input[1] += GaussElem< Tuple<double>, 0u >(clumped[cur_offset[2]].d,clumped[cur_offset[2]].k[0]);
			}
		}
		if (D_label){
			ExOp::toZero(distributions_input[2]); 
			for(;cur_offset[4] < cur_offset[5]; cur_offset[4]++){
				if (distributions_input[2].w == 0.0f) distributions_input[2] = GaussElem< Tuple<double>, 0u >(daughters[cur_offset[4]].d,daughters[cur_offset[4]].k[0]);
				else distributions_input[2] += GaussElem< Tuple<double>, 0u >(daughters[cur_offset[4]].d,daughters[cur_offset[4]].k[0]);
			}
		}
		if (L_label){
			ExOp::toZero(distributions_input[3]); 
			for(;cur_offset[6] < cur_offset[7]; cur_offset[6]++){
				if (distributions_input[3].w == 0.0f) distributions_input[3] = GaussElem< Tuple<double>, 0u >(loners[cur_offset[6]].d,loners[cur_offset[6]].k[0]);
				else distributions_input[3] += GaussElem< Tuple<double>, 0u >(loners[cur_offset[6]].d,loners[cur_offset[6]].k[0]);
			}
		}*/
		distributions.push_back(distributions_input);
	}


	double Lpvalue;
	unsigned int l;
	unsigned int nb_independent;
	for(fout_input.d[0]=1;fout_input.d[0] < prot_orf.size(); fout_input.d[0]++) {
		for(fout_input.d[1]=0;fout_input.d[1] < fout_input.d[0]; fout_input.d[1]++){
			fout_input.k = 0.0f;
			nb_independent =0;
			if ((MB_label)&&(distributions[fout_input.d[0]][0].mean.getSize() != 0)&&(distributions[fout_input.d[1]][0].mean.getSize() != 0)&&(distributions[fout_input.d[0]][0].getN() >= minimum_nbcell)&&(distributions[fout_input.d[1]][0].getN() >= minimum_nbcell)) {
				Lpvalue = (which_test == 0) ?  distributions[fout_input.d[0]][0].Pvalue_LRTest_UnequalMean(distributions[fout_input.d[1]][0], NULL,true) : (
						   (which_test == 1) ? distributions[fout_input.d[0]][0].Pvalue_LRTest_UnequalVariance(distributions[fout_input.d[1]][0],NULL, true) :	
						                       distributions[fout_input.d[0]][0].Pvalue_LRTest_UnequalMeanandVariance(distributions[fout_input.d[1]][0],NULL, true) );
				if (ExOp::isValid(Lpvalue)){fout_input.k += Lpvalue; nb_independent++;}
			}
			
			if ((C_label)&&(distributions[fout_input.d[0]][1].mean.getSize() != 0)&&(distributions[fout_input.d[1]][1].mean.getSize() != 0)&&(distributions[fout_input.d[0]][1].getN() >= minimum_nbcell)&&(distributions[fout_input.d[1]][1].getN() >= minimum_nbcell)) {
				Lpvalue = (which_test == 0) ? distributions[fout_input.d[0]][1].Pvalue_LRTest_UnequalMean(distributions[fout_input.d[1]][1], NULL,true) : (
						  (which_test == 1) ? distributions[fout_input.d[0]][1].Pvalue_LRTest_UnequalVariance(distributions[fout_input.d[1]][1], NULL,true) :	
											  distributions[fout_input.d[0]][1].Pvalue_LRTest_UnequalMeanandVariance(distributions[fout_input.d[1]][1], NULL,true) );
				if (ExOp::isValid(Lpvalue)){fout_input.k += Lpvalue; nb_independent++;}
			}
			if ((D_label)&&(distributions[fout_input.d[0]][2].mean.getSize() != 0)&&(distributions[fout_input.d[1]][2].mean.getSize() != 0)&&(distributions[fout_input.d[0]][2].getN() >= minimum_nbcell)&&(distributions[fout_input.d[1]][2].getN() >= minimum_nbcell)) {
				Lpvalue = (which_test == 0) ? distributions[fout_input.d[0]][2].Pvalue_LRTest_UnequalMean(distributions[fout_input.d[1]][2], NULL,true) : (
						  (which_test == 1) ? distributions[fout_input.d[0]][2].Pvalue_LRTest_UnequalVariance(distributions[fout_input.d[1]][2], NULL,true) :	
						                      distributions[fout_input.d[0]][2].Pvalue_LRTest_UnequalMeanandVariance(distributions[fout_input.d[1]][2], NULL,true) );
				if (ExOp::isValid(Lpvalue)){fout_input.k += Lpvalue; nb_independent++;}
			}
			
			if ((L_label)&&(distributions[fout_input.d[0]][3].mean.getSize() != 0)&&(distributions[fout_input.d[1]][3].mean.getSize() != 0)&&(distributions[fout_input.d[0]][3].getN() >= minimum_nbcell)&&(distributions[fout_input.d[1]][3].getN() >= minimum_nbcell)) {
				Lpvalue = (which_test == 0) ? distributions[fout_input.d[0]][3].Pvalue_LRTest_UnequalMean(distributions[fout_input.d[1]][3], NULL,true) : (
						  (which_test == 1) ? distributions[fout_input.d[0]][3].Pvalue_LRTest_UnequalVariance(distributions[fout_input.d[1]][3], NULL,true) :	
											  distributions[fout_input.d[0]][3].Pvalue_LRTest_UnequalMeanandVariance(distributions[fout_input.d[1]][3], NULL,true) );
				if (ExOp::isValid(Lpvalue)){fout_input.k += Lpvalue; nb_independent++;}
			}
			if (nb_independent > 1) fout_input.k = LogPvalue_SumLogPvalues_Ptail(fout_input.k, nb_independent);
			printf("%i %i push\n", fout_input.d[0] , fout_input.d[1]);
			fout.push_back(fout_input);
	}	}
	printf("okkk\n");fflush(stdout);
	return(fout);
}
Vector< KeyElem<double, Tuple<unsigned int, 2u> > > Madstructs::GenericCellLoader::HottelingTestAllpairs(double confidence_thr, int minimum_nbcell, bool MB_label,bool C_label,bool D_label,bool L_label) const{
	Vector< KeyElem<double, Tuple<unsigned int, 2> > > fout;
	
	Vector< Tuple<GaussElem< Tuple<double>, 0u >, 4> > distributions;
	KeyElem<double, Tuple<unsigned int, 2> > fout_input;
	Tuple<GaussElem< Tuple<double>, 0u >, 4> distributions_input;
	Tuple<unsigned int, 4> cur_offset;
	
	for(fout_input.d[0]=1;fout_input.d[0] < prot_orf.size(); fout_input.d[0]++) {
		cur_offset = offsets[fout_input.d[0]];
		if (MB_label){
			ExOp::toZero(distributions_input[0]); 
			for(;cur_offset[0] < cur_offset[1]; cur_offset[0]++){
				if (mother_buds[cur_offset[0]].k[0] < confidence_thr) continue;
				if (distributions_input[0].w == 0.0f) distributions_input[0] = GaussElem< Tuple<double>, 0u >(mother_buds[cur_offset[0]].d);
				else distributions_input[0] += GaussElem< Tuple<double>, 0u >(mother_buds[cur_offset[0]].d);
			}
		}
		if (C_label){
			ExOp::toZero(distributions_input[1]); 
			for(;cur_offset[2] < cur_offset[3]; cur_offset[2]++){
				if (clumped[cur_offset[2]].k[0] < confidence_thr) continue;
				if (distributions_input[1].w == 0.0f) distributions_input[1] = GaussElem< Tuple<double>, 0u >(clumped[cur_offset[2]].d);
				else distributions_input[1] += GaussElem< Tuple<double>, 0u >(clumped[cur_offset[2]].d);
				if (distributions_input[1].w == 0.0f) printf("OMG!\n");
			}
		}
		if (D_label){
			ExOp::toZero(distributions_input[2]); 
			for(;cur_offset[4] < cur_offset[5]; cur_offset[4]++){
				if (daughters[cur_offset[4]].k[0] < confidence_thr) continue;
				if (distributions_input[2].w == 0.0f) distributions_input[2] = GaussElem< Tuple<double>, 0u >(daughters[cur_offset[4]].d);
				else distributions_input[2] += GaussElem< Tuple<double>, 0u >(daughters[cur_offset[4]].d);
			}
		}
		if (L_label){
			ExOp::toZero(distributions_input[3]); 
			for(;cur_offset[6] < cur_offset[7]; cur_offset[6]++){
				if (loners[cur_offset[6]].k[0] < confidence_thr) continue;
				if (distributions_input[3].w == 0.0f) distributions_input[3] = GaussElem< Tuple<double>, 0u >(loners[cur_offset[6]].d);
				else distributions_input[3] += GaussElem< Tuple<double>, 0u >(loners[cur_offset[6]].d);
			}
		}
		
		distributions.push_back(distributions_input);
		
	}
	
	unsigned int nb_independent;

	
	for(fout_input.d[0]=1;fout_input.d[0] < prot_orf.size(); fout_input.d[0]++) {
		for(fout_input.d[1]=0;fout_input.d[1] <= fout_input.d[0]; fout_input.d[1]++){
			fout_input.k = 0.0f;
			nb_independent=0;
			
			if ((MB_label)&&(distributions[fout_input.d[0]][0].getN() >= minimum_nbcell)&&(distributions[fout_input.d[1]][0].getN() >= minimum_nbcell)) {
				fout_input.k += distributions[fout_input.d[0]][0].Pvalue_Hotelling(distributions[fout_input.d[1]][0],true); nb_independent++;
			}
			if ((C_label)&&(distributions[fout_input.d[0]][1].getN() >= minimum_nbcell)&&(distributions[fout_input.d[1]][1].getN() >= minimum_nbcell)) {
				fout_input.k += distributions[fout_input.d[0]][1].Pvalue_Hotelling(distributions[fout_input.d[1]][1],true); nb_independent++;
			}
			if ((D_label)&&(distributions[fout_input.d[0]][2].getN() >= minimum_nbcell)&&(distributions[fout_input.d[1]][2].getN() >= minimum_nbcell)) {
				fout_input.k += distributions[fout_input.d[0]][2].Pvalue_Hotelling(distributions[fout_input.d[1]][2],true); nb_independent++;
			}
			if ((L_label)&&(distributions[fout_input.d[0]][3].getN() >= minimum_nbcell)&&(distributions[fout_input.d[1]][3].getN() >= minimum_nbcell)) {
				fout_input.k += distributions[fout_input.d[0]][3].Pvalue_Hotelling(distributions[fout_input.d[1]][3],true); nb_independent++;
			}
			if (nb_independent > 1) fout_input.k = LogPvalue_SumLogPvalues_Ptail(fout_input.k, nb_independent);
			fout.push_back(fout_input);
		}	}
	return(fout);
}
Vector< KeyElem<double, Tuple<unsigned int, 2u> > > Madstructs::GenericCellLoader::LRTestAllpairs_frombins(int which_test, int minimum_nbcell, const Tuple<bool> *filter) const{
	Vector< KeyElem<double, Tuple<unsigned int, 2> > > fout;
	
	Vector< Tuple<GaussElem< Tuple<double>, 0u >, 4> > distributions;
	KeyElem<double, Tuple< unsigned int, 2> > fout_input;
	Tuple<GaussElem< Tuple<double>, 0u >, 4> distributions_input;
	Tuple<unsigned int, 4> cur_offset;
	double confidence_thr = 0.0f;

	
	
	double tmpLogPval;
	unsigned int bin_ite;
	unsigned int nb_independent;
	for(fout_input.d[0]=1;fout_input.d[0] < prot_orf.size(); fout_input.d[0]++) {
		for(fout_input.d[1]=0;fout_input.d[1] < fout_input.d[0]; fout_input.d[1]++){
			fout_input.k = 0.0f;
			nb_independent =0;
					for(bin_ite=0;bin_ite< cell_stage_bins[fout_input.d[0]].getSize();bin_ite++){
						if ((cell_stage_bins[fout_input.d[0]][bin_ite].getN() >= minimum_nbcell)&&(cell_stage_bins[fout_input.d[1]][bin_ite].getN() >= minimum_nbcell)){
							tmpLogPval = (which_test == 0) ? cell_stage_bins[fout_input.d[0]][bin_ite].Pvalue_LRTest_UnequalMean(cell_stage_bins[fout_input.d[1]][bin_ite],NULL,true) : ( (which_test == 1) ? cell_stage_bins[fout_input.d[0]][bin_ite].Pvalue_LRTest_UnequalVariance(cell_stage_bins[fout_input.d[1]][bin_ite],NULL,true) : cell_stage_bins[fout_input.d[0]][bin_ite].Pvalue_LRTest_UnequalMeanandVariance(cell_stage_bins[fout_input.d[1]][bin_ite],NULL,true) );
																																			
							if (ExOp::isValid(tmpLogPval)) {fout_input.k += tmpLogPval; nb_independent++;}
						}
					}
					if (nb_independent > 1) fout_input.k = LogPvalue_SumLogPvalues_Ptail(fout_input.k, nb_independent);
					fout.push_back(fout_input);
				}	}
	return(fout);
}
Vector< KeyElem<double, Tuple<unsigned int, 2u> > > Madstructs::GenericCellLoader::HottelingTestAllpairs_frombins(int minimum_nbcell, const Tuple<bool> *filter) const{
	Vector< KeyElem<double, Tuple< unsigned int, 2> > > fout;
	
	Vector< Tuple<GaussElem< Tuple<double>, 0u >, 4> > distributions;
	KeyElem<double, Tuple< unsigned int, 2> > fout_input;
	Tuple<GaussElem< Tuple<double>, 0u >, 4> distributions_input;
	Tuple<unsigned int, 4> cur_offset;
	unsigned int nb_independent;
	unsigned int bin_ite;
	double tmpLogPval;
	
	for(fout_input.d[0]=1;fout_input.d[0] < prot_orf.size(); fout_input.d[0]++) {
		for(fout_input.d[1]=0;fout_input.d[1] <= fout_input.d[0]; fout_input.d[1]++){
			fout_input.k = 0.0f;
			nb_independent=0;
			for(bin_ite=0;bin_ite< cell_stage_bins[fout_input.d[0]].getSize();bin_ite++){
				if ((cell_stage_bins[fout_input.d[0]][bin_ite].getN() >= minimum_nbcell)&&(cell_stage_bins[fout_input.d[1]][bin_ite].getN() >= minimum_nbcell)){
					tmpLogPval = cell_stage_bins[fout_input.d[0]][bin_ite].Pvalue_Hotelling(cell_stage_bins[fout_input.d[1]][bin_ite],true); 
					if (ExOp::isValid(tmpLogPval)) {fout_input.k += tmpLogPval; nb_independent++;}
				}
			}
			if (nb_independent > 1) fout_input.k = LogPvalue_SumLogPvalues_Ptail(fout_input.k, nb_independent);
			fout.push_back(fout_input);
		}	}
	return(fout);
}
Vector< Tuple<double, 8 > > Madstructs::GenericCellLoader::LRTestAll_frombins(int minimum_nbcell, const Tuple<bool> *bin_filter, const Tuple<bool> *channel_filter, Vector<Tuple< Tuple< double > > > *local) const{
	Vector< Tuple<double, 8 > > fout;
	
	Tuple<double, 8 > fout_input;
	
	unsigned int other_iterator,k;
	
	double tmpLogPval[8];
	unsigned int bin_ite, i;
	unsigned int nb_independent[8];
	Tuple<GaussElem<Tuple<double> ,0u> > local_profile[2];
	
	Tuple<double> mean_prof, other_mean_prof;
	Tuple<double> t_covprof[2];
	
	Weight c_weight;
	double tt;
	local_profile[0].setSize(cell_stage_bins[0].getSize());
	local_profile[1].setSize(cell_stage_bins[0].getSize());
	for(bin_ite=0,k=0;bin_ite< cell_stage_bins[0].getSize();bin_ite++) {local_profile[0][bin_ite].setSize(cell_stage_bins[0][bin_ite].mean.getSize());local_profile[1][bin_ite].setSize(cell_stage_bins[0][bin_ite].mean.getSize()); k+= cell_stage_bins[0][bin_ite].mean.getSize();}
	mean_prof.setSize(k); other_mean_prof.setSize(k);
	Tuple< Tuple<double> > query_mean;
	Tuple<double> cur_b_mean;
	if (local){local->setSize(prot_orf.size());}
	daprogbar.start("Finding Local Profiles:");
	bool noerror;
	unsigned int barsel;
	for(i=0;i < prot_orf.size(); i++) {daprogbar.update((double)i / prot_orf.size());
		noerror = true;
		ExOp::toZero(local_profile);tt=0;
		query_mean.setSize(cell_stage_bins[i].getSize()); 
		for(bin_ite=0;bin_ite< cell_stage_bins[i].getSize();bin_ite++) query_mean[bin_ite] = cell_stage_bins[i][bin_ite].getMean();
		
		for(k=0,bin_ite=0;bin_ite< cell_stage_bins[i].getSize();bin_ite++) {
			cur_b_mean = cell_stage_bins[i][bin_ite].getMean();
			for(nb_independent[0]=0;nb_independent[0]<cur_b_mean.getSize();k++) mean_prof[k] = cur_b_mean[nb_independent[0]++];
		}
		
		for(other_iterator=0;other_iterator < prot_orf.size(); other_iterator++){
			if (i == other_iterator) continue;
			if ((bandwidth.getSize() > 1)&&(protein_class[i] != protein_class[other_iterator])) continue;
			barsel = (bandwidth.getSize() > 1) ? protein_class[i] : 0;
			for(k=0,bin_ite=0;bin_ite< cell_stage_bins[other_iterator].getSize();bin_ite++) {
				cur_b_mean = cell_stage_bins[other_iterator][bin_ite].getMean();
				for(nb_independent[0]=0;nb_independent[0]<cur_b_mean.getSize();k++) other_mean_prof[k] = cur_b_mean[nb_independent[0]++] - mean_prof[k] ;
			}
			c_weight = Weight(exp(bandwidth_scale[i] * bandwidth[barsel].Xformed_inner_product_of_inverse(other_mean_prof)));
			tt += c_weight();
			if (!ExOp::isValid(c_weight())) printf("scale: %e\tband: %e\n", bandwidth_scale[i]  , c_weight());
			else{
			for(bin_ite=0;bin_ite< cell_stage_bins[other_iterator].getSize();bin_ite++) {
				local_profile[0][bin_ite] += cell_stage_bins[other_iterator][bin_ite] * c_weight;
				local_profile[1][bin_ite].addGaussElem_free_mean(cell_stage_bins[other_iterator][bin_ite] * c_weight);
			}
			}
		}
		ExOp::toZero(nb_independent);
		ExOp::toZero(fout_input);
		for(bin_ite=0;bin_ite< cell_stage_bins[i].getSize();bin_ite++){
			if ((cell_stage_bins[i][bin_ite].getN() >= minimum_nbcell)&&(local_profile[0][bin_ite].getN() >= minimum_nbcell)){
				tmpLogPval[0] = cell_stage_bins[i][bin_ite].Pvalue_LRTest_UnequalMean(local_profile[0][bin_ite],NULL,true);
				tmpLogPval[1] = cell_stage_bins[i][bin_ite].Pvalue_LRTest_UnequalVariance(local_profile[1][bin_ite],NULL,true);
				tmpLogPval[2] =	cell_stage_bins[i][bin_ite].Pvalue_LRTest_UnequalMeanandVariance(local_profile[1][bin_ite],NULL,true);
				//	printf("%i\t%i\n", cell_stage_bins[i][bin_ite].getSize(), local_profile[1][bin_ite].getSize()); fflush(stdout);
				t_covprof[0] = cell_stage_bins[i][bin_ite].getVar_biaised();
				t_covprof[1] = local_profile[1][bin_ite].getVar_biaised();
				//	printf("%i\t%i\n", mean_prof.getSize(), other_mean_prof.getSize()); fflush(stdout);
				
				tmpLogPval[4] = cell_stage_bins[i][bin_ite].getLogFoldinVariance_Diagonal(local_profile[1][bin_ite]);
				tmpLogPval[5] = log(t_covprof[0][0]) - log(t_covprof[1][0]);
				tmpLogPval[6] = log(t_covprof[0][1]) - log(t_covprof[1][1]);
				for(k=0;k<8;k++) {if (ExOp::isValid(tmpLogPval[k])) {fout_input[k] += tmpLogPval[k]; nb_independent[k]++;}else{ noerror = false;}}
			}
		}
		//LFH_ALIVE;
		for(k=0;k<3;k++) {
			if (nb_independent[k] > 1)  fout_input[k] = LogPvalue_SumLogPvalues_Ptail(fout_input[k], nb_independent[k]);
		}
		fout_input[3] = tt;
		for(k=4;k<7;k++) {
			if (nb_independent[k] > 1)  fout_input[k] /= nb_independent[k];
		}
		
		if (local){
			(*local)[i].setSize(cell_stage_bins[i].getSize());
			for(bin_ite=0;bin_ite< cell_stage_bins[i].getSize();bin_ite++) (*local)[i][bin_ite] = local_profile[0][bin_ite].getMean();
		}
		fout_input[7] = (noerror) ? 0.0f : 1.0f;
		fout.push_back(fout_input);
	}daprogbar.finish();
	return(fout);
}
/*
Vector< Tuple<double, 8 > > Madstructs::GenericCellLoader::LRTestAll_frombins_median(int minimum_nbcell, const Tuple<bool> *bin_filter, const Tuple<bool> *channel_filter, Vector<Tuple< Tuple< double > > > *local) const{
	Vector< Tuple<double, 8 > > fout;
	Tuple<double, 8 > fout_input;
	unsigned int other_iterator,k;
	
	double tmpLogPval[8];
	unsigned int bin_ite, i;
	unsigned int nb_independent[8];
	Tuple<GaussElem<Tuple<double> ,0u> > local_profile[2];
	
	Tuple<double> mean_prof, other_mean_prof;
	Tuple<double> t_covprof[2];
	
	Weight c_weight;
	double tt;
	local_profile[0].setSize(cell_stage_bins[0].getSize());
	local_profile[1].setSize(cell_stage_bins[0].getSize());
	for(bin_ite=0,k=0;bin_ite< cell_stage_bins[0].getSize();bin_ite++) {local_profile[0][bin_ite].setSize(cell_stage_bins[0][bin_ite].mean.getSize());local_profile[1][bin_ite].setSize(cell_stage_bins[0][bin_ite].mean.getSize()); k+= cell_stage_bins[0][bin_ite].mean.getSize();}
	mean_prof.setSize(k); other_mean_prof.setSize(k);
	Tuple< Tuple<double> > query_mean;
	Tuple<double> cur_b_mean;
	if (local){local->setSize(prot_orf.size());}
	daprogbar.start("Finding Local Profiles:");
	bool noerror;
	Vector< KeyElem<double, double > > median_scope[3];
	
	for(i=0;i < prot_orf.size(); i++) {daprogbar.update((double)i / prot_orf.size());
		noerror = true;
		ExOp::toZero(local_profile);tt=0;
		query_mean.setSize(cell_stage_bins[i].getSize()); 
		for(bin_ite=0;bin_ite< cell_stage_bins[i].getSize();bin_ite++) query_mean[bin_ite] = cell_stage_bins[i][bin_ite].getMean();
		
		for(k=0,bin_ite=0;bin_ite< cell_stage_bins[i].getSize();bin_ite++) {
			cur_b_mean = cell_stage_bins[i][bin_ite].getMean();
			for(nb_independent[0]=0;nb_independent[0]<cur_b_mean.getSize();k++) mean_prof[k] = cur_b_mean[nb_independent[0]++];
		}
		
		for(other_iterator=0;other_iterator < prot_orf.size(); other_iterator++){
			if (i == other_iterator) continue;
			for(k=0,bin_ite=0;bin_ite< cell_stage_bins[other_iterator].getSize();bin_ite++) {
				cur_b_mean = cell_stage_bins[other_iterator][bin_ite].getMean();
				for(nb_independent[0]=0;nb_independent[0]<cur_b_mean.getSize();k++) other_mean_prof[k] = cur_b_mean[nb_independent[0]++] - mean_prof[k] ;
			}
			c_weight = Weight(exp(bandwidth_scale[i] * bandwidth.Xformed_inner_product_of_inverse(other_mean_prof)));
			
			if ((!ExOp::isValid(c_weight()))||(c_weight() < 0.000001f)) printf("err dist: %e\tscale: %e\tband: %e\n", bandwidth.Xformed_inner_product_of_inverse(other_mean_prof), bandwidth_scale[i]  , c_weight());
			else{tt += c_weight();
				ExOp::toZero(nb_independent[0]);
				tmpLogPval[4] = 0.0f;
				tmpLogPval[5] = 0.0f;
				tmpLogPval[6] = 0.0f;
				
				for(bin_ite=0;bin_ite< cell_stage_bins[other_iterator].getSize();bin_ite++) {
					local_profile[0][bin_ite] += cell_stage_bins[other_iterator][bin_ite] * c_weight;
					local_profile[1][bin_ite].addGaussElem_free_mean(cell_stage_bins[other_iterator][bin_ite] * c_weight);
					t_covprof[0] = cell_stage_bins[other_iterator][bin_ite].getVar_biaised();

					tmpLogPval[1] = log(t_covprof[1][0]);
					tmpLogPval[2] =	log(t_covprof[1][1]);					
					if ((ExOp::isValid(tmpLogPval[1]))&&  (ExOp::isValid(tmpLogPval[1]))) {tmpLogPval[5]  += tmpLogPval[1];tmpLogPval[6]  += tmpLogPval[2]; nb_independent[0]++;}
				}
				if (nb_independent[0] > 0){
					median_scope[0].push_back(KeyElem<double,double>((tmpLogPval[5] + tmpLogPval[6]) / (2 * nb_independent[0])  , c_weight()));
					median_scope[1].push_back(KeyElem<double,double>(tmpLogPval[5] / nb_independent[0]  , c_weight()));
					median_scope[2].push_back(KeyElem<double,double>(tmpLogPval[6] / nb_independent[0]  , c_weight()));
				}
			}
			
		}
		ExOp::toZero(nb_independent);
		ExOp::toZero(fout_input);
		median_scope[0].sort();median_scope[1].sort();median_scope[2].sort();
		for(tmpLogPval[0] =0.0f,bin_ite=0; tmpLogPval[0] < 0.5f && (bin_ite < median_scope[0].size()); ) tmpLogPval[0] += median_scope[0][bin_ite++].d;
		median_scope[0][0] = median_scope[0][bin_ite];
		for(tmpLogPval[0] =0.0f,bin_ite=0; tmpLogPval[0] < 0.5f && (bin_ite < median_scope[1].size()); ) tmpLogPval[0] += median_scope[1][bin_ite++].d;
		median_scope[1][0] = median_scope[1][bin_ite];
		for(tmpLogPval[0] =0.0f,bin_ite=0; tmpLogPval[0] < 0.5f && (bin_ite < median_scope[2].size()); ) tmpLogPval[0] += median_scope[2][bin_ite++].d;
		median_scope[2][0] = median_scope[2][bin_ite];
		for(bin_ite=0;bin_ite< cell_stage_bins[i].getSize();bin_ite++){
			if ((cell_stage_bins[i][bin_ite].getN() >= minimum_nbcell)&&(local_profile[0][bin_ite].getN() >= minimum_nbcell)){
				tmpLogPval[0] = cell_stage_bins[i][bin_ite].Pvalue_LRTest_UnequalMean(local_profile[0][bin_ite],NULL,true);
				tmpLogPval[1] = cell_stage_bins[i][bin_ite].Pvalue_LRTest_UnequalVariance(local_profile[1][bin_ite],NULL,true);
				tmpLogPval[2] =	cell_stage_bins[i][bin_ite].Pvalue_LRTest_UnequalMeanandVariance(local_profile[1][bin_ite],NULL,true);
				//	printf("%i\t%i\n", cell_stage_bins[i][bin_ite].getSize(), local_profile[1][bin_ite].getSize()); fflush(stdout);
				t_covprof[0] = cell_stage_bins[i][bin_ite].getVar_biaised();
				t_covprof[1] = local_profile[1][bin_ite].getVar_biaised();
				//	printf("%i\t%i\n", mean_prof.getSize(), other_mean_prof.getSize()); fflush(stdout);
				
				tmpLogPval[4] = (0.5f * (log(t_covprof[0][0]) + log(t_covprof[0][1]))) - median_scope[0][0].k;
				tmpLogPval[5] = log(t_covprof[0][0]) - median_scope[1][0].k;
				tmpLogPval[6] = log(t_covprof[0][1]) - median_scope[2][0].k;
				for(k=0;k<8;k++) {if (ExOp::isValid(tmpLogPval[k])) {fout_input[k] += tmpLogPval[k]; nb_independent[k]++;}else{ noerror = false;}}
			}
		}
		median_scope[0].clear();
		median_scope[1].clear();
		median_scope[2].clear();
		//LFH_ALIVE;
		for(k=0;k<3;k++) {
			if (nb_independent[k] > 1)  fout_input[k] = LogPvalue_SumLogPvalues_Ptail(fout_input[k], nb_independent[k]);
		}
		fout_input[3] = tt;
		for(k=4;k<7;k++) {
			if (nb_independent[k] > 1)  fout_input[k] /= nb_independent[k];
		}
		
		if (local){
			(*local)[i].setSize(cell_stage_bins[i].getSize());
			for(bin_ite=0;bin_ite< cell_stage_bins[i].getSize();bin_ite++) (*local)[i][bin_ite] = local_profile[0][bin_ite].getMean();
		}
		fout_input[7] = (noerror) ? 0.0f : 1.0f;
		fout.push_back(fout_input);
	}daprogbar.finish();
	return(fout);
}*/

void Madstructs::GenericCellLoader::find_bin_bandwidth_lowess(double fraction, bool class_partitionned) {Trianglix<double> derivative;
	Tuple<GaussElem<Tuple<double> ,0u> > local_profile;
	unsigned int i,j,k,l;
	for(i=0,k=0;i<cell_stage_bins[0].getSize();i++) k+= cell_stage_bins[0][i].getSize();
	bandwidth.setSize(k);derivative.setSize(k);
	
	local_profile.setSize(cell_stage_bins[0].getSize());
	for(i=0;i<cell_stage_bins[0].getSize();i++)	{local_profile[i].setSize(cell_stage_bins[0][i].getSize());}
	
	Tuple<unsigned int> class_counts;
	// silverman initialization
	{//:
		Tuple<double> input;
	    class_counts.setSize((class_partitionned) ? protein_classes_names.getSize() : 1 );
		bandwidth.setSize( (class_partitionned) ? protein_classes_names.getSize() : 1 );
		Tuple< GaussElem<Tuple<double> > > scope;
		scope.setSize( (class_partitionned) ? protein_classes_names.getSize() : 1 );
		for(i=0;i<scope.getSize();i++) scope[i].setSize(bandwidth.getSize());
		input.setSize(bandwidth.getSize());
		ExOp::toZero(scope);
		Tuple<double> input_bin;
		for(i=0;i<cell_stage_bins.getSize();i++) {
			for(j=0,k=0;j< cell_stage_bins[0].getSize();j++){
				input_bin = cell_stage_bins[i][j].getMean();
					for(l=0;l< input_bin.getSize();l++) input[k++] = input_bin[l];
				}
			if (ExOp::isValid(input)) scope[(class_partitionned) ? protein_class[i] : 0] += GaussElem<Tuple<double> >(input);
		}
		
		for(i=0;i<scope.getSize();i++) {
			bandwidth[i] = scope[i].getCovariance_biased();
			if (scope[i].w > 0.0f){
			double scale = 2.0f * pow(0.25f * (scope[i].w * (2 + input.getSize()))  ,  -2.0f/ (4 + input.getSize()));
			bandwidth[i] *= ExOp::isValid(scale) ? scale : 1.0f;
		    class_counts[i] = scope[i].w;
			if (!ExOp::isValid(bandwidth[i])) {exit(1);}
			}
		}
	}//:
	double der_fraq;
	double fraq;
	double exp_fact;
	
	bandwidth_scale.setSize(cell_stage_bins.getSize());
	
	Tuple<double> mean_prof, other_mean_prof;mean_prof.setSize(k); other_mean_prof.setSize(k);
	Tuple<double> cur_b_mean;
	unsigned int bin_ite;
	Vector<double> distance; distance.setSize(cell_stage_bins.getSize());
	daprogbar.start("Finding Local Regression Local Bandwidths:");
	unsigned int barsel;
	Vector<unsigned int> indexes;
	if (bandwidth.getSize()  > 1) {
		for(barsel=0;barsel<bandwidth.getSize() ;barsel++){daprogbar.update((double)barsel / bandwidth.getSize());
			
			for(i=0;i<prot_orf.size();i++) if (protein_class[i] == barsel)  indexes.push_back(i);
			if (class_counts[barsel] == 1) {bandwidth_scale[indexes[0]] = -1.0f; indexes.clear();continue;}
			
			for(i=0;i<indexes.size();i++) {
				
				for(k=0,bin_ite=0;bin_ite< cell_stage_bins[indexes[i]].getSize();bin_ite++) {
					cur_b_mean = cell_stage_bins[indexes[i]][bin_ite].getMean();
					for(j=0;j<cur_b_mean.getSize();k++) mean_prof[k] = cur_b_mean[j++];
				}
				fraq =0; der_fraq = 0; exp_fact=1.0;
				for(j=0;j < indexes.size(); j++){
					if (i == j) continue;
					for(k=0,bin_ite=0;bin_ite< cell_stage_bins[indexes[j]].getSize();bin_ite++) {
						cur_b_mean = cell_stage_bins[indexes[j]][bin_ite].getMean();
						for(l=0;l<cur_b_mean.getSize();k++) other_mean_prof[k] = cur_b_mean[l++] - mean_prof[k] ;
					}
					distance[j] = bandwidth[barsel].Xformed_inner_product_of_inverse(other_mean_prof);
					fraq += exp(-distance[j]);
					der_fraq -= distance[j] * exp(-distance[j]);
				}
				
				while( fabs(fraq - fraction * class_counts[barsel]) > 0.0000001f){
					der_fraq = -(fraq - fraction * class_counts[barsel]) / (exp_fact * der_fraq);
					fraq = -4.0f * log( (1.0f/ (65536.0f*65536.0f) ) * (1 + rand()) ); if (fraq > 4.0f) fraq = 4.0f; // printf("unstable gard %f   %i\n",  fraq, rand());
					if (fabs(der_fraq) > fraq) exp_fact *= (der_fraq > 0) ? exp(fraq) : exp(-fraq);
					else exp_fact *= exp(der_fraq);
					fraq =0; der_fraq = 0;
					for(j=0;j < indexes.size(); j++){
						if (i == j) continue;
						fraq += exp(-exp_fact * distance[j]);
						der_fraq -= distance[j] * exp(-exp_fact * distance[j]);
					}
				}
				bandwidth_scale[indexes[i]] = (ExOp::isValid(exp_fact)) ? -exp_fact : -1.0f;
			}
			indexes.clear();
		}daprogbar.finish();
	}else{
	 
																									   
	for(i=0;i<prot_orf.size();i++) {daprogbar.update((double)i / prot_orf.size());
																									   
		for(k=0,bin_ite=0;bin_ite< cell_stage_bins[i].getSize();bin_ite++) {
			cur_b_mean = cell_stage_bins[i][bin_ite].getMean();
			for(j=0;j<cur_b_mean.getSize();k++) mean_prof[k] = cur_b_mean[j++];
		}
		fraq =0; der_fraq = 0; exp_fact=1.0;
		for(j=0;j < prot_orf.size(); j++){
			if (i == j) continue;
			if ((class_partitionned)&&(protein_class[i] != protein_class[j])) continue;
			barsel = (class_partitionned) ? protein_class[i] : 0;
			for(k=0,bin_ite=0;bin_ite< cell_stage_bins[j].getSize();bin_ite++) {
				cur_b_mean = cell_stage_bins[j][bin_ite].getMean();
				for(l=0;l<cur_b_mean.getSize();k++) other_mean_prof[k] = cur_b_mean[l++] - mean_prof[k] ;
			}
			distance[j] = bandwidth[barsel].Xformed_inner_product_of_inverse(other_mean_prof);
			fraq += exp(-distance[j]);
			der_fraq -= distance[j] * exp(-distance[j]);
		}

		while( fabs(fraq - fraction * prot_orf.size()) > 0.0000001f){
	    der_fraq = -(fraq - fraction * prot_orf.size()) / (exp_fact * der_fraq);
			fraq = -4.0f * log( (1.0f/ (65536.0f*65536.0f) ) * (1 + rand()) ); if (fraq > 4.0f) fraq = 4.0f; // printf("unstable gard %f   %i\n",  fraq, rand());
			if (fabs(der_fraq) > fraq) exp_fact *= (der_fraq > 0) ? exp(fraq) : exp(-fraq);
			else exp_fact *= exp(der_fraq);
			fraq =0; der_fraq = 0;
			for(j=0;j < prot_orf.size(); j++){
				if (i == j) continue;
				fraq += exp(-exp_fact * distance[j]);
				der_fraq -= distance[j] * exp(-exp_fact * distance[j]);
			}
		}
		bandwidth_scale[i] = (ExOp::isValid(exp_fact)) ? -exp_fact : -1.0f;
	}daprogbar.finish();
	}
	
	
	//for(i=0;i<bandwidth_scale.getSize();i++) bandwidth_scale[i] = -1.0f;
}
/*
void Madstructs::GenericCellLoader::find_bin_bandwidth_undiscrim(double signif_threshold) {Trianglix<double> derivative;
	Tuple<GaussElem<Tuple<double> ,0u> > local_profile;
	unsigned int i,j,k,l;
	for(i=0,k=0;i<cell_stage_bins[0].getSize();i++) k+= cell_stage_bins[0][i].getSize();
	bandwidth.setSize(k);derivative.setSize(k);
	
	local_profile.setSize(cell_stage_bins[0].getSize());
	for(i=0;i<cell_stage_bins[0].getSize();i++)	{local_profile[i].setSize(cell_stage_bins[0][i].getSize());}
	
	// silverman initialization
	{//:
		Tuple<double> input;
		GaussElem<Tuple<double> > scope; scope.setSize(bandwidth.getSize()); input.setSize(bandwidth.getSize()); ExOp::toZero(scope);
		Tuple<double> input_bin;
		for(i=0;i<cell_stage_bins.getSize();i++) {
			for(j=0,k=0;j< cell_stage_bins[0].getSize();j++){
				input_bin = cell_stage_bins[i][j].getMean();
				for(l=0;l< input_bin.getSize();l++) input[k++] = input_bin[l];
			}
			scope += GaussElem<Tuple<double> >(input);
		}
		
		bandwidth = scope.getCovariance_biased();
		double scale = 2.0f * pow(0.25f * (cell_stage_bins.getSize() * (2 + input.getSize()))  ,  -2.0f/ (4 + input.getSize()));
		bandwidth *= scale;
		
		//	ExOp::toinverse(bandwidth);
		if (!ExOp::isValid(bandwidth)) {bandwidth.show();exit(1);}
		
		
	}//:
	
	double der_fraq;
	double fraq;
	double exp_fact;
	LogPvalSum pvalsum;
	Weight c_wei;
	bandwidth_scale.setSize(cell_stage_bins.getSize());
	
	Tuple<double> mean_prof, other_mean_prof;mean_prof.setSize(k); other_mean_prof.setSize(k);
	Tuple<double> cur_b_mean;
	unsigned int bin_ite;
	Vector< KeyElem<double, unsigned int> > distance; distance.setSize(cell_stage_bins.getSize());
	daprogbar.start("Finding Local Bandwidths for indistinguishable profiles:");
	for(i=0;i<prot_orf.size();i++) {daprogbar.update((double)i / prot_orf.size());
		
		for(k=0,bin_ite=0;bin_ite< cell_stage_bins[i].getSize();bin_ite++) {
			cur_b_mean = cell_stage_bins[i][bin_ite].getMean();
			for(j=0;j<cur_b_mean.getSize();k++) mean_prof[k] = cur_b_mean[j++];
		}
		exp_fact=1.0;
		double der_fraq;
		ExOp::toZero(local_profile);
		for(j=0;j < prot_orf.size(); j++){
			if (i == j) {distance[i] = KeyElem<double, unsigned int>(ExCo<double>::maximum(),i); continue;}
			for(k=0,bin_ite=0;bin_ite< cell_stage_bins[j].getSize();bin_ite++) {
				cur_b_mean = cell_stage_bins[j][bin_ite].getMean();
				for(l=0;l<cur_b_mean.getSize();k++) other_mean_prof[k] = cur_b_mean[l++] - mean_prof[k] ;
			}

			distance[j] = KeyElem<double,unsigned int>( bandwidth.Xformed_inner_product_of_inverse(other_mean_prof) ,j);
			if (!ExOp::isValid(distance[j].k)) ExOp::toMax(distance[j].k);
			if (((j == 0)||((i==0)&&(j==1)))||(exp_fact > distance[j].k)) exp_fact = distance[j].k;
			
			for(bin_ite=0;bin_ite< cell_stage_bins[j].getSize();bin_ite++) {
				local_profile[bin_ite] += cell_stage_bins[j][bin_ite] * Weight(exp(-distance[j].k));
			}
		}
		distance.sort();
		ExOp::toZero(pvalsum);
		
		for(bin_ite=0;bin_ite< cell_stage_bins[i].getSize();bin_ite++) {pvalsum += cell_stage_bins[i][bin_ite].Pvalue_LRTest_UnequalMeanandVariance(local_profile[bin_ite],NULL,true);}
		
		exp_fact = 1.0f / exp_fact;
		for(k=0;( pvalsum() > signif_threshold)&&(k<100);k++){
			exp_fact *=0.0625f;
		ExOp::toZero(local_profile);			
		for(j=0;j < prot_orf.size()-1; j++){
			for(bin_ite=0;bin_ite< cell_stage_bins[j].getSize();bin_ite++) local_profile[bin_ite] += cell_stage_bins[distance[j].d][bin_ite] * Weight(exp(-exp_fact * distance[j].k));
			if  (exp_fact * distance[j].k > 100.0f) break;
		}
		ExOp::toZero(pvalsum);
		for(bin_ite=0;bin_ite< cell_stage_bins[i].getSize();bin_ite++) pvalsum += cell_stage_bins[i][bin_ite].Pvalue_LRTest_UnequalMeanandVariance(local_profile[bin_ite],NULL,true);
		pvalsum.compress();
		}
		double scan_fmax;
		double scan_fmin = pvalsum();
		double scan_min = exp_fact;
		double scan_max = 0.0f;
		
		for(k=0;k<100;k++){
			ExOp::toZero(local_profile);			
			for(j=0;j < prot_orf.size()-1; j++){
				for(bin_ite=0;bin_ite< cell_stage_bins[j].getSize();bin_ite++) local_profile[bin_ite] += cell_stage_bins[distance[j].d][bin_ite] * Weight(exp(-exp_fact * distance[j].k));
				if  (exp_fact * distance[j].k > 100.0f) break;
			}
			ExOp::toZero(pvalsum);
			for(bin_ite=0;bin_ite< cell_stage_bins[i].getSize();bin_ite++) pvalsum += cell_stage_bins[i][bin_ite].Pvalue_LRTest_UnequalMeanandVariance(local_profile[bin_ite],NULL,true);
			pvalsum.compress();
			
			
			
			if  ( pvalsum() > signif_threshold){
				scan_max = exp_fact;
				scan_fmax = pvalsum();

			}else if (scan_max == 0) exp_fact *= 256;
			else{
				scan_min = exp_fact;
				scan_fmin = pvalsum();
			}
			if ( fabs(scan_fmax - scan_fmin) < 0.0000001f) break;
			if (scan_max != 0) exp_fact = ((scan_fmax- signif_threshold) * scan_min - (scan_fmin - signif_threshold) * scan_max) / (scan_fmax - scan_fmin);
		}
		bandwidth_scale[i] = -exp_fact;
	}daprogbar.finish();


}*/
	
	
#endif

Vector<Tuple< Tuple< double > > > Madstructs::GenericCellLoader::getMean() const{Vector<Tuple< Tuple< double > > > fout;
	fout.setSize(prot_orf.size());
	unsigned int iterator;
	unsigned int bin_ite;
	for(iterator=0;iterator < prot_orf.size(); iterator++) {
		fout[iterator].setSize(cell_stage_bins[iterator].getSize());
		for(bin_ite=0;bin_ite< cell_stage_bins[iterator].getSize();bin_ite++){
			fout[iterator][bin_ite] = cell_stage_bins[iterator][bin_ite].getMean(); 
		}
	}
	return fout;
}

void Madstructs::GenericCellLoader::printCollumnName(FILE * f) const{
	unsigned int bin_ite,chan_ite;
	char buffer[256];
	memcpy(buffer, "B00_C00", 8);
	for(bin_ite=0;bin_ite< cell_stage_bins[0].getSize();bin_ite++){
		buffer[1] = '0' + (bin_ite / 10);
		buffer[2] = '0' + (bin_ite % 10);
		buffer[5] = '0';
		buffer[6] = '0';
		if (bin_ite== 0) fprintf(f,"%s", buffer);
		else fprintf(f,"\t%s", buffer);
		for(chan_ite=1;chan_ite< cell_stage_bins[0][bin_ite].getSize();chan_ite++){
			buffer[5] = '0' + (chan_ite / 10);
			buffer[6] = '0' + (chan_ite % 10);			
			fprintf(f,"\t%s", buffer);
		}
	}
}
void Madstructs::GenericCellLoader::two_ended_variance_analysis() const{
	unsigned int i,j,k,l;
	unsigned int resol = cell_stage_bins[0].getSize();
	double* buffer = new double[(resol * (resol +1)) >>1];
	double* wbuffer = new double[(resol * (resol +1)) >>1];
	printf("nbinner %i\n", (resol * (resol +1)) >>1);
	Tuple<WeightElem<double, 1> > corr; corr.setSize((resol * (resol +1)) >>1); ExOp::toZero(corr);
	daprogbar.start("Computing Covariances:");
	Tuple<GaussElem<Tuple<double> ,0u> > local_profile; local_profile.setSize(resol);
	for(i=0;i<prot_orf.size();i++) {daprogbar.update((double)i / prot_orf.size());

		for(l=0,j=0;j<resol;j++){
			local_profile[j] = cell_stage_bins[i][j];
			for(k=0;k<j;k++) {local_profile[k] += local_profile[j]; if (local_profile[k].w != 0) buffer[l] = log(local_profile[k].getVar_biaised()[1]); wbuffer[l++] = local_profile[k].w ;}
			 if (local_profile[j].w != 0) buffer[l] = log(local_profile[k].getVar_biaised()[1]); wbuffer[l++] = local_profile[j].w;
		}
		
		for(l=0;l< ((resol * (resol +1)) >>1);l++){
			if (ExOp::isValid(buffer[l])) corr[l] +=  WeightElem<double, 1>(buffer[l] - buffer[((resol * (resol - 1)) >>1)], wbuffer[l]);
		}
	}daprogbar.finish();
	
	for(l=0,j=0;j<resol;j++){
		for(k=0;k<j;k++) printf("%f\t", corr[l++].getMean());
		printf("%f\n", corr[l++].getMean());
	}
	
	for(l=0,j=0;j<resol;j++){
		for(k=0;k<j;k++) printf("%f\t", corr[l++].w[0]);
		printf("%f\n", corr[l++].w[0]);
	}
	
	delete[](buffer);
	delete[](wbuffer);
}


void Madstructs::GenericCellLoader::MLGP() const{
	unsigned int i,j,k;
	Vector<KeyElem<double, double> > bud_range;
	Vector<KeyElem<double, double> > mother_range;
	
	Trianglix<double> covar;
	
	for(i=0;i<offsets.size();i++){
		
		for(j=offsets[i][0];j<offsets[i][1];j++){
			if (mother_buds[j].k[0] > 0.8){
				bud_range.push_back(KeyElem<double,double>(pow(mother_buds[i].k[1], 1.5f),  mother_buds[i].d[0]));
				mother_range.push_back(KeyElem<double,double>(pow(mother_buds[i].k[1], 1.5f),  mother_buds[i].d[1]));
			}
		} 
		
		covar.setSize(bud_range.getSize());
		
		
		for(j=0;j<bud_range.getSize();j++){
			for(k=0;k<j;k++){
				covar.cell(j,j) = 1.0f;
			}
			covar.cell(j,j) = 1.0f;
		}
		
		
		bud_range.clear();
		mother_range.clear();
	}
	
}


void Madstructs::GenericCellLoader::MLClustering(const char* path) const{
	char buffer[256];
	unsigned int i,j,k,l;
	Forest<double,2> da_clust;
	i = strlen(path); memcpy(buffer, path,sizeof(char)*i); memcpy(buffer+i, ".cdt", sizeof(char)*5);
	FILE *clust_cdt = fopen(buffer, "w+");
	double pix[2];
	
	
	
	fprintf(clust_cdt,"GID\tID\tNAME\tGWEIGHT");
	/*for(l=0;l<cell_stage_bins[0].getSize();l++){
		for(k=0;k<cell_stage_bins[0][l].getSize();k++) 
		strcpy(buffer,collumn_names[l]);
		for(i=0;i<3*(resol+1);i++) if ((i % (resol +1)) !=0) fprintf(clust_cdt,"\t%s_%c_M%i", buffer, (i <(2*resol+2)) ? ((i <(resol+1)) ? 'B' : 'M') : ((i <(3*resol+3)) ? 'D' : 'L') ,(i-1)%(resol+1)); else fprintf(g,"\t%s%c", buffer, (i <(2*resol+2)) ? ((i <(resol+1)) ? 'B' : 'M') : ((i <(3*resol+3)) ? 'D' : 'L'));
	}
	for(l=0;l<cell_stage_bins[0].size();l++){
		strcpy(buffer,collumn_names[l]);
		for(i=0;i<3*(resol+1);i++) if ((i % (resol +1)) !=0) fprintf(clust_cdt,"\t%s_%c_V%i", buffer, (i <(2*resol+2)) ? ((i <(resol+1)) ? 'B' : 'M') : ((i <(3*resol+3)) ? 'D' : 'L') ,(i-1)%(resol+1)); else fprintf(g,"\t%s%c", buffer, (i <(2*resol+2)) ? ((i <(resol+1)) ? 'B' : 'M') : ((i <(3*resol+3)) ? 'D' : 'L'));
	}*/
	fprintf(clust_cdt,"\nEWEIGHT\t\t\t");
	//for(l=0;l<collumn_names.size();l++)	for(i=0;i<clust_in.getSize()*2;i++) fprintf(clust_cdt,"\t%f",1.0f);
	fprintf(clust_cdt,"\n");
	
	Vector< GaussElem< Tuple<double, 0u > > > to_clust;
	l=0;k=0;
	for(l=0,k=0;l<cell_stage_bins[0].getSize();l++) k+= cell_stage_bins[0][l].getSize();
	GaussElem< Tuple<double, 0u > > to_clust_input; to_clust_input.setSize(k);
	Tuple<double, 0u > curmean;to_clust_input.w = 1.0f;to_clust_input.w2 = 1.0f;
	unsigned int off;
	for(i=0;i<cell_stage_bins.getSize();i++){
		
		for(l=0,off=0;l<cell_stage_bins[0].getSize();l++){
			curmean = cell_stage_bins[0][l].getMean();
			for(j=0;j< cell_stage_bins[0][l].getSize();j++){
				to_clust_input.mean[off + j] = curmean[j];
				
			}
			off+= cell_stage_bins[0][l].getSize();
		}
	
	}
	
	
	
//	da_clust.cluster_likelihood_ratio(to_clust);
	
	pix[0] = ExCo<double>::maximum(); pix[1] = ExCo<double>::minimum();
	for(i=0;i< da_clust.getSize();i++){
		if (ExCo<double>::isValid(da_clust[i].second)) {
			if (da_clust[i].second <=0.0f) continue;
			if (da_clust[i].second < pix[0]) pix[0] = da_clust[i].second;
			if (da_clust[i].second > pix[1]) pix[1] = da_clust[i].second;
	}	}
	for(i=0;i< da_clust.getSize();i++) da_clust[i].second = (ExCo<double>::isValid(da_clust[i].second)) ? ((da_clust[i].second <=0.0f) ? 1.0f: (log(pix[1]) - log(da_clust[i].second)) / (log(pix[1]) - log(pix[0]) ) ) : 0.0f;

	i = strlen(path); memcpy(buffer, path,sizeof(char)*i); memcpy(buffer+i, ".gtr",sizeof(char)*5);
	da_clust.saveGTRfile(buffer, "GENE");

	// data matrix to print
	
	
	fclose(clust_cdt);
}

template< >
void Madstructs::Image<unsigned char>::LoadTiffImage(vector<Madstructs::Image<unsigned char>* > &out, const char* path){
	FILE* in = fopen(path,"rb+");
	if (in == NULL){ 
		// LFHPrimitive::static_warning_handdle << LFH_WARNING_NO_FILE_HANDDLE_R;
		return;
	}
	char buffer[65536];
	fread(buffer,sizeof(char),8,in);
	stack<int> s;
	bool invert = buffer[0] != 'I';
	short tmpshort;
	int tmpint;
	char tmpchar;
	tmpint = *((int*)(buffer + 4));
	int cur = (invert) ? bitwiseswap(tmpint) : tmpint;
	int i;
	Madstructs::Image<unsigned char>* curimage;
	void* target;
	int type;
	
	int stripof; // address
	int stripco;
	int stripro;
	//	int nbstrip;
	
	
	
	int fieldsize;
	while(cur != 0){
		curimage = new Madstructs::Image<unsigned char>();
		fseek(in,cur,SEEK_SET);
		fread(buffer,sizeof(short),1,in);
		tmpshort = *((short*)(buffer));
		if (invert) i = bitwiseswap(tmpshort);
		else i = tmpshort;
		for(i--;i>=0;i--){
			fread(buffer,sizeof(char),12,in);
			tmpshort = *((short*)(buffer));	if (invert) tmpshort = bitwiseswap(tmpshort);
			switch(tmpshort){
					//			case 254:memcpy(buffer+512,"NewSubfileType",sizeof(char)*15);break;
				case 256:target = (void*)&(curimage->sizex); type =4; break;//memcpy(buffer+512,"ImageWidth",sizeof(char)*11);break;
				case 257:target = (void*)&(curimage->sizey); type =4; break;//memcpy(buffer+512,"ImageHeight",sizeof(char)*12);break;
					//			case 258:memcpy(buffer+512,"BitsPerSample",sizeof(char)*14);break;
					//			case 259:memcpy(buffer+512,"Compression",sizeof(char)*12);break;
					//			case 262:memcpy(buffer+512,"PhotometricInterpretation",sizeof(char)*26);break; 
				case 273:target = (void*)&(stripof); type =4; break;//memcpy(buffer+512,"SkipOffsets",sizeof(char)*12);break;
					//			case 274:memcpy(buffer+512,"Orientation",sizeof(char)*12);break;
				case 277:target = (void*)&(curimage->channels); type =4; break;//memcpy(buffer+512,"SamplesPerPixel",sizeof(char)*16);break;
				case 278:target = (void*)&(stripro); type =4; break;//memcpy(buffer+512,"RowsPerStrip",sizeof(char)*13);break;
				case 279:target = (void*)&(stripco); type =4; break;//memcpy(buffer+512,"StripByteCounts",sizeof(char)*16);break;
					//			case 282:memcpy(buffer+512,"XResolution",sizeof(char)*12);break;
					//			case 283:memcpy(buffer+512,"YResolution",sizeof(char)*12);break;
					//			case 296:memcpy(buffer+512,"ResolutionUnit",sizeof(char)*15);break;
				default: target = NULL; //memcpy(buffer+512,"",sizeof(char)*1);
			}
			
			tmpshort = *((short*)(buffer+2));if (invert) tmpshort = bitwiseswap(tmpshort);
			
			switch(tmpshort){
				case 1:fieldsize = sizeof(char);break;//memcpy(buffer+256,"BYTE",sizeof(char)*5);break;
				case 2:fieldsize = sizeof(char);break;//memcpy(buffer+256,"ASCII",sizeof(char)*6);break;
				case 3:fieldsize = sizeof(short);break;//memcpy(buffer+256,"SHORT",sizeof(char)*6);break;
				case 4:fieldsize = sizeof(int);break;//memcpy(buffer+256,"LONG",sizeof(char)*5);break;
				case 5:fieldsize = sizeof(int)*2;break;//memcpy(buffer+256,"RATIONAL",sizeof(char)*9);break;
				case 6:fieldsize = sizeof(char);break;//memcpy(buffer+256,"SBYTE",sizeof(char)*6);break;
				case 7:fieldsize = sizeof(char);break;//memcpy(buffer+256,"UNDEFINED",sizeof(char)*10);break;
				case 8:fieldsize = sizeof(short);break;//memcpy(buffer+256,"SSHORT",sizeof(char)*7);break;
				case 9:fieldsize = sizeof(int);break;//memcpy(buffer+256,"SLONG",sizeof(char)*6);break;
				case 10:fieldsize = sizeof(int)*2;break;//memcpy(buffer+256,"SRATIONAL",sizeof(char)*10);break;
				case 11:fieldsize = sizeof(float)*2;break;//memcpy(buffer+256,"FLOAT",sizeof(char)*6);break;
				case 12:fieldsize = sizeof(double)*2;break;//memcpy(buffer+256,"DOUBLE",sizeof(char)*7);break;
				default: memcpy(buffer+256,"UNKNOWN",sizeof(char)*8);
			}
			if (target != NULL){
				
				if (invert){
					switch(tmpshort){
						case 1: if (type == 4) {tmpchar = *((char*)(buffer + 8)); *((int*)target) = (int) bitwiseswap(tmpchar);} break;
						case 2: if (type == 4) {tmpchar = *((char*)(buffer + 8)); *((int*)target) = (int) bitwiseswap(tmpchar);}break;
						case 3: if (type == 4) {tmpshort = *((short*)(buffer + 8)); *((int*)target) = (int) bitwiseswap(tmpshort);}break;
						case 4: if (type == 4) {tmpint = *((int*)(buffer + 8)); *((int*)target) = (int) bitwiseswap(tmpint);}break;
					}
					
				}else{
					if ((*((int*)(buffer+4)))*fieldsize <= 4){
						switch(*((short*)(buffer+2))){
							case 1: if (type == 4) *((int*)target) = (int) *((char*)(buffer + 8)); break;
							case 2: if (type == 4) *((int*)target) = (int) *((char*)(buffer + 8)); break;
							case 3: if (type == 4) *((int*)target) = (int) *((short*)(buffer + 8)); break;
							case 4: if (type == 4) *((int*)target) = (int) *((int*)(buffer + 8)); break;
						}
						
					}else{
						// for now, that's not used
						
					}
				}
			}
			
		}
		fread(&tmpint,sizeof(int),1,in);
		cur = (invert) ? bitwiseswap(tmpint) : tmpint;
		fseek(in,stripof,SEEK_SET);
		curimage->allocateBuffer();
		fread(curimage->data,sizeof(char),curimage->channels * curimage->sizex * curimage->sizey,in); // assumes a single strip...
		
		out.push_back(curimage);
	}
	
	fclose(in);
}

template< >
void Madstructs::Image<unsigned short>::LoadTiffImage(vector<Madstructs::Image<unsigned short>* > &out, const char* path){
	FILE* in = fopen(path,"rb+");
	if (in == NULL){ 
		// LFHPrimitive::static_warning_handdle << LFH_WARNING_NO_FILE_HANDDLE_R;
		return;
	}
	char buffer[65536];
	fread(buffer,sizeof(char),8,in);
	stack<int> s;
	bool invert = buffer[0] != 'I';
	short tmpshort;
	int tmpint;
	char tmpchar;
	tmpint = *((int*)(buffer + 4));
	int cur = (invert) ? bitwiseswap(tmpint) : tmpint;
	int i;
	Madstructs::Image<unsigned short>* curimage;
	void* target;
	int type;
	
	int stripof; // address
	int stripco;
	int stripro;
	//	int nbstrip;
	
	
	
	int fieldsize;
	while(cur != 0){
		curimage = new Madstructs::Image<unsigned short>();
		fseek(in,cur,SEEK_SET);
		fread(buffer,sizeof(short),1,in);
		tmpshort = *((short*)(buffer));
		if (invert) i = bitwiseswap(tmpshort);
		else i = tmpshort;
		for(i--;i>=0;i--){
			fread(buffer,sizeof(char),12,in);
			tmpshort = *((short*)(buffer));	if (invert) tmpshort = bitwiseswap(tmpshort);
			switch(tmpshort){
					//			case 254:memcpy(buffer+512,"NewSubfileType",sizeof(char)*15);break;
				case 256:target = (void*)&(curimage->sizex); type =4; break;//memcpy(buffer+512,"ImageWidth",sizeof(char)*11);break;
				case 257:target = (void*)&(curimage->sizey); type =4; break;//memcpy(buffer+512,"ImageHeight",sizeof(char)*12);break;
					//			case 258:memcpy(buffer+512,"BitsPerSample",sizeof(char)*14);break;
					//			case 259:memcpy(buffer+512,"Compression",sizeof(char)*12);break;
					//			case 262:memcpy(buffer+512,"PhotometricInterpretation",sizeof(char)*26);break; 
				case 273:target = (void*)&(stripof); type =4; break;//memcpy(buffer+512,"SkipOffsets",sizeof(char)*12);break;
					//			case 274:memcpy(buffer+512,"Orientation",sizeof(char)*12);break;
				case 277:target = (void*)&(curimage->channels); type =4; break;//memcpy(buffer+512,"SamplesPerPixel",sizeof(char)*16);break;
				case 278:target = (void*)&(stripro); type =4; break;//memcpy(buffer+512,"RowsPerStrip",sizeof(char)*13);break;
				case 279:target = (void*)&(stripco); type =4; break;//memcpy(buffer+512,"StripByteCounts",sizeof(char)*16);break;
					//			case 282:memcpy(buffer+512,"XResolution",sizeof(char)*12);break;
					//			case 283:memcpy(buffer+512,"YResolution",sizeof(char)*12);break;
					//			case 296:memcpy(buffer+512,"ResolutionUnit",sizeof(char)*15);break;
				default: target = NULL; //memcpy(buffer+512,"",sizeof(char)*1);
			}
			
			tmpshort = *((short*)(buffer+2));if (invert) tmpshort = bitwiseswap(tmpshort);
			
			switch(tmpshort){
				case 1:fieldsize = sizeof(char);break;//memcpy(buffer+256,"BYTE",sizeof(char)*5);break;
				case 2:fieldsize = sizeof(char);break;//memcpy(buffer+256,"ASCII",sizeof(char)*6);break;
				case 3:fieldsize = sizeof(short);break;//memcpy(buffer+256,"SHORT",sizeof(char)*6);break;
				case 4:fieldsize = sizeof(int);break;//memcpy(buffer+256,"LONG",sizeof(char)*5);break;
				case 5:fieldsize = sizeof(int)*2;break;//memcpy(buffer+256,"RATIONAL",sizeof(char)*9);break;
				case 6:fieldsize = sizeof(char);break;//memcpy(buffer+256,"SBYTE",sizeof(char)*6);break;
				case 7:fieldsize = sizeof(char);break;//memcpy(buffer+256,"UNDEFINED",sizeof(char)*10);break;
				case 8:fieldsize = sizeof(short);break;//memcpy(buffer+256,"SSHORT",sizeof(char)*7);break;
				case 9:fieldsize = sizeof(int);break;//memcpy(buffer+256,"SLONG",sizeof(char)*6);break;
				case 10:fieldsize = sizeof(int)*2;break;//memcpy(buffer+256,"SRATIONAL",sizeof(char)*10);break;
				case 11:fieldsize = sizeof(float)*2;break;//memcpy(buffer+256,"FLOAT",sizeof(char)*6);break;
				case 12:fieldsize = sizeof(double)*2;break;//memcpy(buffer+256,"DOUBLE",sizeof(char)*7);break;
				default: memcpy(buffer+256,"UNKNOWN",sizeof(char)*8);
			}
			if (target != NULL){
				
				if (invert){
					switch(tmpshort){
						case 1: if (type == 4) {tmpchar = *((char*)(buffer + 8)); *((int*)target) = (int) bitwiseswap(tmpchar);} break;
						case 2: if (type == 4) {tmpchar = *((char*)(buffer + 8)); *((int*)target) = (int) bitwiseswap(tmpchar);}break;
						case 3: if (type == 4) {tmpshort = *((short*)(buffer + 8)); *((int*)target) = (int) bitwiseswap(tmpshort);}break;
						case 4: if (type == 4) {tmpint = *((int*)(buffer + 8)); *((int*)target) = (int) bitwiseswap(tmpint);}break;
					}
					
				}else{
					if ((*((int*)(buffer+4)))*fieldsize <= 4){
						switch(*((short*)(buffer+2))){
							case 1: if (type == 4) *((int*)target) = (int) *((char*)(buffer + 8)); break;
							case 2: if (type == 4) *((int*)target) = (int) *((char*)(buffer + 8)); break;
							case 3: if (type == 4) *((int*)target) = (int) *((short*)(buffer + 8)); break;
							case 4: if (type == 4) *((int*)target) = (int) *((int*)(buffer + 8)); break;
						}
						
					}else{
						// for now, that's not used
						
					}
				}
			}
			
		}
		fread(&tmpint,sizeof(int),1,in);
		cur = (invert) ? bitwiseswap(tmpint) : tmpint;
		fseek(in,stripof,SEEK_SET);
		curimage->allocateBuffer();
		fread(curimage->data,sizeof(short),curimage->channels * curimage->sizex * curimage->sizey,in); // assumes a single strip...
		
		out.push_back(curimage);
	}
	
	fclose(in);
}

template< >
void Madstructs::Image<unsigned char>::LoadTiffImageBin(vector<Madstructs::Image<unsigned char>* > &out, const char* path){
	FILE* in = fopen(path,"rb+");
	if (in == NULL){ 
		// LFHPrimitive::static_warning_handdle << LFH_WARNING_NO_FILE_HANDDLE_R;
		return;
	}
	char buffer[65536];
	fread(buffer,sizeof(char),8,in);
	stack<int> s;
	bool invert = buffer[0] != 'I';
	short tmpshort;
	int tmpint;
	char tmpchar;
	tmpint = *((int*)(buffer + 4));
	int cur = (invert) ? bitwiseswap(tmpint) : tmpint;
	int i;
	Madstructs::Image<unsigned char>* curimage;
	void* target;
	int type;
	
	int stripof; // address
	int stripco;
	int stripro;
	//	int nbstrip;
	
	
	
	int fieldsize;
	while(cur != 0){
		curimage = new Madstructs::Image<unsigned char>();
		fseek(in,cur,SEEK_SET);
		fread(buffer,sizeof(short),1,in);
		tmpshort = *((short*)(buffer));
		if (invert) i = bitwiseswap(tmpshort);
		else i = tmpshort;
		for(i--;i>=0;i--){
			fread(buffer,sizeof(char),12,in);
			tmpshort = *((short*)(buffer));	if (invert) tmpshort = bitwiseswap(tmpshort);
			switch(tmpshort){
					//			case 254:memcpy(buffer+512,"NewSubfileType",sizeof(char)*15);break;
				case 256:target = (void*)&(curimage->sizex); type =4; break;//memcpy(buffer+512,"ImageWidth",sizeof(char)*11);break;
				case 257:target = (void*)&(curimage->sizey); type =4; break;//memcpy(buffer+512,"ImageHeight",sizeof(char)*12);break;
					//			case 258:memcpy(buffer+512,"BitsPerSample",sizeof(char)*14);break;
					//			case 259:memcpy(buffer+512,"Compression",sizeof(char)*12);break;
					//			case 262:memcpy(buffer+512,"PhotometricInterpretation",sizeof(char)*26);break; 
				case 273:target = (void*)&(stripof); type =4; break;//memcpy(buffer+512,"SkipOffsets",sizeof(char)*12);break;
					//			case 274:memcpy(buffer+512,"Orientation",sizeof(char)*12);break;
				case 277:target = (void*)&(curimage->channels); type =4; break;//memcpy(buffer+512,"SamplesPerPixel",sizeof(char)*16);break;
				case 278:target = (void*)&(stripro); type =4; break;//memcpy(buffer+512,"RowsPerStrip",sizeof(char)*13);break;
				case 279:target = (void*)&(stripco); type =4; break;//memcpy(buffer+512,"StripByteCounts",sizeof(char)*16);break;
					//			case 282:memcpy(buffer+512,"XResolution",sizeof(char)*12);break;
					//			case 283:memcpy(buffer+512,"YResolution",sizeof(char)*12);break;
					//			case 296:memcpy(buffer+512,"ResolutionUnit",sizeof(char)*15);break;
				default: target = NULL; //memcpy(buffer+512,"",sizeof(char)*1);
			}
			
			tmpshort = *((short*)(buffer+2));if (invert) tmpshort = bitwiseswap(tmpshort);
			
			switch(tmpshort){
				case 1:fieldsize = sizeof(char);break;//memcpy(buffer+256,"BYTE",sizeof(char)*5);break;
				case 2:fieldsize = sizeof(char);break;//memcpy(buffer+256,"ASCII",sizeof(char)*6);break;
				case 3:fieldsize = sizeof(short);break;//memcpy(buffer+256,"SHORT",sizeof(char)*6);break;
				case 4:fieldsize = sizeof(int);break;//memcpy(buffer+256,"LONG",sizeof(char)*5);break;
				case 5:fieldsize = sizeof(int)*2;break;//memcpy(buffer+256,"RATIONAL",sizeof(char)*9);break;
				case 6:fieldsize = sizeof(char);break;//memcpy(buffer+256,"SBYTE",sizeof(char)*6);break;
				case 7:fieldsize = sizeof(char);break;//memcpy(buffer+256,"UNDEFINED",sizeof(char)*10);break;
				case 8:fieldsize = sizeof(short);break;//memcpy(buffer+256,"SSHORT",sizeof(char)*7);break;
				case 9:fieldsize = sizeof(int);break;//memcpy(buffer+256,"SLONG",sizeof(char)*6);break;
				case 10:fieldsize = sizeof(int)*2;break;//memcpy(buffer+256,"SRATIONAL",sizeof(char)*10);break;
				case 11:fieldsize = sizeof(float)*2;break;//memcpy(buffer+256,"FLOAT",sizeof(char)*6);break;
				case 12:fieldsize = sizeof(double)*2;break;//memcpy(buffer+256,"DOUBLE",sizeof(char)*7);break;
				default: memcpy(buffer+256,"UNKNOWN",sizeof(char)*8);
			}
			if (target != NULL){
				
				if (invert){
					switch(tmpshort){
						case 1: if (type == 4) {tmpchar = *((char*)(buffer + 8)); *((int*)target) = (int) bitwiseswap(tmpchar);} break;
						case 2: if (type == 4) {tmpchar = *((char*)(buffer + 8)); *((int*)target) = (int) bitwiseswap(tmpchar);}break;
						case 3: if (type == 4) {tmpshort = *((short*)(buffer + 8)); *((int*)target) = (int) bitwiseswap(tmpshort);}break;
						case 4: if (type == 4) {tmpint = *((int*)(buffer + 8)); *((int*)target) = (int) bitwiseswap(tmpint);}break;
					}
					
				}else{
					if ((*((int*)(buffer+4)))*fieldsize <= 4){
						switch(*((short*)(buffer+2))){
							case 1: if (type == 4) *((int*)target) = (int) *((char*)(buffer + 8)); break;
							case 2: if (type == 4) *((int*)target) = (int) *((char*)(buffer + 8)); break;
							case 3: if (type == 4) *((int*)target) = (int) *((short*)(buffer + 8)); break;
							case 4: if (type == 4) *((int*)target) = (int) *((int*)(buffer + 8)); break;
						}
						
					}else{
						// for now, that's not used
						
					}
				}
			}
			
		}
		
		curimage->sizex += 5;
		fread(&tmpint,sizeof(int),1,in);
		cur = (invert) ? bitwiseswap(tmpint) : tmpint;
		fseek(in,stripof,SEEK_SET);
		curimage->allocateBuffer();
		fread(curimage->data,sizeof(char),curimage->channels * curimage->sizex * curimage->sizey/8 + 1,in); // assumes a single strip...
		
		for(i = curimage->sizex * curimage->sizey -1;i>=0;i--){
			curimage->data[i] = ((curimage->data[i/8] >> (7 - (i & 7))) & 1 == 1) ? 0 : 255;
		}
		
		out.push_back(curimage);
	}
	
	fclose(in);
}


template< >
void Madstructs::Image<unsigned char> ::SaveTiffImage(vector<Madstructs::Image<unsigned char>* > &list, const char* path, int ignore, int nbchannels){
	FILE* out = fopen(path,"wb+");
	if (out == NULL){ 
		//		// LFHPrimitive::static_warning_handdle << LFH_WARNING_NO_FILE_HANDDLE_W;
		return;
	}
	char buffer[65536];
	buffer[0] = 'I';
	buffer[1] = 'I';
	*(short*)(buffer + 2) = 42;
	char *p;
	*(int*)(buffer + 4) = (list.size() == 0) ? 0 : 8;
	fwrite(buffer,sizeof(char),8,out);
	int x,y;
	int imc=0;
	int cur = 8;
	int nbflag;
	int extra;
 	if (nbchannels == 0) nbchannels = list[0]->channels;
	for(imc=0;imc<list.size();imc++){
		p = buffer;
		extra =0;
		nbflag = 14;
		*(short*)(p) = nbflag; 
		p+=2;
		
		*(short*)(p) = 254; 
		*(short*)(p+2) = 4; 
		*(int*)(p+4) = 1; 
		*(int*)(p+8) = 0; 
		p+=12;
		
		*(short*)(p) = 256; 
		*(short*)(p+2) = 4; 
		*(int*)(p+4) = 1; 
		*(int*)(p+8) = list[imc]->sizex; 
		p+=12;
		
		*(short*)(p) = 257; 
		*(short*)(p+2) = 4; 
		*(int*)(p+4) = 1; 
		*(int*)(p+8) = list[imc]->sizey; 
		p+=12;
		
		*(short*)(p) = 258; 
		*(short*)(p+2) = 3; 
		if (nbchannels == 1){
			*(int*)(p+4) = 1;
			*(short*)(p+8) = 8; //bitpersample
		}else{
			*(int*)(p+4) = 3;
			*(int*)(p+8) =cur + 6 + 12 * nbflag + extra;
			extra += sizeof(short)*3;
		}
		p+=12;
		
		*(short*)(p) = 259; 
		*(short*)(p+2) = 3; 
		*(int*)(p+4) = 1; 
		*(short*)(p+8) = 1; //compression
		p+=12;
		
		*(short*)(p) = 262; 
		*(short*)(p+2) = 3; 
		*(int*)(p+4) = 1;
		switch(nbchannels){//photothing
			case 1: *(short*)(p+8) = 1; break;
			case 2: *(short*)(p+8) = 1; break;
			default: *(short*)(p+8) = 2; break;
		}
		p+=12;
		
		*(short*)(p) = 282; 
		*(short*)(p+2) = 5; 
		*(int*)(p+4) = 1; 
		*(int*)(p+8) = cur + 6 + 12 * nbflag + extra;
		extra += sizeof(int)*2;
		p+=12;
		
		*(short*)(p) = 283; 
		*(short*)(p+2) = 5; 
		*(int*)(p+4) = 1; 
		*(int*)(p+8) = cur + 6 + 12 * nbflag + extra;
		extra += sizeof(int)*2;
		p+=12;
		
		*(short*)(p) = 273; 
		*(short*)(p+2) = 4; 
		*(int*)(p+4) = 1; 
		*(int*)(p+8) = cur + 6 + 12 * nbflag + extra; //data start
		p+=12;
		
		*(short*)(p) = 277; 
		*(short*)(p+2) = 3; 
		*(int*)(p+4) = 1; 
		*(short*)(p+8) = nbchannels; 
		p+=12;
		
		*(short*)(p) = 278; 
		*(short*)(p+2) = 4; 
		*(int*)(p+4) = 1; 
		*(int*)(p+8) = list[imc]->sizey; //Rowperstrip
		p+=12;
		
		*(short*)(p) = 279; 
		*(short*)(p+2) = 4; 
		*(int*)(p+4) = 1; 
		*(int*)(p+8) = list[imc]->sizex*list[imc]->sizey*nbchannels ; //NBbyte
		p+=12;
		
		*(short*)(p) = 284; 
		*(short*)(p+2) = 3; 
		*(int*)(p+4) = 1; 
		*(short*)(p+8) = 1; //planar_rep
		p+=12;
		
		*(short*)(p) = 296; 
		*(short*)(p+2) = 3; 
		*(int*)(p+4) = 1; 
		*(short*)(p+8) = 3; //unit
		p+=12;
		
		/*	*(short*)(p) = 339; 
		 *(short*)(p+2) = 3; 
		 *(int*)(p+4) = 1; 
		 *(short*)(p+8) = 3; //unit
		 p+=12;*/
		
		
		cur += 6 + 12*nbflag + extra + list[imc]->sizex* list[imc]->sizey* nbchannels;
		if ((imc + 1) == list.size()) cur = 0;
		*(int*)(p) = cur;
		
		if (list[imc]->channels == 1){
			*(int*)(p+4) = 1;
			*(int*)(p+8) = 1;
			*(int*)(p+12) = 1;
			*(int*)(p+16) = 1;
		}else{
			*(short*)(p+4) = 8;
			*(short*)(p+6) = 8;
			*(short*)(p+8) = 8;			
			*(int*)(p+10) = 1;
			*(int*)(p+14) = 1;
			*(int*)(p+18) = 1;
			*(int*)(p+22) = 1;
		}
		fwrite(buffer,sizeof(char), 6 + 12*nbflag + extra,out);
		if (nbchannels == list[imc]->channels)
			fwrite(list[imc]->data,sizeof(char), list[imc]->sizex* list[imc]->sizey* list[imc]->channels,out);
		else{
			for(y=0;y<list[imc]->sizey;y++){
				for(x=0;x<list[imc]->sizex;x++){
					fwrite(list[imc]->data + ignore +  list[imc]->channels * (x + y *list[imc]->sizey) ,sizeof(char), nbchannels,out);
				}}
		}
		
	}
	fclose(out);
	
}


template< >
void Madstructs::Image<unsigned short> ::SaveTiffImage(vector<Madstructs::Image<unsigned short>* > &list, const char* path, int ignore, int nbchannels){
	FILE* out = fopen(path,"wb+");
	if (out == NULL) exit(1);
	char buffer[65536];
	buffer[0] = 'I';
	buffer[1] = 'I';
	*(short*)(buffer + 2) = 42;
	char *p;
	*(int*)(buffer + 4) = (list.size() == 0) ? 0 : 8;
	fwrite(buffer,sizeof(char),8,out);
	int x,y;
	int imc=0;
	int cur = 8;
	int nbflag;
	int extra;
	if (nbchannels == 0) nbchannels = list[0]->channels;
	for(imc=0;imc<list.size();imc++){
		p = buffer;
		extra =0;
		nbflag = 14;
		*(short*)(p) = nbflag; 
		p+=2;
		
		*(short*)(p) = 254; 
		*(short*)(p+2) = 4; 
		*(int*)(p+4) = 1; 
		*(int*)(p+8) = 0; 
		p+=12;
		
		*(short*)(p) = 256; 
		*(short*)(p+2) = 4; 
		*(int*)(p+4) = 1; 
		*(int*)(p+8) = list[imc]->sizex; 
		p+=12;
		
		*(short*)(p) = 257; 
		*(short*)(p+2) = 4; 
		*(int*)(p+4) = 1; 
		*(int*)(p+8) = list[imc]->sizey; 
		p+=12;
		
		*(short*)(p) = 258; 
		*(short*)(p+2) = 3; 
		if (nbchannels == 1){
			*(int*)(p+4) = 1;
			*(short*)(p+8) = 16; //bitpersample
		}else{
			*(int*)(p+4) = 3;
			*(int*)(p+8) =cur + 6 + 12 * nbflag + extra;
			extra += sizeof(short)*3;
		}
		p+=12;
		
		*(short*)(p) = 259; 
		*(short*)(p+2) = 3; 
		*(int*)(p+4) = 1; 
		*(short*)(p+8) = 1; //compression
		p+=12;
		
		*(short*)(p) = 262; 
		*(short*)(p+2) = 3; 
		*(int*)(p+4) = 1;
		switch(nbchannels){//photothing
			case 1: *(short*)(p+8) = 1; break;
			case 2: *(short*)(p+8) = 1; break;
			default: *(short*)(p+8) = 2; break;
		}
		p+=12;
		
		*(short*)(p) = 282; 
		*(short*)(p+2) = 5; 
		*(int*)(p+4) = 1; 
		*(int*)(p+8) = cur + 6 + 12 * nbflag + extra;
		extra += sizeof(int)*2;
		p+=12;
		
		*(short*)(p) = 283; 
		*(short*)(p+2) = 5; 
		*(int*)(p+4) = 1; 
		*(int*)(p+8) = cur + 6 + 12 * nbflag + extra;
		extra += sizeof(int)*2;
		p+=12;
		
		*(short*)(p) = 273; 
		*(short*)(p+2) = 4; 
		*(int*)(p+4) = 1; 
		*(int*)(p+8) = cur + 6 + 12 * nbflag + extra; //data start
		p+=12;
		
		*(short*)(p) = 277; 
		*(short*)(p+2) = 3; 
		*(int*)(p+4) = 1; 
		*(short*)(p+8) = nbchannels; 
		p+=12;
		
		*(short*)(p) = 278; 
		*(short*)(p+2) = 4; 
		*(int*)(p+4) = 1; 
		*(int*)(p+8) = list[imc]->sizey; //Rowperstrip
		p+=12;
		
		*(short*)(p) = 279; 
		*(short*)(p+2) = 4; 
		*(int*)(p+4) = 1; 
		*(int*)(p+8) = list[imc]->sizex*list[imc]->sizey*nbchannels*2; //NBbyte
		p+=12;
		
		*(short*)(p) = 284; 
		*(short*)(p+2) = 3; 
		*(int*)(p+4) = 1; 
		*(short*)(p+8) = 1; //planar_rep
		p+=12;
		
		*(short*)(p) = 296; 
		*(short*)(p+2) = 3; 
		*(int*)(p+4) = 1; 
		*(short*)(p+8) = 3; //unit
		p+=12;
		
		/*	*(short*)(p) = 339; 
		 *(short*)(p+2) = 3; 
		 *(int*)(p+4) = 1; 
		 *(short*)(p+8) = 3; //unit
		 p+=12;*/
		
		
		cur += 6 + 12*nbflag + extra + list[imc]->sizex* list[imc]->sizey* nbchannels*2;
		if ((imc + 1) == list.size()) cur = 0;
		*(int*)(p) = cur;
		
		if (list[imc]->channels == 1){
			*(int*)(p+4) = 1;
			*(int*)(p+8) = 1;
			*(int*)(p+12) = 1;
			*(int*)(p+16) = 1;
		}else{
			*(short*)(p+4) = 16;
			*(short*)(p+6) = 16;
			*(short*)(p+8) = 16;			
			*(int*)(p+10) = 1;
			*(int*)(p+14) = 1;
			*(int*)(p+18) = 1;
			*(int*)(p+22) = 1;
		}
		fwrite(buffer,sizeof(char), 6 + 12*nbflag + extra,out);
		if (nbchannels == list[imc]->channels)
			fwrite(list[imc]->data,sizeof(unsigned short), list[imc]->sizex* list[imc]->sizey* list[imc]->channels,out);
		else{
			for(y=0;y<list[imc]->sizey;y++){
				for(x=0;x<list[imc]->sizex;x++){
					fwrite(list[imc]->data + ignore +  list[imc]->channels * (x + y *list[imc]->sizey) ,sizeof(char), nbchannels,out);
				}}
		}
		
	}
	fclose(out);
	
}

template< >
void Madstructs::Image<float>::LoadTiffImage(vector<Madstructs::Image<float>* > &out, const char* path){
	FILE* in = fopen(path,"rb+");
	if (in == NULL) return;
	char buffer[65536];
	fread(buffer,sizeof(char),8,in);
	stack<int> s;
	int cur = *((int*)(buffer + 4));
	int i;
	Madstructs::Image<float>* curimage;
	void* target;
	int type;
	
	int stripof; // address
	int stripco;
	int stripro;
	//	int nbstrip;
	
	int fieldsize;
	while(cur != 0){
		curimage = new Madstructs::Image<float>();
		fseek(in,cur,SEEK_SET);
		fread(buffer,sizeof(short),1,in);
		i = *((short*)(buffer));
		for(i--;i>=0;i--){
			fread(buffer,sizeof(char),12,in);
			
			switch(*((short*)(buffer))){
					//			case 254:memcpy(buffer+512,"NewSubfileType",sizeof(char)*15);break;
				case 256:target = (void*)&(curimage->sizex); type =4; break;//memcpy(buffer+512,"ImageWidth",sizeof(char)*11);break;
				case 257:target = (void*)&(curimage->sizey); type =4; break;//memcpy(buffer+512,"ImageHeight",sizeof(char)*12);break;
					//			case 258:memcpy(buffer+512,"BitsPerSample",sizeof(char)*14);break;
					//			case 259:memcpy(buffer+512,"Compression",sizeof(char)*12);break;
					//			case 262:memcpy(buffer+512,"PhotometricInterpretation",sizeof(char)*26);break; 
				case 273:target = (void*)&(stripof); type =4; break;//memcpy(buffer+512,"SkipOffsets",sizeof(char)*12);break;
					//			case 274:memcpy(buffer+512,"Orientation",sizeof(char)*12);break;
				case 277:target = (void*)&(curimage->channels); type =4; break;//memcpy(buffer+512,"SamplesPerPixel",sizeof(char)*16);break;
				case 278:target = (void*)&(stripro); type =4; break;//memcpy(buffer+512,"RowsPerStrip",sizeof(char)*13);break;
				case 279:target = (void*)&(stripco); type =4; break;//memcpy(buffer+512,"StripByteCounts",sizeof(char)*16);break;
					//			case 282:memcpy(buffer+512,"XResolution",sizeof(char)*12);break;
					//			case 283:memcpy(buffer+512,"YResolution",sizeof(char)*12);break;
					//			case 296:memcpy(buffer+512,"ResolutionUnit",sizeof(char)*15);break;
				default: target = NULL; //memcpy(buffer+512,"",sizeof(char)*1);
			}
			
			switch(*((short*)(buffer+2))){
				case 1:fieldsize = sizeof(char);break;//memcpy(buffer+256,"BYTE",sizeof(char)*5);break;
				case 2:fieldsize = sizeof(char);break;//memcpy(buffer+256,"ASCII",sizeof(char)*6);break;
				case 3:fieldsize = sizeof(short);break;//memcpy(buffer+256,"SHORT",sizeof(char)*6);break;
				case 4:fieldsize = sizeof(int);break;//memcpy(buffer+256,"LONG",sizeof(char)*5);break;
				case 5:fieldsize = sizeof(int)*2;break;//memcpy(buffer+256,"RATIONAL",sizeof(char)*9);break;
				case 6:fieldsize = sizeof(char);break;//memcpy(buffer+256,"SBYTE",sizeof(char)*6);break;
				case 7:fieldsize = sizeof(char);break;//memcpy(buffer+256,"UNDEFINED",sizeof(char)*10);break;
				case 8:fieldsize = sizeof(short);break;//memcpy(buffer+256,"SSHORT",sizeof(char)*7);break;
				case 9:fieldsize = sizeof(int);break;//memcpy(buffer+256,"SLONG",sizeof(char)*6);break;
				case 10:fieldsize = sizeof(int)*2;break;//memcpy(buffer+256,"SRATIONAL",sizeof(char)*10);break;
				case 11:fieldsize = sizeof(float)*2;break;//memcpy(buffer+256,"FLOAT",sizeof(char)*6);break;
				case 12:fieldsize = sizeof(double)*2;break;//memcpy(buffer+256,"DOUBLE",sizeof(char)*7);break;
				default: memcpy(buffer+256,"UNKNOWN",sizeof(char)*8);
			}
			if (target != NULL){
				if ((*((int*)(buffer+4)))*fieldsize <= 4){
					switch(*((short*)(buffer+2))){
						case 1: if (type == 4) *((int*)target) = (int) *((char*)(buffer + 8)); break;
						case 2: if (type == 4) *((int*)target) = (int) *((char*)(buffer + 8)); break;
						case 3: if (type == 4) *((int*)target) = (int) *((short*)(buffer + 8)); break;
						case 4: if (type == 4) *((int*)target) = (int) *((int*)(buffer + 8)); break;
					}
				}else{
					// for now, that's not used
					
				}
			}
			
		}
		fread(&cur,sizeof(int),1,in);
		fseek(in,stripof,SEEK_SET);
		curimage->allocateBuffer();
		fread(curimage->data,sizeof(float),curimage->channels * curimage->sizex * curimage->sizey,in); // assumes a single strip...
		
		out.push_back(curimage);
	}
	
	fclose(in);
}


template< >
void Madstructs::Image<float>::SaveTiffImage(vector<Madstructs::Image<float>* > &list, const char* path, int ignore, int nbchannels){
	FILE* out = fopen(path,"wb+");
	char buffer[65536];
	buffer[0] = 'I';
	buffer[1] = 'I';
	*(short*)(buffer + 2) = 42;
	char *p;
	*(int*)(buffer + 4) = (list.size() == 0) ? 0 : 8;
	fwrite(buffer,sizeof(char),8,out);
	int imc=0;
	int cur = 8;
	int nbflag;
	int extra;
	for(imc=0;imc<list.size();imc++){
		p = buffer;
		extra =0;
		nbflag = 18;
		*(short*)(p) = nbflag; 
		p+=2;
		
		*(short*)(p) = 254; 
		*(short*)(p+2) = 4; 
		*(int*)(p+4) = 1; 
		*(int*)(p+8) = 0; 
		p+=12;
		
		*(short*)(p) = 256; 
		*(short*)(p+2) = 4; 
		*(int*)(p+4) = 1; 
		*(int*)(p+8) = list[imc]->sizex; 
		p+=12;
		
		*(short*)(p) = 257; 
		*(short*)(p+2) = 4; 
		*(int*)(p+4) = 1; 
		*(int*)(p+8) = list[imc]->sizey; 
		p+=12;
		
		*(short*)(p) = 258; 
		*(short*)(p+2) = 3; 
		if (list[imc]->channels == 1){
			*(int*)(p+4) = 1;
			*(short*)(p+8) = 8* sizeof(float); //bitpersample
		}else{
			*(int*)(p+4) = 3;
			*(int*)(p+8) =cur + 6 + 12 * nbflag + extra;
			extra += sizeof(short)*3;
		}
		p+=12;
		
		*(short*)(p) = 259; 
		*(short*)(p+2) = 3; 
		*(int*)(p+4) = 1; 
		*(short*)(p+8) = 1; //compression
		p+=12;
		
		*(short*)(p) = 262; 
		*(short*)(p+2) = 3; 
		*(int*)(p+4) = 1;
		switch(list[imc]->channels){//photothing
			case 1: *(short*)(p+8) = 1; break;
			case 2: *(short*)(p+8) = 1; break;
			default: *(short*)(p+8) = 2; break;
		}
		p+=12;
		
		*(short*)(p) = 282; 
		*(short*)(p+2) = 5; 
		*(int*)(p+4) = 1; 
		*(int*)(p+8) = cur + 6 + 12 * nbflag + extra;
		extra += sizeof(int)*2;
		p+=12;
		
		*(short*)(p) = 283; 
		*(short*)(p+2) = 5; 
		*(int*)(p+4) = 1; 
		*(int*)(p+8) = cur + 6 + 12 * nbflag + extra;
		extra += sizeof(int)*2;
		p+=12;
		
		*(short*)(p) = 273; 
		*(short*)(p+2) = 4; 
		*(int*)(p+4) = 1; 
		*(int*)(p+8) = cur + 6 + 12 * nbflag + extra; //data start
		p+=12;
		
		*(short*)(p) = 277; 
		*(short*)(p+2) = 3; 
		*(int*)(p+4) = 1; 
		*(short*)(p+8) = list[imc]->channels; 
		p+=12;
		
		*(short*)(p) = 278; 
		*(short*)(p+2) = 4; 
		*(int*)(p+4) = 1; 
		*(int*)(p+8) = list[imc]->sizey; //Rowperstrip
		p+=12;
		
		*(short*)(p) = 279; 
		*(short*)(p+2) = 4; 
		*(int*)(p+4) = 1; 
		*(int*)(p+8) = list[imc]->sizex*list[imc]->sizey*list[imc]->channels * sizeof(float); //NBbyte
		p+=12;
		
		
		*(short*)(p) = 284; 
		*(short*)(p+2) = 3; 
		*(int*)(p+4) = 1; 
		*(short*)(p+8) = 1; //planar_rep
		p+=12;
		
		*(short*)(p) = 296; 
		*(short*)(p+2) = 3; 
		*(int*)(p+4) = 1; 
		*(short*)(p+8) = 0; //unit
		p+=12;
		
		*(short*)(p) = 338; // extra sample meaning
		*(short*)(p+2) = 3; 
		*(int*)(p+4) = 1; 
		*(short*)(p+8) = 0; 
		p+=12;
		
		*(short*)(p) = 339; 
		*(short*)(p+2) = 3; 
		*(int*)(p+4) = 1; 
		*(short*)(p+8) = 3; //format
		p+=12;
		
		*(short*)(p) = 340; 
		*(short*)(p+2) = 4; 
		*(int*)(p+4) = 1; 
		*(int*)(p+8) = 0; //min value
		p+=12;
		
		*(short*)(p) = 341; 
		*(short*)(p+2) = 4; 
		*(int*)(p+4) = 1; 
		*(int*)(p+8) = 1; //max value
		p+=12;
		
		cur += 6 + 12*nbflag + extra + list[imc]->sizex* list[imc]->sizey* list[imc]->channels*sizeof(float);
		
		if ((imc + 1) == list.size()) cur = 0;
		*(int*)(p) = cur;
		
		if (list[imc]->channels == 1){
			*(int*)(p+4) = 1;
			*(int*)(p+8) = 1;
			*(int*)(p+12) = 1;
			*(int*)(p+16) = 1;
		}else{
			*(short*)(p+4) = 8* sizeof(float);
			*(short*)(p+6) = 8* sizeof(float);
			*(short*)(p+8) = 8* sizeof(float);			
			*(int*)(p+10) = 1;
			*(int*)(p+14) = 1;
			*(int*)(p+18) = 1;
			*(int*)(p+22) = 1;
		}
		fwrite(buffer,sizeof(char), 6 + 12*nbflag + extra,out);
		
		fwrite(list[imc]->data,sizeof(float), list[imc]->sizex* list[imc]->sizey* list[imc]->channels,out);
		
	}
	fclose(out);
	
}



template< >
void Madstructs::Image<double>::LoadTiffImage(vector<Madstructs::Image<double>* > &out, const char* path){
	FILE* in = fopen(path,"rb+");
	if (in == NULL){ 
		// // LFHPrimitive::static_warning_handdle << LFH_WARNING_NO_FILE_HANDDLE_R;
		return;
	}
	char buffer[65536];
	fread(buffer,sizeof(char),8,in);
	stack<int> s;
	int cur = *((int*)(buffer + 4));
	int i;
	Madstructs::Image<double>* curimage;
	void* target;
	int type;
	
	int stripof; // address
	int stripco;
	int stripro;
	//	int nbstrip;
	
	int fieldsize;
	while(cur != 0){
		curimage = new Madstructs::Image<double>();
		fseek(in,cur,SEEK_SET);
		fread(buffer,sizeof(short),1,in);
		i = *((short*)(buffer));
		for(i--;i>=0;i--){
			fread(buffer,sizeof(char),12,in);
			
			switch(*((short*)(buffer))){
					//			case 254:memcpy(buffer+512,"NewSubfileType",sizeof(char)*15);break;
				case 256:target = (void*)&(curimage->sizex); type =4; break;//memcpy(buffer+512,"ImageWidth",sizeof(char)*11);break;
				case 257:target = (void*)&(curimage->sizey); type =4; break;//memcpy(buffer+512,"ImageHeight",sizeof(char)*12);break;
					//			case 258:memcpy(buffer+512,"BitsPerSample",sizeof(char)*14);break;
					//			case 259:memcpy(buffer+512,"Compression",sizeof(char)*12);break;
					//			case 262:memcpy(buffer+512,"PhotometricInterpretation",sizeof(char)*26);break; 
				case 273:target = (void*)&(stripof); type =4; break;//memcpy(buffer+512,"SkipOffsets",sizeof(char)*12);break;
					//			case 274:memcpy(buffer+512,"Orientation",sizeof(char)*12);break;
				case 277:target = (void*)&(curimage->channels); type =4; break;//memcpy(buffer+512,"SamplesPerPixel",sizeof(char)*16);break;
				case 278:target = (void*)&(stripro); type =4; break;//memcpy(buffer+512,"RowsPerStrip",sizeof(char)*13);break;
				case 279:target = (void*)&(stripco); type =4; break;//memcpy(buffer+512,"StripByteCounts",sizeof(char)*16);break;
					//			case 282:memcpy(buffer+512,"XResolution",sizeof(char)*12);break;
					//			case 283:memcpy(buffer+512,"YResolution",sizeof(char)*12);break;
					//			case 296:memcpy(buffer+512,"ResolutionUnit",sizeof(char)*15);break;
				default: target = NULL; //memcpy(buffer+512,"",sizeof(char)*1);
			}
			
			switch(*((short*)(buffer+2))){
				case 1:fieldsize = sizeof(char);break;//memcpy(buffer+256,"BYTE",sizeof(char)*5);break;
				case 2:fieldsize = sizeof(char);break;//memcpy(buffer+256,"ASCII",sizeof(char)*6);break;
				case 3:fieldsize = sizeof(short);break;//memcpy(buffer+256,"SHORT",sizeof(char)*6);break;
				case 4:fieldsize = sizeof(int);break;//memcpy(buffer+256,"LONG",sizeof(char)*5);break;
				case 5:fieldsize = sizeof(int)*2;break;//memcpy(buffer+256,"RATIONAL",sizeof(char)*9);break;
				case 6:fieldsize = sizeof(char);break;//memcpy(buffer+256,"SBYTE",sizeof(char)*6);break;
				case 7:fieldsize = sizeof(char);break;//memcpy(buffer+256,"UNDEFINED",sizeof(char)*10);break;
				case 8:fieldsize = sizeof(short);break;//memcpy(buffer+256,"SSHORT",sizeof(char)*7);break;
				case 9:fieldsize = sizeof(int);break;//memcpy(buffer+256,"SLONG",sizeof(char)*6);break;
				case 10:fieldsize = sizeof(int)*2;break;//memcpy(buffer+256,"SRATIONAL",sizeof(char)*10);break;
				case 11:fieldsize = sizeof(float)*2;break;//memcpy(buffer+256,"FLOAT",sizeof(char)*6);break;
				case 12:fieldsize = sizeof(double)*2;break;//memcpy(buffer+256,"DOUBLE",sizeof(char)*7);break;
				default: memcpy(buffer+256,"UNKNOWN",sizeof(char)*8);
			}
			if (target != NULL){
				if ((*((int*)(buffer+4)))*fieldsize <= 4){
					switch(*((short*)(buffer+2))){
						case 1: if (type == 4) *((int*)target) = (int) *((char*)(buffer + 8)); break;
						case 2: if (type == 4) *((int*)target) = (int) *((char*)(buffer + 8)); break;
						case 3: if (type == 4) *((int*)target) = (int) *((short*)(buffer + 8)); break;
						case 4: if (type == 4) *((int*)target) = (int) *((int*)(buffer + 8)); break;
					}
				}else{
					// for now, that's not used
					
				}
			}
			
		}
		fread(&cur,sizeof(int),1,in);
		fseek(in,stripof,SEEK_SET);
		curimage->allocateBuffer();
		fread(curimage->data,sizeof(double),curimage->channels * curimage->sizex * curimage->sizey,in); // assumes a single strip...
		
		out.push_back(curimage);
	}
	
	fclose(in);
}


template< >
void Madstructs::Image<double> ::SaveTiffImage(vector<Madstructs::Image<double>* > &list, const char* path, int ignore, int nbchannels){
	FILE* out = fopen(path,"wb+");
	if (out == NULL){ 
		// LFHPrimitive::static_warning_handdle << LFH_WARNING_NO_FILE_HANDDLE_W;
		return;
	}
	char buffer[65536];
	buffer[0] = 'I';
	buffer[1] = 'I';
	if (nbchannels == 0) nbchannels = list[0]->channels - ignore;
	*(short*)(buffer + 2) = 42;
	char *p;
	*(int*)(buffer + 4) = (list.size() == 0) ? 0 : 8;
	int x,y;
	fwrite(buffer,sizeof(char),8,out);
	int imc=0;
	int cur = 8;
	int nbflag;
	int extra;
	for(imc=0;imc<list.size();imc++){
		p = buffer;
		extra =0;
		nbflag = 17;
		*(short*)(p) = nbflag; 
		p+=2;
		
		*(short*)(p) = 254; 
		*(short*)(p+2) = 4; 
		*(int*)(p+4) = 1; 
		*(int*)(p+8) = 0; 
		p+=12;
		
		*(short*)(p) = 256; 
		*(short*)(p+2) = 4; 
		*(int*)(p+4) = 1; 
		*(int*)(p+8) = list[imc]->sizex; 
		p+=12;
		
		*(short*)(p) = 257; 
		*(short*)(p+2) = 4; 
		*(int*)(p+4) = 1; 
		*(int*)(p+8) = list[imc]->sizey; 
		p+=12;
		
		*(short*)(p) = 258; 
		*(short*)(p+2) = 3; 
		if (nbchannels == 1){
			*(int*)(p+4) = 1;
			*(short*)(p+8) = 8* sizeof(double); //bitpersample
		}else{
			*(int*)(p+4) = 3;
			*(int*)(p+8) =cur + 6 + 12 * nbflag + extra;
			extra += sizeof(short)*3;
		}
		p+=12;
		
		*(short*)(p) = 259; 
		*(short*)(p+2) = 3; 
		*(int*)(p+4) = 1; 
		*(short*)(p+8) = 1; //compression
		p+=12;
		
		*(short*)(p) = 262; 
		*(short*)(p+2) = 3; 
		*(int*)(p+4) = 1;
		switch(nbchannels){//photothing
			case 1: *(short*)(p+8) = 1; break;
			case 2: *(short*)(p+8) = 1; break;
			default: *(short*)(p+8) = 2; break;
		}
		p+=12;
		
		*(short*)(p) = 282; 
		*(short*)(p+2) = 5; 
		*(int*)(p+4) = 1; 
		*(int*)(p+8) = cur + 6 + 12 * nbflag + extra;
		extra += sizeof(int)*2;
		p+=12;
		
		*(short*)(p) = 283; 
		*(short*)(p+2) = 5; 
		*(int*)(p+4) = 1; 
		*(int*)(p+8) = cur + 6 + 12 * nbflag + extra;
		extra += sizeof(int)*2;
		p+=12;
		
		*(short*)(p) = 273; 
		*(short*)(p+2) = 4; 
		*(int*)(p+4) = 1; 
		*(int*)(p+8) = cur + 6 + 12 * nbflag + extra; //data start
		p+=12;
		
		*(short*)(p) = 277; 
		*(short*)(p+2) = 3; 
		*(int*)(p+4) = 1; 
		*(short*)(p+8) = nbchannels; 
		p+=12;
		
		*(short*)(p) = 278; 
		*(short*)(p+2) = 4; 
		*(int*)(p+4) = 1; 
		*(int*)(p+8) = list[imc]->sizey; //Rowperstrip
		p+=12;
		
		*(short*)(p) = 279; 
		*(short*)(p+2) = 4; 
		*(int*)(p+4) = 1; 
		*(int*)(p+8) = list[imc]->sizex*list[imc]->sizey*nbchannels* sizeof(double); //NBbyte
		p+=12;
		
		*(short*)(p) = 284; 
		*(short*)(p+2) = 3; 
		*(int*)(p+4) = 1; 
		*(short*)(p+8) = 1; //planar_rep
		p+=12;
		
		*(short*)(p) = 296; 
		*(short*)(p+2) = 3; 
		*(int*)(p+4) = 1; 
		*(short*)(p+8) = 3; //unit
		p+=12;
		
		*(short*)(p) = 339; 
		*(short*)(p+2) = 3; 
		*(int*)(p+4) = 1; 
		*(short*)(p+8) = 3; //unit
		p+=12;
		
		*(short*)(p) = 340; 
		*(short*)(p+2) = 11; 
		*(int*)(p+4) = 1; 
		*(float*)(p+8) = 0.0; //min value
		p+=12;
		
		*(short*)(p) = 341; 
		*(short*)(p+2) = 11; 
		*(int*)(p+4) = 1; 
		*(float*)(p+8) = 1.0f; //max value
		p+=12;
		
		cur += 6 + 12*nbflag + extra + list[imc]->sizex* list[imc]->sizey* nbchannels*sizeof(double);
		if ((imc + 1) == list.size()) cur = 0;
		*(int*)(p) = cur;
		
		if (nbchannels == 1){
			*(int*)(p+4) = 1;
			*(int*)(p+8) = 1;
			*(int*)(p+12) = 1;
			*(int*)(p+16) = 1;
		}else{
			*(short*)(p+4) = 8* sizeof(double);
			*(short*)(p+6) = 8* sizeof(double);
			*(short*)(p+8) = 8* sizeof(double);			
			*(int*)(p+10) = 1;
			*(int*)(p+14) = 1;
			*(int*)(p+18) = 1;
			*(int*)(p+22) = 1;
		}
		fwrite(buffer,sizeof(char), 6 + 12*nbflag + extra,out);
		
		
		if (nbchannels == list[imc]->channels)
			fwrite(list[imc]->data,sizeof(double), list[imc]->sizex* list[imc]->sizey* list[imc]->channels,out);
		else{
			for(y=0;y<list[imc]->sizey;y++){
				for(x=0;x<list[imc]->sizex;x++){
					fwrite(list[imc]->data + ignore +  list[imc]->channels * (x + y *list[imc]->sizey) ,sizeof(double), nbchannels,out);
				}}
		}
		
	}
	fclose(out);
	
}


template< >
void Madstructs::Image<double>::loadRawImage(char* path){
	FILE *f = fopen(path,"rb+");
	if (f == NULL){ 
		// LFHPrimitive::static_warning_handdle << LFH_WARNING_NO_FILE_HANDDLE_R;
		return;
	}
	fread(&sizex,sizeof(int),1,f);
	fread(&sizey,sizeof(int),1,f);
	fread(&channels,sizeof(int),1,f);
	allocateBuffer();
	
	fread(data,sizeof(double),sizex*sizey*channels,f);
	fclose(f);
}
template< >
void Madstructs::Image<double>::saveRawImage(char* path){
	FILE *f = fopen(path,"wb+");
	if (f == NULL){ 
		// LFHPrimitive::static_warning_handdle << LFHPrimitive::LFH_WARNING_NO_FILE_HANDDLE_W;
		return;
	}
	
	fwrite(&sizex,sizeof(int),1,f);
	fwrite(&sizey,sizeof(int),1,f);
	fwrite(&channels,sizeof(int),1,f);
	
	fwrite(data,sizeof(double),sizex*sizey*channels,f);
	fclose(f);
}

template< > 
Madstructs::Image<unsigned char>* Madstructs::Image<unsigned char>::makeImageFromFunction(int sizex, int sizey, Madstructs::Evaluatable* T){
	Madstructs::Image<unsigned char>* newout = new Madstructs::Image<unsigned char>();
	int x,y,z;
	newout->sizex = sizex;
	newout->sizey = sizey;
	newout->channels = T->outputsize();
	newout->allocateBuffer();
	double pox[256]; 
	double coor[32];
	for(y=0;y<sizey;y++){
		coor[1] = y;
		for(x=0;x<sizex;x++){
			coor[0] = x;
			T->eval(coor,pox);
			for(z=0;z<newout->channels;z++) newout->data[z + newout->channels*(x + y*sizex)] = (unsigned char)(pox[z] * 255.0f);
		}
	}
	return(newout);
}

template< > 
Madstructs::Image<unsigned char>* Madstructs::Image<unsigned char>::makeImageFromFunction(int sx, int sy,int sizex, int sizey, Madstructs::Evaluatable* T){
	Madstructs::Image<unsigned char>* newout = new Madstructs::Image<unsigned char>();
	int x,y,z;
	newout->sizex = sizex;
	newout->sizey = sizey;
	newout->channels = T->outputsize();
	newout->allocateBuffer();
	double pox[256];
	double coor[32];
	for(y=0;y<sizey;y++){
		coor[1] = sy+y;
		for(x=0;x<sizex;x++){
			coor[0] = sx+x;
			T->eval(coor,pox);
			for(z=0;z<newout->channels;z++) newout->data[z + newout->channels*(x + y*sizex)] = (unsigned char)(pox[z] * 255.0f);
			newout->data[2 + newout->channels*(x + y*sizex)] =0;
		}
	}
	return(newout);
}


template< >
void Madstructs::Image<unsigned char>::makeImageFromChannels(vector<Madstructs::Image<unsigned char> *> &srclist, vector<int> &srcchan){
	channels = srclist.size();
	Madstructs::Image<unsigned char> * cur = NULL;
	int i;
	for(i=0;i<srclist.size();i++){
		if (srclist[i] != NULL) {cur = srclist[i];break;}
	}
	if (cur == NULL) exit(123);
	sizex = cur->sizex;
	sizey = cur->sizey;
	channels = srcchan.size();
	data = new unsigned char[sizex*sizey*channels];
	memset(data,'\0',sizeof(char)*sizex*sizey*channels);
	int x,y,z,n;
	for(i=0;i<srclist.size();i++){
		cur = srclist[i];
		
		if (cur != NULL){
			n = cur->channels;
			z = srcchan[i];
			for(x=0;x<sizex;x++){
				for(y=0;y<sizey;y++){
					data[i + (y*sizex +x)*channels] = cur->data[z + (y*sizex +x)*n];
				}
			}}
	}
	
}

template< >
void Madstructs::Image<unsigned short> ::makeImageFromChannels(vector<Madstructs::Image<unsigned short> *> &srclist, vector<int> &srcchan){
	channels = srclist.size();
	Madstructs::Image<unsigned short> * cur = NULL;
	int i;
	for(i=0;i<srclist.size();i++){
		if (srclist[i] != NULL) {cur = srclist[i];break;}
	}
	if (cur == NULL) exit(123);
	sizex = cur->sizex;
	sizey = cur->sizey;
	channels = srcchan.size();
	data = new unsigned short[sizex*sizey*channels];
	memset(data,'\0',sizeof(unsigned short)*sizex*sizey*channels);
	int x,y,z,n;
	for(i=0;i<srclist.size();i++){
		cur = srclist[i];
		
		if (cur != NULL){
			n = cur->channels;
			z = srcchan[i];
			for(x=0;x<sizex;x++){
				for(y=0;y<sizey;y++){
					data[i + (y*sizex +x)*channels] = cur->data[z + (y*sizex +x)*n];
				}
			}}
	}
	
}



template< >
void Madstructs::Image<unsigned int> ::addPixel(int x, int y, double *out, double factor){
	int i;
	for(i=0;i<channels;i++){
		data[(x + y * sizex)*channels+i] += (unsigned int) (out[i]*255.0f * factor);
	}
}

template< >
void Madstructs::Image<double> ::addPixel(int x, int y, double *out, double factor){
	int i;
	for(i=0;i<channels;i++){
		data[(x + y * sizex)*channels+i] += out[i] * factor;
	}
}


template<>
void Madstructs::Image<unsigned char>::getPixel(int x, int y, double *outp){
	int i;
	for(i=0;i<channels;i++){
		outp[i] = ((double)data[(x + y * sizex)*channels+i]) / 255.0f;
	}
}
template<>
void Madstructs::Image<unsigned short>::getPixel(int x, int y, double *outp){
	int i;
	for(i=0;i<channels;i++){
		outp[i] = ((double)data[(x + y * sizex)*channels+i]) / 65535.0f;
	}
}
template<>
void Madstructs::Image<unsigned int>::getPixel(int x, int y, double *outp){
	int i;
	for(i=0;i<channels;i++){
		outp[i] = ((double)data[(x + y * sizex)*channels+i]) / 0xFFFFFFFF;
	}
}


template< >
void Madstructs::Image<float>::getPixel(int x, int y, double *outp){
	int i;
	for(i=0;i<channels;i++){
		outp[i] = data[(x + y * sizex)*channels+i];
	}
}

template< >
void Madstructs::Image<double>::getPixel(int x, int y, double *outp){
	memcpy(outp,data + (x + y * sizex)*channels, sizeof(double)*channels);
}

template< >
void Madstructs::Image<float>::setPixel(int x, int y, double *outp){
	int i;
	for(i=0;i<channels;i++){
		data[(x + y * sizex)*channels+i] = outp[i];
	}
}

template< >
void Madstructs::Image<double>::setPixel(int x, int y, double *outp){
	memcpy(data + (x + y * sizex)*channels,outp, sizeof(double)*channels);
}

template< >
void Madstructs::Image<unsigned char>::setPixel(int x, int y, double *outp){
	int i,j;
	for(i=0;i<channels;i++){
		j = (int)(outp[i] * 255.1f);
		if (j >= 256) j=255;
		data[(x + y * sizex)*channels+i] = j;
	}
}
template< >
void Madstructs::Image<unsigned short>::setPixel(int x, int y, double *outp){
	int i,j;
	for(i=0;i<channels;i++){
		j = (int)(outp[i] * 65535.1f);
		if (j >= 65535) j=65535;
		data[(x + y * sizex)*channels+i] = j;
	}
}
template< >
void Madstructs::Image<unsigned int>::setPixel(int x, int y, double *outp){
	int i;
	for(i=0;i<channels;i++){
		data[(x + y * sizex)*channels+i] = (unsigned int) (outp[i] * (pow(2.0f,32.0f) -1.0f));
	}
}


template< >
void Madstructs::Image<unsigned char>::GradientFilter(Madstructs::Image<unsigned char>* out){
	double buffer[4][32];
	double obuffer[32];
	int x,y,z;
	double tmp,tmp2;
	for(x=1;x<sizex-1;x++){
		for(y=1;y<sizey-1;y++){
			getPixel(x-1,y,buffer[0]);
			getPixel(x+1,y,buffer[1]);
			getPixel(x,y-1,buffer[2]);
			getPixel(x,y+1,buffer[3]);
			for(z=0;z<channels;z++) {
				//			obuffer[z] =(fabs(buffer[0][z] - buffer[1][z]) +fabs(buffer[2][z] - buffer[3][z]))/4;
				tmp2 = buffer[0][z]+buffer[1][z]+buffer[2][z]+buffer[3][z];
				if (tmp2 == 0.0f) obuffer[z] = 0;
				else {tmp = buffer[0][z] - buffer[1][z]; obuffer[z] = tmp*tmp;
					tmp = buffer[2][z] - buffer[3][z]; tmp = tmp2*tmp2*(sqrt((obuffer[z] + tmp*tmp)) / (10 +tmp2));
					if (tmp > 255.0f) obuffer[z] =255.0f;
					else obuffer[z] = tmp;
				}
			} 
			out->setPixel(x,y,obuffer);
		}
	}
}


template< >
void Madstructs::Image<unsigned short>::GradientFilter(Madstructs::Image<unsigned short>* out){
	double buffer0[32];
	double buffer1[32];
	double buffer2[32];
	double buffer3[32];
	double buffer4[32];
	double obuffer[32];
	int x,y,z;
	double tmp,tmp2;
	for(x=0;x<sizex;x++){
		for(y=0;y<sizey;y++){
			if (x > 0) getPixel(x-1,y,buffer0);
			else memset(buffer0 ,'\0', sizeof(double)*32);
			if (x < sizex-1) getPixel(x+1,y,buffer1);
			else memset(buffer1 ,'\0', sizeof(double)*32);
			if (y > 0) getPixel(x,y-1,buffer2);
			else memset(buffer2 ,'\0', sizeof(double)*32);
			if (y < sizey-1) getPixel(x,y+1,buffer3);
			else memset(buffer3 ,'\0', sizeof(double)*32);
			getPixel(x,y,buffer4);
			for(z=0;z<channels;z++) {
				//			obuffer[z] =(fabs(buffer[0][z] - buffer[1][z]) +fabs(buffer[2][z] - buffer[3][z]))/4;
				tmp2 = buffer0[z]+buffer1[z]+buffer2[z]+buffer3[z];
				if (tmp2 == 0.0f) obuffer[z] = 0;
				else {tmp = buffer0[z] - buffer1[z]; obuffer[z] = tmp*tmp;
					tmp = buffer2[z] - buffer3[z];
					tmp = sqrt(sqrt(buffer4[z]*tmp2)*sqrt((obuffer[z] + tmp*tmp)));
					//					tmp = tmp2*tmp2*sqrt((obuffer[z] + tmp*tmp)) / (10.0f +tmp2);
					if (tmp > 1.0f) obuffer[z] =1.0f;
					else obuffer[z] = tmp;
				}
			} 
			out->setPixel(x,y,obuffer);
		}
	}
}


template< >
void Madstructs::Image<float>::BFpropagation(double *transit, double *bounds, int dir, Madstructs::Image<float>* out){
	int x,y,nbx,nby,z,w;
	if (dir == 0){
		nbx = sizex;
		nby = sizey;
	}else{
		nbx = sizey;
		nby = sizex;
	}
	double* back = new double[nby* channels];
	double* tmpb = new double[channels];
	double* tmpb2 = new double[channels];
	double* swp;
	double tmp;
	double sigweight[2];
	sigweight[0] = 20;
	sigweight[1] = 20;
	double buffer[32];
	for(x=0;x<nbx;x++){
		memset(back,'\0',sizeof(double)*channels*nby);
		for(z=0;z<channels;z++)	back[z+(nby-1)*channels] = 1.0f;
		for(y=nby-2;y>=0;y--){
			//backward
			if (dir == 0) getPixel(x,y,buffer); else getPixel(y,x,buffer);
			for(z=0;z<channels;z++){
				tmp = back[z+(y+1)*channels] * (bounds[z] + buffer[z] * sigweight[z]) / (sigweight[z]+1);
				for(w=0;w<channels;w++){
					back[w+y*channels] += tmp * transit[z+w*channels];
				}
			}
			//	printf("%f\t%f\n",back[0+y*channels],back[1+y*channels]);
		}
		for(z=0;z<channels;z++)	tmpb[z] = bounds[z];
		for(y=0;y<nby;y++){
			if (dir == 0) getPixel(x,y,buffer); else getPixel(y,x,buffer);
			memset(tmpb2,'\0',sizeof(double)*channels);
			for(z=0;z<channels;z++){
				tmp = tmpb[z] * (bounds[z] + buffer[z] * sigweight[z]) / (sigweight[z]+1);
				for(w=0;w<channels;w++){
					tmpb2[w] += tmp * transit[w+z*channels];
				}
			}
			//	printf("%f\t%f\n",tmpb2[0],tmpb2[1]);
			
			swp = tmpb;
			tmpb = tmpb2;
			tmpb2 = swp;
			
			tmp =0;
			for(z=0;z<channels;z++){tmpb2[z] = tmpb[z] * back[z+y*channels];tmp += tmpb2[z];}
			if (tmp > 0.0f)	for(z=0;z<channels;z++) tmpb2[z] /= tmp;
			
			
			if (isnan(tmpb2[0])) printf("honot");
			if (dir == 0) out->setPixel(x,y,tmpb2); else out->setPixel(y,x,tmpb2);
			
			
		}
		//	break;
	}
	delete[](back);
	delete[](tmpb);
	delete[](tmpb2);
}

template< >
void Madstructs::Image<float>::BFpropagation(double *transit, double *bounds, int dir, Madstructs::Image<float>* out, int rect[4]){
	int x,y,nbx,nby,z,w;
	if (dir == 0){
		nbx = 1 + rect[2] -rect[0];
		nby = 1 + rect[3] -rect[1];
	}else{
		nbx = 1 + rect[3] -rect[1];
		nby = 1 + rect[2] -rect[0];
	}
	double* back = new double[nby* channels];
	double* tmpb = new double[channels];
	double* tmpb2 = new double[channels];
	double* swp;
	double tmp;
	double sigweight[2];
	sigweight[0] = 20;
	sigweight[1] = 20;
	double buffer[32];
	for(x=0;x<nbx;x++){
		memset(back,'\0',sizeof(double)*channels*nby);
		for(z=0;z<channels;z++)	back[z+(nby-1)*channels] = 1.0f;
		for(y=nby-2;y>=0;y--){
			//backward
			if (dir == 0) getPixel(x + rect[0],y+ rect[1],buffer); else getPixel(y+ rect[0],x+ rect[1],buffer);
			for(z=0;z<channels;z++){
				tmp = back[z+(y+1)*channels] * (bounds[z] + buffer[z] * sigweight[z]) / (sigweight[z]+1);
				for(w=0;w<channels;w++){
					back[w+y*channels] += tmp * transit[z+w*channels];
				}
			}
			//	printf("%f\t%f\n",back[0+y*channels],back[1+y*channels]);
		}
		for(z=0;z<channels;z++)	tmpb[z] = bounds[z];
		for(y=0;y<nby;y++){
			if (dir == 0) getPixel(x+ rect[0],y+ rect[1],buffer); else getPixel(y+ rect[0],x+ rect[1],buffer);
			memset(tmpb2,'\0',sizeof(double)*channels);
			for(z=0;z<channels;z++){
				tmp = tmpb[z] * (bounds[z] + buffer[z] * sigweight[z]) / (sigweight[z]+1);
				for(w=0;w<channels;w++){
					tmpb2[w] += tmp * transit[w+z*channels];
				}
			}
			//	printf("%f\t%f\n",tmpb2[0],tmpb2[1]);
			
			swp = tmpb;
			tmpb = tmpb2;
			tmpb2 = swp;
			
			tmp =0;
			for(z=0;z<channels;z++){tmpb2[z] = tmpb[z] * back[z+y*channels];tmp += tmpb2[z];}
			for(z=0;z<channels;z++) tmpb2[z] /= tmp;
			if (dir == 0) out->setPixel(x+ rect[0],y+ rect[1],tmpb2); else out->setPixel(y+ rect[0],x+ rect[1],tmpb2);
			
			
		}
		//	break;
	}
	delete[](back);
	delete[](tmpb);
	delete[](tmpb2);
}

template< >
void Madstructs::Image<float>::BFpropagation(double *transit, double *bounds, int dir, Madstructs::Image<float>* out, int rect[4], double* updatetransit){
	int x,y,nbx,nby,z,w;
	if (dir == 0){
		nbx = 1 + rect[2] -rect[0];
		nby = 1 + rect[3] -rect[1];
	}else{
		nbx = 1 + rect[3] -rect[1];
		nby = 1 + rect[2] -rect[0];
	}
	double* back = new double[nby* channels];
	double* tmpb = new double[channels];
	double* tmpb2 = new double[channels];
	double* swp;
	double tmp;
	double sigweight[2];
	sigweight[0] = 20;
	sigweight[1] = 20;
	//	memset(updatetransit,'\0',sizeof(double)*channels*channels); // asume it<s done
	double buffer[32];
	for(x=0;x<nbx;x++){
		memset(back,'\0',sizeof(double)*channels*nby);
		for(z=0;z<channels;z++)	back[z+(nby-1)*channels] = 1.0f;
		for(y=nby-2;y>=0;y--){
			//backward
			if (dir == 0) getPixel(x + rect[0],y+ rect[1],buffer); else getPixel(y+ rect[0],x+ rect[1],buffer);
			for(z=0;z<channels;z++){
				tmp = back[z+(y+1)*channels] * (bounds[z] + buffer[z] * sigweight[z]) / (sigweight[z]+1);
				for(w=0;w<channels;w++){
					back[w+y*channels] += tmp * transit[z+w*channels];
				}
			}
			//	printf("%f\t%f\n",back[0+y*channels],back[1+y*channels]);
		}
		for(z=0;z<channels;z++)	tmpb[z] = bounds[z];
		for(y=0;y<nby;y++){
			if (dir == 0) getPixel(x+ rect[0],y+ rect[1],buffer); else getPixel(y+ rect[0],x+ rect[1],buffer);
			memset(tmpb2,'\0',sizeof(double)*channels);
			for(z=0;z<channels;z++){
				tmp = tmpb[z] * (bounds[z] + buffer[z] * sigweight[z]) / (sigweight[z]+1);
				for(w=0;w<channels;w++){
					tmpb2[w] += tmp * transit[w+z*channels];
					updatetransit[w+z*channels] += tmp * transit[w+z*channels] * back[w+y*channels];
				}
			}
			// updates
			
			//	printf("%f\t%f\n",tmpb2[0],tmpb2[1]);
			
			swp = tmpb;
			tmpb = tmpb2;
			tmpb2 = swp;
			
			tmp =0;
			for(z=0;z<channels;z++){tmpb2[z] = tmpb[z] * back[z+y*channels];tmp += tmpb2[z];}
			for(z=0;z<channels;z++) tmpb2[z] /= tmp;
			if (dir == 0) out->setPixel(x+ rect[0],y+ rect[1],tmpb2); else out->setPixel(y+ rect[0],x+ rect[1],tmpb2);
			
			
		}
		//	break;
	}
	delete[](back);
	delete[](tmpb);
	delete[](tmpb2);
}
/*
 template< >
 void Madstructs::Image<float>::WavyBFpropagation(double *transit, double *bounds, int dir, Madstructs::Image<float>* out){
 int x,y,nbx,nby,z,w;
 if (dir == 0){
 nbx = sizex;
 nby = sizey*2;
 }else{
 nbx = sizey;
 nby = sizex*2;
 }
 double* back = new double[nby* channels];
 double* tmpb = new double[channels];
 double* tmpb2 = new double[channels];
 double* swp;
 double tmp;
 double sigweight[2];
 sigweight[0] = 20;
 sigweight[1] = 20;
 double buffer[32];
 for(x=0;x<nbx;x++){
 memset(back,'\0',sizeof(double)*channels*nby);
 for(z=0;z<channels;z++)	back[z+(nby-1)*channels] = 1.0f;
 for(y=nby-2;y>=0;y--){
 //backward
 if (dir == 0) getPixel(x,y,buffer); else getPixel(y,x,buffer);
 for(z=0;z<channels;z++){
 tmp = back[z+(y+1)*channels] * (bounds[z] + buffer[z] * sigweight[z]) / (sigweight[z]+1);
 for(w=0;w<channels;w++){
 back[w+y*channels] += tmp * transit[z+w*channels];
 }
 }
 //	printf("%f\t%f\n",back[0+y*channels],back[1+y*channels]);
 }
 for(z=0;z<channels;z++)	tmpb[z] = bounds[z];
 for(y=0;y<nby;y++){
 if (dir == 0) getPixel(x,y,buffer); else getPixel(y,x,buffer);
 memset(tmpb2,'\0',sizeof(double)*channels);
 for(z=0;z<channels;z++){
 tmp = tmpb[z] * (bounds[z] + buffer[z] * sigweight[z]) / (sigweight[z]+1);
 for(w=0;w<channels;w++){
 tmpb2[w] += tmp * transit[w+z*channels];
 }
 }
 //	printf("%f\t%f\n",tmpb2[0],tmpb2[1]);
 
 swp = tmpb;
 tmpb = tmpb2;
 tmpb2 = swp;
 
 tmp =0;
 for(z=0;z<channels;z++){tmpb2[z] = tmpb[z] * back[z+y*channels];tmp += tmpb2[z];}
 for(z=0;z<channels;z++) tmpb2[z] /= tmp;
 if (dir == 0) out->setPixel(x,y,tmpb2); else out->setPixel(y,x,tmpb2);
 
 
 }
 //	break;
 }
 delete[](back);
 delete[](tmpb);
 delete[](tmpb2);
 }*/

/*
 template< >
 void Madstructs::Image<float>::computeDistances(Madstructs::Image<float>* out){
 out->initBlack();
 int x,y;
 bool found=true;
 double pix[256];
 
 int inda,indb;
 int* dist = new int[sizex*sizey];
 
 //	int* nbpath = new int[sizex*sizey];
 
 for(y=0;y<sizey;y++) for(x=0;x<sizex;x++){
 getPixel(x,y,pix);
 dist[x + y*sizex] = (pix[1] > 0.5) ? 0x7FFFFFFF : 0;
 //	nbpath[x + y*sizex] = (pix[1] > 0.5) ? 0 : 1;
 }
 
 while(found){
 found = false;
 for(y=0;y<sizey-1;y++) for(x=0;x<sizex-1;x++){
 inda = x + y*sizex; indb = x+1 + y*sizex;
 if (dist[inda] < dist[indb]-70) {dist[indb] = dist[inda] + 70; found =true;}
 inda = x+1 + y*sizex; indb = x + y*sizex;
 if (dist[inda] < dist[indb]-70) {dist[indb] = dist[inda] + 70; found =true;}
 inda = x + y*sizex; indb = x + (y+1)*sizex;
 if (dist[inda] < dist[indb]-70) {dist[indb] = dist[inda] + 70; found =true;}
 inda = x + (y+1)*sizex; indb = x + y*sizex;
 if (dist[inda] < dist[indb]-70) {dist[indb] = dist[inda] + 70; found =true;}
 inda = x + y*sizex; indb = x+1 + (y+1)*sizex;
 if (dist[inda] < dist[indb]-99) {dist[indb] = dist[inda] + 99; found =true;}
 indb = x + y*sizex; inda = x+1 + (y+1)*sizex;
 if (dist[inda] < dist[indb]-99) {dist[indb] = dist[inda] + 99; found =true;}
 inda = x+1 + y*sizex; indb = x + (y+1)*sizex;
 if (dist[inda] < dist[indb]-99) {dist[indb] = dist[inda] + 99; found =true;}
 indb = x+1 + y*sizex; inda = x + (y+1)*sizex;
 if (dist[inda] < dist[indb]-99) {dist[indb] = dist[inda] + 99; found =true;}
 }
 }
 /*	found = true;
 while(found){
 found = false;
 for(y=1;y<sizey-2;y++) for(x=1;x<sizex-2;x++){
 inda =0;
 indb = x+1 + y*sizex; if (dist[x + y*sizex] > dist[indb]) inda +=nbpath[indb];
 indb = x-1 + y*sizex; if (dist[x + y*sizex] > dist[indb]) inda +=nbpath[indb];
 indb = x + (y+1)*sizex; if (dist[x + y*sizex] > dist[indb]) inda +=nbpath[indb];
 indb = x+1 + (y+1)*sizex; if (dist[x + y*sizex] > dist[indb]) inda +=nbpath[indb];
 indb = x-1 + (y+1)*sizex; if (dist[x + y*sizex] > dist[indb]) inda +=nbpath[indb];
 indb = x + (y-1)*sizex; if (dist[x + y*sizex] > dist[indb]) inda +=nbpath[indb];
 indb = x+1 + (y-1)*sizex; if (dist[x + y*sizex] > dist[indb]) inda +=nbpath[indb];
 indb = x-1 + (y-1)*sizex; if (dist[x + y*sizex] > dist[indb]) inda +=nbpath[indb];
 if (nbpath[x + y*sizex] < inda){found =true; nbpath[x + y*sizex] = inda;}
 }
 } /
 for(y=0;y<sizey;y++) for(x=0;x<sizex;x++){
 pix[1] = 1.0f - 1.0f / (1 + dist[x + y*sizex] / 700.0f);
 
 /*	if ((x != sizex-1)&&(x != 0)&&(y != sizey-1)&&(y != 0)){
 
 if (((nbpath[x + y*sizex] > nbpath[x+1 + (y+1)*sizex])&&(nbpath[x + y*sizex] > nbpath[x+1 + y*sizex]))&&
 ((nbpath[x + y*sizex] > nbpath[x-1 + (y+1)*sizex])&&(nbpath[x + y*sizex] > nbpath[x-1 + y*sizex]))&&
 ((nbpath[x + y*sizex] > nbpath[x+1 + (y-1)*sizex])&&(nbpath[x + y*sizex] > nbpath[x + (y+1)*sizex]))&&
 ((nbpath[x + y*sizex] > nbpath[x-1 + (y-1)*sizex])&&(nbpath[x + y*sizex] > nbpath[x + (y-1)*sizex])))
 pix[1] =1.0f;
 
 
 } /
 
 out->setPixel(x,y,pix);
 }*/



template< >
void Madstructs::Image<float>::computeDistances(Madstructs::Image<float>* out, Madstructs::Image<float>* rprob){
	out->initBlack();
	int x,y;
	bool found=true;
	double pix[256];
	double pox[256];
	int count;
	int inda,indb;
	int* dist = new int[sizex*sizey];
	int* disu = new int[sizex*sizey];
	
	//	int* nbpath = new int[sizex*sizey];
	
	for(y=0;y<sizey;y++) for(x=0;x<sizex;x++){
		rprob->getPixel(x,y,pix);
		getPixel(x,y,pox);
		pox[1] = pox[1] * pox[1];
		//getPixel(x,y,pix+16);
		//pix[1] = (pix[1] + pix[17]) /2.0f;
		dist[x + y*sizex] = (int)(pix[1] * 0x7FFFFEFF);
		disu[x + y*sizex] = (int)(pox[1] * 0x7FFFFEFF);
		setPixel(x,y,pox);
		
		//	if ((x==0)||(y==0)||(x==sizex-1)||(y==sizey-1)) dist[x + y*sizex] =0x7FFFFFFF;
		//	if (pix[1] < 0.01f) dist[x + y*sizex] = 0;
		//	nbpath[x + y*sizex] = (pix[1] > 0.5) ? 0 : 1;
	}
	
	for(count=0;(count<250)&&(found);count++){
		found = false;
		for(y=0;y<sizey-2;y++) for(x=0;x<sizex-2;x++){
			rprob->getPixel(x,y,pix);
			getPixel(x,y,pox);
			///	rprob->getPixel(x,y,pix+16);
			//	pix[1] = (pix[1] + pix[17]*15) /16.0f;
			
			inda = x + (y+1)*sizex; indb = x + y*sizex;
			
			if (pix[1] *(dist[inda]+70) <  dist[indb]) {dist[indb] = (int)(pix[1] * (dist[inda] + 70)); found =true;}
			if (pox[1] *(disu[inda]+70) <  disu[indb]) {disu[indb] = (int)(pox[1] * (disu[inda] + 70)); found =true;}
			inda = x+1 + y*sizex; indb = x + y*sizex;
			if (pix[1] *(dist[inda]+70) < dist[indb]) {dist[indb] =  (int)(pix[1] * (dist[inda] + 70)); found =true;}
			if (pox[1] *(disu[inda]+70) < disu[indb]) {disu[indb] =  (int)(pox[1] * (disu[inda] + 70)); found =true;}
			inda = x+1 + (y+1)*sizex; indb = x + y*sizex;
			if (pix[1] *(dist[inda]+99) < dist[indb]) {dist[indb] =  (int)(pix[1] * (dist[inda] + 99)); found =true;}
			if (pox[1] *(disu[inda]+99) < disu[indb]) {disu[indb] =  (int)(pox[1] * (disu[inda] + 99)); found =true;}
			
			rprob->getPixel(x+1,y,pix);
			getPixel(x+1,y,pox);
			//rprob->getPixel(x+1,y,pix+16);
			//pix[1] = (pix[1] + pix[17]*15) /16.0f;
			
			inda = x + y*sizex; indb = x+1 + y*sizex;
			if (pix[1] *(dist[inda]+70) <  dist[indb]) {dist[indb] =  (int)(pix[1] * (dist[inda] + 70)); found =true;}
			if (pox[1] *(disu[inda]+70) <  disu[indb]) {disu[indb] =  (int)(pox[1] * (disu[inda] + 70)); found =true;}
			inda = x + (y+1)*sizex;indb = x+1 + y*sizex;
			if (pix[1] *(dist[inda]+99) < dist[indb]) {dist[indb] = (int)(pix[1] * (dist[inda] + 99)); found =true;}
			if (pox[1] *(disu[inda]+99) < disu[indb]) {disu[indb] = (int)(pox[1] * (disu[inda] + 99)); found =true;}
			
			rprob->getPixel(x,y+1,pix);
			getPixel(x,y+1,pox);
			//rprob->getPixel(x,y+1,pix+16);
			//pix[1] = (pix[1] + pix[17]*15) /16.0f;
			
			
			inda = x + y*sizex; indb = x + (y+1)*sizex;
			if (pix[1] *(dist[inda]+70) <  dist[indb]) {dist[indb] = (int)( pix[1] * (dist[inda] + 70)); found =true;}
			if (pox[1] *(disu[inda]+70) <  disu[indb]) {disu[indb] = (int)( pox[1] * (disu[inda] + 70)); found =true;}
			inda = x+1 + y*sizex; indb = x + (y+1)*sizex;
			if (pix[1] *(dist[inda]+99) <  dist[indb]) {dist[indb] = (int)(pix[1] * (dist[inda] + 99)); found =true;}
			if (pox[1] *(disu[inda]+99) <  disu[indb]) {disu[indb] = (int)(pox[1] * (disu[inda] + 99)); found =true;}
			
			rprob->getPixel(x+1,y+1,pix);
			getPixel(x+1,y+1,pox);
			//rprob->getPixel(x+1,y+1,pix+16);
			//pix[1] =  (pix[1] + pix[17]*15) /16.0f;
			
			inda = x + y*sizex; indb = x+1 + (y+1)*sizex;
			if (pix[1] *(dist[inda]+99) < dist[indb]) {dist[indb] = (int)( pix[1] * (dist[inda] + 99)); found =true;}
			if (pox[1] *(disu[inda]+99) < disu[indb]) {disu[indb] = (int)(pox[1] * (disu[inda] + 99)); found =true;}
		}
	}
	/*	found = true;
	 while(found){
	 found = false;
	 for(y=1;y<sizey-2;y++) for(x=1;x<sizex-2;x++){
	 inda =0;
	 indb = x+1 + y*sizex; if (dist[x + y*sizex] > dist[indb]) inda +=nbpath[indb];
	 indb = x-1 + y*sizex; if (dist[x + y*sizex] > dist[indb]) inda +=nbpath[indb];
	 indb = x + (y+1)*sizex; if (dist[x + y*sizex] > dist[indb]) inda +=nbpath[indb];
	 indb = x+1 + (y+1)*sizex; if (dist[x + y*sizex] > dist[indb]) inda +=nbpath[indb];
	 indb = x-1 + (y+1)*sizex; if (dist[x + y*sizex] > dist[indb]) inda +=nbpath[indb];
	 indb = x + (y-1)*sizex; if (dist[x + y*sizex] > dist[indb]) inda +=nbpath[indb];
	 indb = x+1 + (y-1)*sizex; if (dist[x + y*sizex] > dist[indb]) inda +=nbpath[indb];
	 indb = x-1 + (y-1)*sizex; if (dist[x + y*sizex] > dist[indb]) inda +=nbpath[indb];
	 if (nbpath[x + y*sizex] < inda){found =true; nbpath[x + y*sizex] = inda;}
	 }
	 }*/
	for(y=0;y<sizey;y++) for(x=0;x<sizex;x++){
		getPixel(x,y,pix);
		if (pix[1] *pix[1] * dist[x + y*sizex]  < 70) pix[0] =0.0f;
		else pix[0] = 1.0f - 1.0f / (1 + pix[1] * pix[1] * (dist[x + y*sizex] + disu[x + y*sizex]) / 1400.0f);
		
		/*	if ((x != sizex-1)&&(x != 0)&&(y != sizey-1)&&(y != 0)){
		 
		 if (((nbpath[x + y*sizex] > nbpath[x+1 + (y+1)*sizex])&&(nbpath[x + y*sizex] > nbpath[x+1 + y*sizex]))&&
		 ((nbpath[x + y*sizex] > nbpath[x-1 + (y+1)*sizex])&&(nbpath[x + y*sizex] > nbpath[x-1 + y*sizex]))&&
		 ((nbpath[x + y*sizex] > nbpath[x+1 + (y-1)*sizex])&&(nbpath[x + y*sizex] > nbpath[x + (y+1)*sizex]))&&
		 ((nbpath[x + y*sizex] > nbpath[x-1 + (y-1)*sizex])&&(nbpath[x + y*sizex] > nbpath[x + (y-1)*sizex])))
		 pix[1] =1.0f;
		 
		 
		 }*/
		
		out->setPixel(x,y,pix);
	}
	/*
	 for(y=0;y<sizey;y++) for(x=0;x<sizex;x++){
	 getPixel(x,y,pix);
	 dist[x + y*sizex] = (int)(pix[1] * 0x7FFFFFFF);
	 pix[0] = pix[1];
	 out->setPixel(x,y,pix);
	 
	 //	if ((x==0)||(y==0)||(x==sizex-1)||(y==sizey-1)) dist[x + y*sizex] =0x7FFFFFFF;
	 //	if (pix[1] < 0.01f) dist[x + y*sizex] = 0;
	 //	nbpath[x + y*sizex] = (pix[1] > 0.5) ? 0 : 1;
	 }*/
	delete[](dist);
	delete[](disu);
}

template< >
void Madstructs::Image<unsigned char>::groupPixel(Madstructs::Image<unsigned char>* origred,Madstructs::Image<unsigned char>* origreen, char* name){
	int x,y,r,l,c;
	double pix[3]; 
	double pox[3]; 
	for(y=0;y<sizey;y++){
		for(x=0;x<sizex;x++){
			getPixel(x,y,pix);
			pix[0] =  (pix[0] < 0.01f) ? 0.0f : 1.0f;
			setPixel(x,y,pix);			
		}
	}
	vector<int> buf;
	int cur = 251;
	int bounds[256][4];
	for(r = 0;r<sizex*sizey;r++){
		getPixel(x = (r %sizex),(y = r/sizex),pix);
		if (pix[0]  == 1.0f){
			cur--;
			buf.push_back(x);
			buf.push_back(y);
			bounds[cur][0] = x;
			bounds[cur][1] = y;
			bounds[cur][2] = x;
			bounds[cur][3] = y;
			while(buf.size()!= 0){
				y = *(buf.end()-1);buf.pop_back();x = *(buf.end()-1);buf.pop_back();
				getPixel(x,y,pix);
				if (pix[0] == 1.0f){
					data[(x + y * sizex)*channels] =cur;
					//		setPixel(x,y,pix);
					if (x > 0) {buf.push_back(x-1);buf.push_back(y);}
					if (x < sizex-1) {buf.push_back(x+1);buf.push_back(y);}
					if (y > 0) {buf.push_back(x);buf.push_back(y-1);}
					if (y < sizey-1) {buf.push_back(x);buf.push_back(y+1);}
					if (x< bounds[cur][0]) bounds[cur][0]= x;
					if (y< bounds[cur][1]) bounds[cur][1] =y;
					if (x> bounds[cur][2]) bounds[cur][2]=x;
					if (y> bounds[cur][3]) bounds[cur][3]=y;
				}
			}
		}
	}
	printf("%i frames\n",251-cur);
	Madstructs::Image<unsigned char>* newimage;
	l = strlen(name);
	char buffer[256];
	memcpy(buffer,name,l);
	buffer[l+3] = '.';
	buffer[l+4] = 't';
	buffer[l+5] = 'i';
	buffer[l+6] = 'f';
	buffer[l+7] = '\0';
	vector<Madstructs::Image<unsigned char> *> vachehe;
	c=0;
	for(r=250;r>=cur;r--){
		if ((bounds[r][0] > 0)&&(bounds[r][1] > 0)&&(bounds[r][2] < sizex-1)&&(bounds[r][3] < sizey-1)&&((bounds[r][2]-bounds[r][0])*(bounds[r][3]-bounds[r][1]) > 250)){
			printf("\t(%i,%i)-(%i,%i)\n",bounds[r][0],bounds[r][1],bounds[r][2],bounds[r][3]);
			newimage = new Madstructs::Image<unsigned char>();
			newimage->sizex = bounds[r][2] - bounds[r][0] +1;
			newimage->sizey = bounds[r][3] - bounds[r][1] +1;
			newimage->channels = 3;
			newimage->allocateBuffer();
			for(x=bounds[r][0];x<=bounds[r][2];x++){
				for(y=bounds[r][1];y<=bounds[r][3];y++){
					//		getPixel(x,y,pix);
					if (data[(x + y * sizex)*channels] == r) pox[2] =0.0f;
					else if (data[(x + y * sizex)*channels] == 0)	pox[2] =0.5f;
					else {pox[2] = 1.0f;}
					origred->getPixel(x,y,pix);
					pox[0] = pix[0];
					origred->getPixel(x,y,pix);
					pox[1] = pix[0];
					newimage->setPixel(x-bounds[r][0],y- bounds[r][1], pox);
				}
			}
			c++;
			buffer[l] = (char)(((int)'0') + ((c/ 100) % 10));
			buffer[l+1] = (char)(((int)'0') + ((c/ 10) % 10));
			buffer[l+2] = (char)(((int)'0') + ((c/ 1) % 10));
			vachehe.push_back(newimage);
			//	Madstructs::Image<unsigned char>::SaveTiffImage(vachehe, buffer);
			vachehe.clear();
			delete(newimage);
		}
	}
	
}

template< >
void Madstructs::Image<float>::groupCovPixel(Madstructs::Image<unsigned char>* origred,Madstructs::Image<unsigned char>* origreen, char* name){
	int x,y,r,l,c;
	Madstructs::MultiCover mcc;
	
	Madstructs::CellCover cc;
	double pix[3]; 
	double pox[3]; 
	//	Madstructs::Image<double>* vecf;
	//	Madstructs::Image<unsigned char>* outsink;
	int* glabel = new int[sizex*sizey];
	memset(glabel,'\0',sizex*sizey*sizeof(int));
	vector<int> buf;
	int cur = 0;
	int bounds[65536][4];
	c =0;
	int lab =1;
	vector<int> labels;
	for(r = 0;r<sizex*sizey;r++){
		getPixel(x = (r %sizex),(y = r/sizex),pix);
		if ((pix[0]  > 0.0f)&&(glabel[x+y*sizex] == 0)){
			
			buf.push_back(x);
			buf.push_back(y);
			bounds[cur][0] = x;
			bounds[cur][1] = y;
			bounds[cur][2] = x;
			bounds[cur][3] = y;
			while(buf.size()!= 0){
				y = *(buf.end()-1);buf.pop_back();x = *(buf.end()-1);buf.pop_back();
				getPixel(x,y,pix);
				if  (pix[0]  > 0.0f){
					c++;
					glabel[x+y*sizex] = lab;
					//		setPixel(x,y,pix);
					if (x > 0) if (glabel[x+y*sizex-1] == 0x00000000) {buf.push_back(x-1);buf.push_back(y);}
					if (x < sizex-1) if (glabel[x+y*sizex+1] == 0x00000000) {buf.push_back(x+1);buf.push_back(y);}
					if (y > 0) if (glabel[x+(y-1)*sizex] == 0x00000000) {buf.push_back(x);buf.push_back(y-1);}
					if (y < sizey-1) if (glabel[x+(y+1)*sizex] == 0x00000000) {buf.push_back(x);buf.push_back(y+1);}
					if (x< bounds[cur][0]) bounds[cur][0]= x;
					if (y< bounds[cur][1]) bounds[cur][1] =y;
					if (x> bounds[cur][2]) bounds[cur][2]=x;
					if (y> bounds[cur][3]) bounds[cur][3]=y;
				}
			}
			if (c > 50){
				//		printf("did %i\t%i\n",cur,pawa);
				bounds[cur][0]--;
				bounds[cur][1]--;
				bounds[cur][2]++;
				bounds[cur][3]++;
				cur++;
				labels.push_back(lab);
			}
			lab++;
		}
	}
	
	Madstructs::Image<double>* newimage;
	
	char buffer[256];
	l = strlen(name);
	memcpy(buffer,name,l);
	memcpy(buffer+l-4,"_000.tif",sizeof(char)*9);
	
	c=0;
	for(r=0;r<cur;r++){
		
		
		if ((bounds[r][0] > 0)&&(bounds[r][1] > 0)&&(bounds[r][2] < sizex-1)&&(bounds[r][3] < sizey-1)&&((bounds[r][2]-bounds[r][0])*(bounds[r][3]-bounds[r][1]) > 250)){
			//		printf("\t(%i,%i)-(%i,%i)\n",bounds[r][0],bounds[r][1],bounds[r][2],bounds[r][3]);
			
			newimage = new Madstructs::Image<double>();
			newimage->sizex = bounds[r][2] - bounds[r][0] +1;
			newimage->sizey = bounds[r][3] - bounds[r][1] +1;
			//	printf("%i,%i\n", newimage->sizex,newimage->sizey);
			newimage->channels = 3;
			newimage->allocateBuffer();
			for(x=bounds[r][0];x<=bounds[r][2];x++){
				for(y=bounds[r][1];y<=bounds[r][3];y++){
					getPixel(x,y,pix);
					if (glabel[x+y*sizex]  == labels[r]) pox[2] = 1.0f - pix[0];
					else {pox[2] = 1.0f;}
					origred->getPixel(x,y,pix);
					pox[0] = pix[0];
					origreen->getPixel(x,y,pix);
					pox[1] = pix[0];
					newimage->setPixel(x-bounds[r][0],y- bounds[r][1], pox);
				}
			}
			cc.findCellCover(newimage);
			memcpy(cc.rect, bounds[r],sizeof(int)*4); 
			if (cc.cover.size() > 0){
				c++;
				buffer[l-3] = (char)('0' + ((mcc.group.size()/100) % 10));
				buffer[l-2] = (char)('0' + ((mcc.group.size()/10) % 10));
				buffer[l-1] = (char)('0' + ((mcc.group.size()) % 10));
				mcc.group.push_back(cc);
			}
			cc.cover.clear();
			delete(newimage);
			
		}
	}
	printf("%s has %i out of %i frames\n",name ,mcc.group.size(),cur);fflush(stdout);
	l = strlen(name);
	memcpy(buffer,name,l);
	buffer[l-3] = 'm';
	buffer[l-2] = 'c';
	buffer[l-1] = 'v';
	buffer[l] = '\0';
	mcc.save(buffer);
	delete[](glabel);
	
	mcc.flush();
}

template< >
void Madstructs::Image<float>::groupCovPixel(Madstructs::Image<unsigned char>* origred,Madstructs::Image<unsigned char>* origreen, FILE* mcvout){
	int x,y,r,c;
	Madstructs::MultiCover mcc;
	
	Madstructs::CellCover cc;
	double pix[3]; 
	double pox[3]; 
	//	Madstructs::Image<double>* vecf;
	//	Madstructs::Image<unsigned char>* outsink;
	int* glabel = new int[sizex*sizey];
	memset(glabel,'\0',sizex*sizey*sizeof(int));
	vector<int> buf;
	int cur = 0;
	int bounds[65536][4];
	c =0;
	int lab =1;
	vector<int> labels;
	for(r = 0;r<sizex*sizey;r++){
		getPixel(x = (r %sizex),(y = r/sizex),pix);
		if ((pix[0]  > 0.0f)&&(glabel[x+y*sizex] == 0)){
			
			buf.push_back(x);
			buf.push_back(y);
			bounds[cur][0] = x;
			bounds[cur][1] = y;
			bounds[cur][2] = x;
			bounds[cur][3] = y;
			while(buf.size()!= 0){
				y = *(buf.end()-1);buf.pop_back();x = *(buf.end()-1);buf.pop_back();
				getPixel(x,y,pix);
				if  (pix[0]  > 0.0f){
					c++;
					glabel[x+y*sizex] = lab;
					//		setPixel(x,y,pix);
					if (x > 0) if (glabel[x+y*sizex-1] == 0x00000000) {buf.push_back(x-1);buf.push_back(y);}
					if (x < sizex-1) if (glabel[x+y*sizex+1] == 0x00000000) {buf.push_back(x+1);buf.push_back(y);}
					if (y > 0) if (glabel[x+(y-1)*sizex] == 0x00000000) {buf.push_back(x);buf.push_back(y-1);}
					if (y < sizey-1) if (glabel[x+(y+1)*sizex] == 0x00000000) {buf.push_back(x);buf.push_back(y+1);}
					if (x< bounds[cur][0]) bounds[cur][0]= x;
					if (y< bounds[cur][1]) bounds[cur][1] =y;
					if (x> bounds[cur][2]) bounds[cur][2]=x;
					if (y> bounds[cur][3]) bounds[cur][3]=y;
				}
			}
			if (c > 50){
				//		printf("did %i\t%i\n",cur,pawa);
				bounds[cur][0]--;
				bounds[cur][1]--;
				bounds[cur][2]++;
				bounds[cur][3]++;
				cur++;
				labels.push_back(lab);
			}
			lab++;
		}
	}
	
	Madstructs::Image<double>* newimage;
	
	
	c=0;
	for(r=0;r<cur;r++){
		
		
		if ((bounds[r][0] > 0)&&(bounds[r][1] > 0)&&(bounds[r][2] < sizex-1)&&(bounds[r][3] < sizey-1)&&((bounds[r][2]-bounds[r][0])*(bounds[r][3]-bounds[r][1]) > 250)){
			//		printf("\t(%i,%i)-(%i,%i)\n",bounds[r][0],bounds[r][1],bounds[r][2],bounds[r][3]);
			
			newimage = new Madstructs::Image<double>();
			newimage->sizex = bounds[r][2] - bounds[r][0] +1;
			newimage->sizey = bounds[r][3] - bounds[r][1] +1;
			//	printf("%i,%i\n", newimage->sizex,newimage->sizey);
			newimage->channels = 3;
			newimage->allocateBuffer();
			for(x=bounds[r][0];x<=bounds[r][2];x++){
				for(y=bounds[r][1];y<=bounds[r][3];y++){
					getPixel(x,y,pix);
					if (glabel[x+y*sizex]  == labels[r]) pox[2] = 1.0f - pix[0];
					else {pox[2] = 1.0f;}
					origred->getPixel(x,y,pix);
					pox[0] = pix[0];
					origreen->getPixel(x,y,pix);
					pox[1] = pix[0];
					newimage->setPixel(x-bounds[r][0],y- bounds[r][1], pox);
				}
			}
			cc.findCellCover(newimage);
			memcpy(cc.rect, bounds[r],sizeof(int)*4); 
			if (cc.cover.size() > 0){
				c++;
				
				mcc.group.push_back(cc);
			}
			cc.cover.clear();
			delete(newimage);
			
		}
	}
	printf("has %i out of %i frames\n",mcc.group.size(),cur);fflush(stdout);
	
	mcc.save(mcvout);
	delete[](glabel);
	
	mcc.flush();
}

template< >
void Madstructs::Image<float>::groupCovPixel(Madstructs::Image<float>* origred, FILE* mcvout){
	int x,y,r,c;
	Madstructs::MultiCover mcc;
	
	Madstructs::CellCover cc;
	double pix[3]; 
	double pox[3]; 
	//	Madstructs::Image<double>* vecf;
	//	Madstructs::Image<unsigned char>* outsink;
	int* glabel = new int[sizex*sizey];
	memset(glabel,'\0',sizex*sizey*sizeof(int));
	vector<int> buf;
	int cur = 0;
	int bounds[65536][4];
	c =0;
	int lab =1;
	vector<int> labels;
	for(r = 0;r<sizex*sizey;r++){
		getPixel(x = (r %sizex),(y = r/sizex),pix);
		if ((pix[0]  > 0.0001f)&&(glabel[x+y*sizex] == 0)){
			
			buf.push_back(x);
			buf.push_back(y);
			bounds[cur][0] = x;
			bounds[cur][1] = y;
			bounds[cur][2] = x;
			bounds[cur][3] = y;
			while(buf.size()!= 0){
				y = *(buf.end()-1);buf.pop_back();x = *(buf.end()-1);buf.pop_back();
				getPixel(x,y,pix);
				if  (pix[0]  > 0.0001f){
					c++;
					glabel[x+y*sizex] = lab;
					//		setPixel(x,y,pix);
					if (x > 0) if (glabel[x+y*sizex-1] == 0x00000000) {buf.push_back(x-1);buf.push_back(y);}
					if (x < sizex-1) if (glabel[x+y*sizex+1] == 0x00000000) {buf.push_back(x+1);buf.push_back(y);}
					if (y > 0) if (glabel[x+(y-1)*sizex] == 0x00000000) {buf.push_back(x);buf.push_back(y-1);}
					if (y < sizey-1) if (glabel[x+(y+1)*sizex] == 0x00000000) {buf.push_back(x);buf.push_back(y+1);}
					if (x< bounds[cur][0]) bounds[cur][0]= x;
					if (y< bounds[cur][1]) bounds[cur][1] =y;
					if (x> bounds[cur][2]) bounds[cur][2]=x;
					if (y> bounds[cur][3]) bounds[cur][3]=y;
				}
			}
			if (c > 50){
				//		printf("did %i\t%i\n",cur,pawa);
				if (bounds[cur][0] != 0) bounds[cur][0]--;
				if (bounds[cur][1] != 0) bounds[cur][1]--;
				if (bounds[cur][2] != sizex-1) bounds[cur][2]++;
				if (bounds[cur][3] != sizey-1) bounds[cur][3]++;
				cur++;
				labels.push_back(lab);
			}
			lab++;
		}
	}
	printf("did %i\n",cur);
	Madstructs::Image<double>* newimage;
	
	
	c=0;
	for(r=0;r<cur;r++){
		
		
		if ((bounds[r][2]-bounds[r][0])*(bounds[r][3]-bounds[r][1]) > 250){
			//	if ((bounds[r][0] > 0)&&(bounds[r][1] > 0)&&(bounds[r][2] < sizex-1)&&(bounds[r][3] < sizey-1)&&((bounds[r][2]-bounds[r][0])*(bounds[r][3]-bounds[r][1]) > 250)){
			printf("\t(%i,%i)-(%i,%i)\n",bounds[r][0],bounds[r][1],bounds[r][2],bounds[r][3]);
			
			
			
			newimage = new Madstructs::Image<double>();
			newimage->sizex = bounds[r][2] - bounds[r][0] +1;
			newimage->sizey = bounds[r][3] - bounds[r][1] +1;
			//	printf("%i,%i\n", newimage->sizex,newimage->sizey);
			newimage->channels = 3;
			newimage->allocateBuffer();
			for(x=bounds[r][0];x<=bounds[r][2];x++){
				for(y=bounds[r][1];y<=bounds[r][3];y++){
					getPixel(x,y,pix);
					//				if (glabel[x+y*sizex]  == labels[r]) pox[2] = 1.0f - pix[0];
					//				else {pox[2] = 1.0f;}
					/*		if ((x < 0)||(y<0)|| (x>=sizex)||(y >=sizey)){
					 pox[0] =0.0f;
					 pox[1] =0.0f;
					 pox[2] =0.0f;
					 }else {*/
					if (glabel[x+y*sizex]  == labels[r]) pox[2] = pix[0] * 100.0f;
					else {pox[2] = 0.0f;}
					origred->getPixel(x,y,pix);
					pox[0] = pix[0];
					pox[1] = pix[0];
					//}
					newimage->setPixel(x-bounds[r][0],y- bounds[r][1], pox);
				}
			}
			//cc.findCellCoverHeuristic(newimage, 0.0f);
			//		cc.findCellCover_2(newimage);
			
			if (cc.cover.size() > 0){
				c++;
				
				y =  mcc.group.size();
				mcc.group.push_back(Madstructs::CellCover());
				memcpy(mcc.group[y].rect, bounds[r],sizeof(int)*4); 
				for(x=0;x<cc.cover.size();x++) mcc.group[y].cover.push_back(cc.cover[x]);
			}
			cc.cover.clear();
			delete(newimage);
		}
		
	}
	printf("has %i out of %i frames\n",mcc.group.size(),cur);fflush(stdout);
	
	mcc.save(mcvout);
	delete[](glabel);
	
	mcc.flush();
}



template< >
void Madstructs::Image<float>::groupCovPixel(Madstructs::Image<unsigned short>* origred,Madstructs::Image<unsigned short>* origreen, FILE* mcvout){
	int x,y,r,l,c;
	Madstructs::MultiCover mcc;
	Madstructs::CellCover cc;
	double pix[3]; 
	double pox[3]; 
	//	Madstructs::Image<double>* vecf;
	//	Madstructs::Image<unsigned char>* outsink;
	int* glabel = new int[sizex*sizey];
	memset(glabel,'\0',sizex*sizey*sizeof(int));
	vector<int> buf;
	int cur = 0;
	int bounds[65536][4];
	c =0;
	int lab =1;
	vector<int> labels;
	for(r = 0;r<sizex*sizey;r++){
		getPixel(x = (r %sizex),(y = r/sizex),pix);
		if ((pix[0]  > 0.0f)&&(glabel[x+y*sizex] == 0)){
			
			buf.push_back(x);
			buf.push_back(y);
			bounds[cur][0] = x;
			bounds[cur][1] = y;
			bounds[cur][2] = x;
			bounds[cur][3] = y;
			while(buf.size()!= 0){
				y = *(buf.end()-1);buf.pop_back();x = *(buf.end()-1);buf.pop_back();
				getPixel(x,y,pix);
				if  (pix[0]  > 0.0f){
					c++;
					glabel[x+y*sizex] = lab;
					//		setPixel(x,y,pix);
					if (x > 0) if (glabel[x+y*sizex-1] == 0x00000000) {buf.push_back(x-1);buf.push_back(y);}
					if (x < sizex-1) if (glabel[x+y*sizex+1] == 0x00000000) {buf.push_back(x+1);buf.push_back(y);}
					if (y > 0) if (glabel[x+(y-1)*sizex] == 0x00000000) {buf.push_back(x);buf.push_back(y-1);}
					if (y < sizey-1) if (glabel[x+(y+1)*sizex] == 0x00000000) {buf.push_back(x);buf.push_back(y+1);}
					if (x< bounds[cur][0]) bounds[cur][0]= x;
					if (y< bounds[cur][1]) bounds[cur][1] =y;
					if (x> bounds[cur][2]) bounds[cur][2]=x;
					if (y> bounds[cur][3]) bounds[cur][3]=y;
				}
			}
			//		printf("did %i\t%i\n",cur,pawa);
			if (c > 50){
				//		printf("did %i\t%i\n",cur,pawa);
				bounds[cur][0]--;
				bounds[cur][1]--;
				bounds[cur][2]++;
				bounds[cur][3]++;
				cur++;
				labels.push_back(lab);
			}
			lab++;
			c=0;
		}
		//if (cur == 5) break;
	}
	
	Madstructs::Image<double>* newimage;
	
	char buffer[256];
	
	c=0;
	for(r=0;r<cur;r++){
		
		
		if ((bounds[r][0] > 0)&&(bounds[r][1] > 0)&&(bounds[r][2] < sizex-1)&&(bounds[r][3] < sizey-1)&&((bounds[r][2]-bounds[r][0])*(bounds[r][3]-bounds[r][1]) > 250)){
			//		printf("\t(%i,%i)-(%i,%i)\n",bounds[r][0],bounds[r][1],bounds[r][2],bounds[r][3]);
			
			newimage = new Madstructs::Image<double>();
			newimage->sizex = bounds[r][2] - bounds[r][0] +1;
			newimage->sizey = bounds[r][3] - bounds[r][1] +1;
			//	printf("%i,%i\n", newimage->sizex,newimage->sizey);
			newimage->channels = 3;
			newimage->allocateBuffer();
			for(x=bounds[r][0];x<=bounds[r][2];x++){
				for(y=bounds[r][1];y<=bounds[r][3];y++){
					getPixel(x,y,pix);
					if (glabel[x+y*sizex]  == labels[r]) pox[2] = 1.0f - pix[0];
					else {pox[2] = 1.0f;}
					origred->getPixel(x,y,pix);
					pox[0] = pix[0];
					origreen->getPixel(x,y,pix);
					pox[1] = pix[0];
					newimage->setPixel(x-bounds[r][0],y- bounds[r][1], pox);
				}
			}
			printf("%i/%i analyse\n", r,cur);
			cc.findCellCover(newimage);
			memcpy(cc.rect, bounds[r],sizeof(int)*4); 
			if (cc.cover.size() > 0){
				c++;
				buffer[l-3] = (char)('0' + ((mcc.group.size()/100) % 10));
				buffer[l-2] = (char)('0' + ((mcc.group.size()/10) % 10));
				buffer[l-1] = (char)('0' + ((mcc.group.size()) % 10));
				mcc.group.push_back(cc);
			}
			cc.cover.clear();
			delete(newimage);
			
		}
	}
	
	mcc.save(mcvout);
	delete[](glabel);
	
	mcc.flush();
}


template< >
void Madstructs::Image<double>::initMorphMap(Madstructs::Evaluatable* source, Madstructs::Evaluatable* sink){
	channels = 3;
	sizex = 100;
}

template<>
void Madstructs::Image<double>::morphingStepSym(Madstructs::Evaluatable* source, Madstructs::Evaluatable* sink){
	int x,y,z;
	
	int size = source->outputsize();
	if (size != sink->outputsize()) exit(1);
	
	double valsour[32];
	double dersour[32][2];
	double valsink[32];
	double dersink[32][2];
	double pix[3]; // first value is for blur weights
	double values[6];
	for(y=0;y<sizey;y++){
		for(x=0;x<sizex;x++){
			getPixel(x,y,pix);
			pix[1] -= ((double)x) / (sizex-1);
			pix[2] -= ((double)y) / (sizey-1);
			sink->eval(pix+1,valsink);
			sink->evalDerivatives(pix+1,(double*)dersink);
			pix[1] = ((2*(double)x) / (sizex-1))-pix[1];
			pix[2] = ((2*(double)y) / (sizey-1))-pix[2];
			source->eval(pix+1,valsour);
			source->evalDerivatives(pix+1,(double*)dersour);
			for(z=0;z<size;z++) valsink[z] -= valsour[z];
			for(z=0;z<size*2;z++) ((double*)dersour)[z] -= ((double*)dersour)[z];
			memset(values, '\0',sizeof(double)*6);
			for(z=0;z<size;z++){
				values[0] += valsink[z] * dersink[z][0];
				values[1] += valsink[z] * dersink[z][1];
				values[2] += dersink[z][0] * dersink[z][0];
				values[3] += dersink[z][1] * dersink[z][1];
				values[4] += dersink[z][0] * dersink[z][1];
			}
			values[5] = values[4]*values[4] - values[2]* values[3];
			if (values[5] != 0.0f){
				values[3] = (values[3] * values[0] - values[4] * values[1]) / values[5];
				values[2] = (values[2] * values[1] - values[4] * values[0]) / values[5];
				values[0] =0;
				for(z=0;z<size;z++){values[0] += valsink[z]*valsink[z];}
				pix[1] += values[3];
				pix[2] += values[2];
				source->evalDerivatives(pix+1,(double*)dersour);
				pix[1] = ((2*(double)x) / (sizex-1))-pix[1];
				pix[2] = ((2*(double)y) / (sizey-1))-pix[2];
				sink->evalDerivatives(pix+1,(double*)dersour);
				for(z=0;z<size;z++) valsink[z] -= valsour[z];
				values[1] =0;
				for(z=0;z<size;z++){values[1] += valsink[z]*valsink[z];}
				getPixel(x,y,pix);
				if (values[1] < values[0]){
					// this is an improvement
					pix[0] = values[0] / (0.01f + values[1]);
					pix[1] += values[3];
					pix[2] += values[2];
				}else pix[0] =0;
				setPixel(x,y,pix);
			}
		}
	}
	
}

template<>
void Madstructs::Image<double>::morphingStep(Madstructs::Evaluatable* source, Madstructs::Evaluatable* sink, double magnitude){
	int x,y,z;
	
	int size = source->outputsize()-1;
	double valsour[32];
	double valsink[32];
	double dersink[256];
	double pix[256]; // first value is for blur weights
	double values[13];
	int cin = 0;
	int ctot = 0;
	for(y=0;y<sizey;y++){
		for(x=0;x<sizex;x++){
			pix[1] = x;
			pix[2] = y;
			source->eval(pix+1,valsour);
			data[channels*(x+y*sizex)] = 0.0f;
			
			
			getPixel(x,y,pix);
			//		if (pix[0] != 0.0f){
			pix[1] += x;
			pix[2] += y;
			//	printf("posis: %f,%f,%f\n",pix[1],pix[2],pix[3]);
			
			sink->eval(pix+1,valsink);
			//if (valsour[0] > 0.0f){
			sink->evalDerivatives(pix+1,dersink);
			//	dersink[0]=0.0f;
			/*		printf("derivative: ");
			 for(z=0;z<9;z++) printf("%f\t",dersink[z]);
			 printf("\n");*/
			
			//	for(z=0;z<size;z++) valsink[z] -= valsour[z+1];
			for(z=0;z<size;z++) valsink[z] -= valsour[z+1] + data[4+z+channels*(x+y*sizex)];
			memset(values, '\0',sizeof(double)*13);
			for(z=0;z<size;z++){
				values[0] += valsink[z] * dersink[z];
				values[1] += valsink[z] * dersink[z + size];
				values[2] += valsink[z] * dersink[z + size*2];
				values[3] += dersink[z] * dersink[z];
				values[4] += dersink[z+ size] * dersink[z+ size];
				values[5] += dersink[z+ size*2] * dersink[z+ size*2];
				values[6] += dersink[z] * dersink[z+ size];
				values[7] += dersink[z+ size] * dersink[z+ size*2];
				values[8] += dersink[z+ size*2] * dersink[z];
				values[12] += valsink[z]*valsink[z];
			}
			//		if (isnan(values[8])) exit(123);
			//	printf("%i,%i, step %f\t%f\t%f\n",x,y, values[0],values[1],values[2]);
			
			values[11] = (values[3]*(values[4]*values[5] - values[7]*values[7]) + values[6] * (values[7]*values[8] - values[5]*values[6]) + values[8]*(values[6]*values[7]- values[8]*values[4]));
			if (values[11] != 0.0f){
				
				values[11] = 1.0f / values[11];
				
				values[9] = (values[0]*(values[4]*values[5] - values[7]*values[7]) + values[6] * (values[7]*values[2] - values[5]*values[1]) + values[8]*(values[1]*values[7]- values[2]*values[4])) * values[11];
				values[10] = (values[3]*(values[1]*values[5] - values[2]*values[7]) + values[0] * (values[7]*values[8] - values[5]*values[6]) + values[8]*(values[6]*values[2]- values[8]*values[1])) * values[11];
				values[11] = (values[3]*(values[4]*values[2] - values[7]*values[1]) + values[6] * (values[1]*values[8] - values[2]*values[6]) + values[0]*(values[6]*values[7]- values[8]*values[4])) * values[11];
				
				//printf("%f,%f,%f\n", values[0] - values[9]* values[3] - values[10] * values[6] - values[11] * values[8],
				//	                   values[1] - values[9]* values[6] - values[10] * values[4] - values[11] * values[7],
				//	   			       values[2] - values[9]* values[8] - values[10] * values[7] - values[11] * values[5]);
				
				values[0] = sqrt(values[9]*values[9] + values[10]*values[10] + values[11] * values[11]);
				values[0] = magnitude / (magnitude + values[0]);
				
				values[9] *= values[0];
				values[10] *= values[0];
				values[11] *= values[0];
				
				
				pix[1] = data[1+channels*(x+y*sizex)]- values[9] + x;
				pix[2] = data[2+channels*(x+y*sizex)]- values[10] + y;
				pix[3] = data[3+channels*(x+y*sizex)]- values[11];
				sink->eval(pix+1,valsink);
				
				values[0] = 0.0f;
				for(z=0;z<size;z++){
					values[1]  = valsink[z] - valsour[z+1] + data[4+z+channels*(x+y*sizex)];
					values[0] += values[1]*values[1];
				}
				ctot ++;
				if (values[0] < values[12]){
					cin++;
					valsour[0] = exp(-values[0]);
					data[channels*(x+y*sizex)] = valsour[0];
					
					data[1+channels*(x+y*sizex)] = valsour[0]*(data[1+channels*(x+y*sizex)] - values[9]);
					data[2+channels*(x+y*sizex)] = valsour[0]*(data[2+channels*(x+y*sizex)] - values[10]);
					data[3+channels*(x+y*sizex)] = valsour[0]*(data[3+channels*(x+y*sizex)] - values[11]);
					for(z=0;z<size;z++) data[4+z+channels*(x+y*sizex)] = 0.9f * valsour[0]*(valsour[z+1] - valsink[z]);
				}else{
					pix[1] = data[1+channels*(x+y*sizex)] + x;
					pix[2] = data[2+channels*(x+y*sizex)] + y;
					pix[3] = data[3+channels*(x+y*sizex)];
					sink->eval(pix+1,valsink);
					
					valsour[0] = exp(-values[12]);
					data[channels*(x+y*sizex)] = valsour[0];
					
					data[1+channels*(x+y*sizex)] = valsour[0]*(data[1+channels*(x+y*sizex)]);
					data[2+channels*(x+y*sizex)] = valsour[0]*(data[2+channels*(x+y*sizex)]);
					data[3+channels*(x+y*sizex)] = valsour[0]*(data[3+channels*(x+y*sizex)]);
					for(z=0;z<size;z++) data[4+z+channels*(x+y*sizex)] = 0.9f * valsour[0]*(valsour[z+1] - valsink[z]);
					
					
				}
				
				if ((isnan(data[1+channels*(x+y*sizex)]))||(isnan(data[2+channels*(x+y*sizex)]))||(isnan(data[3+channels*(x+y*sizex)]))){
					memset(data +channels*(x+y*sizex), '\0',sizeof(double)*4);
				}
				
				
			}
			
			//	}
			if (data[channels*(x+y*sizex)] == 0.0f) memset(data + channels*(x+y*sizex),'\0',sizeof(double)*channels);
			
			
		}
		
		
	}
	//printf("%i/%i\n",cin,ctot);
}
template<>
void Madstructs::Image<double>::probmorphingStep(Madstructs::Evaluatable* source, Madstructs::Evaluatable* sink, double magnitude){
	int x,y,z;
	
	int size = source->outputsize()-1;
	double valsour[32];
	double valsink[32];
	double dersink[256];
	double pix[256]; // first value is for blur weights
	double values[16];
	//	double solverBuffer[12];
	int cin = 0;
	int ctot = 0;
	for(y=0;y<sizey;y++){
		for(x=0;x<sizex;x++){
			pix[1] = x;
			pix[2] = y;
			source->eval(pix+1,valsour);
			data[channels*(x+y*sizex)] = 0.0f;
			
			
			getPixel(x,y,pix);
			//		if (pix[0] != 0.0f){
			pix[1] += x;
			pix[2] += y;
			//	printf("posis: %f,%f,%f\n",pix[1],pix[2],pix[3]);
			
			sink->eval(pix+1,valsink);
			//if (valsour[0] > 0.0f){
			sink->evalDerivatives(pix+1,dersink);
			//	dersink[0]=0.0f;
			/*		printf("derivative: ");
			 for(z=0;z<9;z++) printf("%f\t",dersink[z]);
			 printf("\n");*/
			
			//	for(z=0;z<size;z++) valsink[z] -= valsour[z+1];
			for(z=0;z<size;z++) valsink[z] -= valsour[z+1] + data[4+z+channels*(x+y*sizex)];
			memset(values, '\0',sizeof(double)*16);
			for(z=0;z<size;z++){
				values[9] += valsink[z] * dersink[z];
				values[10] += valsink[z] * dersink[z + size*2];
				values[11] += valsink[z] * dersink[z + size*4];
				values[0] += dersink[z] * dersink[z];
				values[4] += dersink[z+ size*2] * dersink[z+ size*2];
				values[8] += dersink[z+ size*4] * dersink[z+ size*4];
				values[1] += dersink[z] * dersink[z+ size*2];
				values[2] += dersink[z+ size*2] * dersink[z+ size*4];
				values[5] += dersink[z+ size*4] * dersink[z];
				values[15] += valsink[z]*valsink[z] / (valsink[z + size] * valsink[z + size]);
			}
			//		if (isnan(values[8])) exit(123);
			//	printf("%i,%i, step %f\t%f\t%f\n",x,y, values[0],values[1],values[2]);
			values[3] = values[1];
			values[6] = values[2];
			values[7] = values[5];
			
			Madstructs::solvelinear(3,values,values+12);
			
			values[0] = sqrt(values[12]*values[12] + values[13]*values[13] + values[14] * values[14]);
			values[0] = magnitude / (magnitude + values[0]);
			
			values[9] = values[12]*values[0];
			values[10] = values[13]*values[0];
			values[11] = values[14]*values[0];
			
			
			pix[1] = data[1+channels*(x+y*sizex)]- values[9] + x;
			pix[2] = data[2+channels*(x+y*sizex)]- values[10] + y;
			pix[3] = data[3+channels*(x+y*sizex)]- values[11];
			sink->eval(pix+1,valsink);
			
			values[0] = 0.0f;
			for(z=0;z<size;z++){
				values[1]  = (valsink[z] - valsour[z+1] + data[4+z+channels*(x+y*sizex)]) / (valsink[z + size]);
				values[0] += values[1]*values[1];
			}
			ctot ++;
			if (values[0] < values[15]){
				cin++;
				valsour[0] *= exp(-values[0] / 2);
				for(z=0;z<size;z++) valsour[0] /= valsink[z + size];
				
				values[2] = data[1+channels*(x+y*sizex)] - values[9]; values[3] += values[2]*values[2];
				values[2] = data[2+channels*(x+y*sizex)] - values[10]; values[3] += values[2]*values[2];
				values[2] = data[3+channels*(x+y*sizex)] - values[11]; values[3] += values[2]*values[2];
				valsour[0] *= exp(-values[3]/ (magnitude*magnitude*16));
				
				data[channels*(x+y*sizex)] = valsour[0];
				data[1+channels*(x+y*sizex)] = valsour[0]*(data[1+channels*(x+y*sizex)] - values[9]);
				data[2+channels*(x+y*sizex)] = valsour[0]*(data[2+channels*(x+y*sizex)] - values[10]);
				data[3+channels*(x+y*sizex)] = valsour[0]*(data[3+channels*(x+y*sizex)] - values[11]);
				for(z=0;z<size;z++) data[4+z+channels*(x+y*sizex)] = 0.9f * valsour[0]*(valsour[z+1] - valsink[z]);
			}else{
				pix[1] = data[1+channels*(x+y*sizex)] + x;
				pix[2] = data[2+channels*(x+y*sizex)] + y;
				pix[3] = data[3+channels*(x+y*sizex)];
				sink->eval(pix+1,valsink);
				
				valsour[0] *= exp(-values[15] /2);
				for(z=0;z<size;z++) valsour[0] /= valsink[z + size];
				data[channels*(x+y*sizex)] = valsour[0];
				values[2] = data[1+channels*(x+y*sizex)]; values[3] += values[2]*values[2];
				values[2] = data[2+channels*(x+y*sizex)]; values[3] += values[2]*values[2];
				values[2] = data[3+channels*(x+y*sizex)]; values[3] += values[2]*values[2];
				valsour[0] *= exp(-values[3]/ (magnitude*magnitude*16));
				
				data[1+channels*(x+y*sizex)] = valsour[0]*(data[1+channels*(x+y*sizex)]);
				data[2+channels*(x+y*sizex)] = valsour[0]*(data[2+channels*(x+y*sizex)]);
				data[3+channels*(x+y*sizex)] = valsour[0]*(data[3+channels*(x+y*sizex)]);
				for(z=0;z<size;z++) data[4+z+channels*(x+y*sizex)] = 0.9f * valsour[0]*(valsour[z+1] - valsink[z]);
				
				
			}
			
			if ((isnan(data[1+channels*(x+y*sizex)]))||(isnan(data[2+channels*(x+y*sizex)]))||(isnan(data[3+channels*(x+y*sizex)]))){
				memset(data +channels*(x+y*sizex), '\0',sizeof(double)*4);
			}
			
			
			
			
			//	}
			if (data[channels*(x+y*sizex)] == 0.0f) memset(data + channels*(x+y*sizex),'\0',sizeof(double)*channels);
			
			
		}
		
		
	}
	//printf("%i/%i\n",cin,ctot);
}


template< >
double Madstructs::Image<double>::evalMap(Madstructs::Evaluatable* source, Madstructs::Evaluatable* sink, double &var){
	int x,y,z;
	
	int size = source->outputsize()-1;
	double valsour[32];
	double valsink[32];
	double pix[256]; // first value is for blur weights
	double err =0;
	//	double errs =0;
	double tmp;
	double count=0.0f;
	for(y=0;y<sizey;y++){
		for(x=0;x<sizex;x++){
			pix[1] = x;
			pix[2] = y;
			source->eval(pix+1,valsour);
			//printf("%f\n",valsour[0]);
			if (valsour[0] > 0.0f){
				
				/*if (valsour[0] == 1.0f){
				 printf("impact");
				 }*/
				getPixel(x,y,pix);
				pix[1] += x;
				pix[2] += y;
				
				if (var != 10000.0f) pix[3] += var;
				sink->eval(pix+1,valsink);
				
				for(z=0;z<size;z++) {
					if (valsink[z+size] > 0.0f){
						tmp = (valsour[z+1] - valsink[z] - pix[4+z]) / valsink[z+size];
						err += valsour[0] * (-tmp*tmp/2 - log(valsink[z+size]) - 0.399089934179058f);
						count += valsour[0];
					}
				}
			}
			
		}
	}
	
	var = 0.0f;//errs / (count *size);
	if (count == 0) return(0);
	return(err / count);
}
/*
template<>
void Madstructs::Image<double>::writeTransformedPixels(Madstructs::Evaluatable* source, Madstructs::Transformed* xform, Madstructs::ImageArray<double>* target, double weight){
	int x,y,z,t;
	//	double coor[32];
	double scoor[2];
	double pox[256];
	double pix[256];
	double ptx[32];
	bool isback;
	for(y = -1;y < sizey+1;y++){
		scoor[1] = y;
		for(x = -1;x < sizex+1;x++){
			scoor[0] = x;
			if ((x<0)||(x ==sizex)||(y<0)||(y ==sizey)) {isback = true; memset(pox,'\0',sizeof(double)*32);}
			else {
				source->eval(scoor,pix);
				isback = (pix[0] == 0.0f);
				getPixel(x,y,pox);
			}
			pox[1] += x;
			pox[2] += y;
			xform->eval(pox+1,ptx+1);
			if (isback) memset(pix,'\0',sizeof(double)*32);
			else if ((target->channels-1) > (t = source->outputsize())){
				for(z = t;z< target->channels ;z ++){
					pix[z] = pix[z-t+1]*pix[z-t+1];
				}
			}
			
			Madstructs::Image<double>::addWeigthedPixel(target->im,ptx[1],ptx[2],ptx[3],pix+1, weight);
			
		}
	}
}*/

template< >
void Madstructs::Image<double>::writeTransformedPixels(Madstructs::Evaluatable* source, Madstructs::Transformed* xform, Madstructs::Image<double>* target, double weight){
	int x,y;
	//	double coor[32];
	double scoor[2];
	double pox[256];
	double pix[256];
	double ptx[32];
	bool isback;
	for(y = -1;y <= sizey;y++){
		scoor[1] = y;
		for(x = -1;x <= sizex;x++){
			scoor[0] = x;
			
			if ((x<0)||(x ==sizex)||(y<0)||(y ==sizey)) {isback = true; memset(pox,'\0',sizeof(double)*32);}
			else {
				source->eval(scoor,pix);
				isback = (pix[0] == 0.0f);
				getPixel(x,y,pox);
			}
			pox[1] += x;
			pox[2] += y;
			xform->eval(pox+1,ptx+1);
			if (isback) memset(pix,'\0',sizeof(double)*32);
			
			//		if ((target->channels-1) > (t = xform->outputsize())){
			//			for(z = t;z< target->channels ;z ++) pix[z] = pix[z-t]*pix[z-t];
			
			
			//	target->addWeigthedPixel(ptx[1],ptx[2],pix+1, weight);
			//	}
		}
	}
	
	
	
}

template< >
double Madstructs::Image<double>::computeArea(Madstructs::Evaluatable* source){
	int x,y;
	double pix[256];
	double piy[32];
	double piz[32];
	double piw[32];
	double pox[256];
	double coor[2];
	double tmp;
	double area =0.0f;
	for(y=0;y<sizey-1;y++){
		
		for(x= 0;x<sizex-1;x++){
			coor[0] =x; coor[1] =y; source->eval(coor,pox); tmp = pox[0];
			coor[0] =x+1; coor[1] =y; source->eval(coor,pox); tmp += pox[0];
			coor[0] =x; coor[1] =y+1; source->eval(coor,pox); tmp += pox[0];
			coor[0] =x+1; coor[1] =y+1; source->eval(coor,pox); tmp += pox[0];
			if (tmp > 0.0f){
				getPixel(x,y,pix);
				getPixel(x+1,y,piy);
				getPixel(x+1,y+1,piz);
				getPixel(x,y+1,piw);
				area += tmp * fabs( (piy[1] - piw[1] + 1)*(pix[2] - piz[2] - 1) + (piz[1] - pix[1] + 1)*(piy[2] - piw[2] - 1)) /8.0f;
			}
		}		
	}
	return(area);
}

// the weigth must be 1.0f for all pixels
template< >
void Madstructs::Image<double>::vectorfieldRescale(double factor){
	int x,y;
	double pix[256];
	double cx = 0.5f * (sizex-1);
	double cy = 0.5f * (sizey-1);
	for(y=0;y<sizey-1;y++){
		for(x= 0;x<sizex-1;x++){
			getPixel(x,y,pix);
			pix[1] = factor * pix[1] + (cx - x) * (1 - factor);
			pix[2] = factor * pix[2] + (cy - y) * (1 - factor);
			setPixel(x,y,pix);
			
		}		
	}
}



template<>
void Madstructs::Image<double>::genStdDevs(int start, int nbchannels){
	int x,y,z;
	double pix[256];
	for(y = 0;y < sizey;y++) for(x = 0;x < sizex;x++){
		getPixel(x,y,pix);
		for(z=0;z<nbchannels;z++) pix[start + z + nbchannels] = sqrt( pix[start + z + nbchannels] - pix[start + z]*pix[start + z]);
		setPixel(x,y,pix);
	}
}




